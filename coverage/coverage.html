
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>admin: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hjanuschka/go-deployd/internal/admin/admin.go (0.0%)</option>
				
				<option value="file1">github.com/hjanuschka/go-deployd/internal/admin/auth.go (0.0%)</option>
				
				<option value="file2">github.com/hjanuschka/go-deployd/internal/admin/events.go (0.0%)</option>
				
				<option value="file3">github.com/hjanuschka/go-deployd/internal/auth/jwt.go (84.0%)</option>
				
				<option value="file4">github.com/hjanuschka/go-deployd/internal/config/security.go (0.0%)</option>
				
				<option value="file5">github.com/hjanuschka/go-deployd/internal/context/context.go (0.0%)</option>
				
				<option value="file6">github.com/hjanuschka/go-deployd/internal/database/column_store.go (0.0%)</option>
				
				<option value="file7">github.com/hjanuschka/go-deployd/internal/database/database.go (0.0%)</option>
				
				<option value="file8">github.com/hjanuschka/go-deployd/internal/database/interfaces.go (83.3%)</option>
				
				<option value="file9">github.com/hjanuschka/go-deployd/internal/database/mongodb.go (0.6%)</option>
				
				<option value="file10">github.com/hjanuschka/go-deployd/internal/database/mysql.go (0.3%)</option>
				
				<option value="file11">github.com/hjanuschka/go-deployd/internal/database/query_builder.go (0.0%)</option>
				
				<option value="file12">github.com/hjanuschka/go-deployd/internal/database/schema.go (5.1%)</option>
				
				<option value="file13">github.com/hjanuschka/go-deployd/internal/database/sqlite.go (18.2%)</option>
				
				<option value="file14">github.com/hjanuschka/go-deployd/internal/database/store.go (0.0%)</option>
				
				<option value="file15">github.com/hjanuschka/go-deployd/internal/database/utils.go (30.3%)</option>
				
				<option value="file16">github.com/hjanuschka/go-deployd/internal/email/email.go (0.0%)</option>
				
				<option value="file17">github.com/hjanuschka/go-deployd/internal/events/compile.go (0.0%)</option>
				
				<option value="file18">github.com/hjanuschka/go-deployd/internal/events/compile_wrapper.go (0.0%)</option>
				
				<option value="file19">github.com/hjanuschka/go-deployd/internal/events/hotreload.go (1.1%)</option>
				
				<option value="file20">github.com/hjanuschka/go-deployd/internal/events/manager.go (1.6%)</option>
				
				<option value="file21">github.com/hjanuschka/go-deployd/internal/events/plugin.go (1.4%)</option>
				
				<option value="file22">github.com/hjanuschka/go-deployd/internal/events/script.go (0.2%)</option>
				
				<option value="file23">github.com/hjanuschka/go-deployd/internal/events/v8_pool.go (12.6%)</option>
				
				<option value="file24">github.com/hjanuschka/go-deployd/internal/logging/logger.go (0.0%)</option>
				
				<option value="file25">github.com/hjanuschka/go-deployd/internal/metrics/collector.go (0.0%)</option>
				
				<option value="file26">github.com/hjanuschka/go-deployd/internal/metrics/middleware.go (0.0%)</option>
				
				<option value="file27">github.com/hjanuschka/go-deployd/internal/resources/collection.go (0.0%)</option>
				
				<option value="file28">github.com/hjanuschka/go-deployd/internal/resources/resource.go (0.0%)</option>
				
				<option value="file29">github.com/hjanuschka/go-deployd/internal/resources/user_collection.go (0.0%)</option>
				
				<option value="file30">github.com/hjanuschka/go-deployd/internal/router/router.go (35.0%)</option>
				
				<option value="file31">github.com/hjanuschka/go-deployd/internal/server/server.go (22.4%)</option>
				
				<option value="file32">github.com/hjanuschka/go-deployd/internal/sessions/session.go (0.0%)</option>
				
				<option value="file33">github.com/hjanuschka/go-deployd/internal/swagger/generator.go (0.0%)</option>
				
				<option value="file34">github.com/hjanuschka/go-deployd/internal/testutil/testutil.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package admin

import (
        "encoding/json"
        "fmt"
        "io/fs"
        "net/http"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/hjanuschka/go-deployd/internal/config"
        "github.com/hjanuschka/go-deployd/internal/database"
        "github.com/hjanuschka/go-deployd/internal/email"
        "github.com/hjanuschka/go-deployd/internal/logging"
        "github.com/hjanuschka/go-deployd/internal/resources"
        "github.com/hjanuschka/go-deployd/internal/router"
        "github.com/hjanuschka/go-deployd/internal/events"
)

type AdminHandler struct {
        db           database.DatabaseInterface
        router       *router.Router
        config       *Config
        resourcesDir string
        AuthHandler  *AuthHandler
}

type Config struct {
        Port           int
        DatabaseHost   string
        DatabasePort   int
        DatabaseName   string
        Development    bool
}

type ServerInfo struct {
        Version     string    `json:"version"`
        GoVersion   string    `json:"goVersion"`
        Uptime      string    `json:"uptime"`
        Database    string    `json:"database"`
        Environment string    `json:"environment"`
        StartTime   time.Time `json:"startTime"`
}

type CollectionInfo struct {
        Name          string                 `json:"name"`
        DocumentCount int64                  `json:"documentCount"`
        Properties    map[string]interface{} `json:"properties"`
        LastModified  time.Time              `json:"lastModified"`
}

func NewAdminHandler(db database.DatabaseInterface, router *router.Router, adminConfig *Config) *AdminHandler <span class="cov0" title="0">{
        // Load security configuration
        securityConfig, err := config.LoadSecurityConfig(config.GetConfigDir())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to load security config: %v\n", err)
                securityConfig = config.DefaultSecurityConfig()
        }</span>
        
        // Log master key on startup
        <span class="cov0" title="0">fmt.Printf("üîê Master Key: %s\n", securityConfig.MasterKey)
        
        authHandler := NewAuthHandler(db, securityConfig)
        
        return &amp;AdminHandler{
                db:           db,
                router:       router,
                config:       adminConfig,
                resourcesDir: "./resources",
                AuthHandler:  authHandler,
        }</span>
}

func (h *AdminHandler) RegisterRoutes(r *mux.Router) <span class="cov0" title="0">{
        admin := r.PathPrefix("/_admin").Subrouter()
        
        // Public authentication routes (no master key required)
        admin.HandleFunc("/auth/validate-master-key", h.AuthHandler.HandleMasterKeyValidation).Methods("POST")
        admin.HandleFunc("/auth/dashboard-login", h.handleDashboardLogin).Methods("POST")
        
        // Protected authentication routes (master key required)
        admin.HandleFunc("/auth/system-login", h.AuthHandler.RequireMasterKey(h.AuthHandler.HandleSystemLogin)).Methods("POST")
        admin.HandleFunc("/auth/security-info", h.AuthHandler.RequireMasterKey(h.AuthHandler.HandleGetSecurityInfo)).Methods("GET")
        admin.HandleFunc("/auth/regenerate-master-key", h.AuthHandler.RequireMasterKey(h.AuthHandler.HandleRegenerateMasterKey)).Methods("POST")
        admin.HandleFunc("/auth/create-user", h.AuthHandler.RequireMasterKey(h.AuthHandler.HandleCreateUser)).Methods("POST")
        
        // Protected admin routes (master key required)
        admin.HandleFunc("/info", h.AuthHandler.RequireMasterKey(h.getServerInfo)).Methods("GET")
        admin.HandleFunc("/collections", h.AuthHandler.RequireMasterKey(h.getCollections)).Methods("GET")
        admin.HandleFunc("/collections/{name}", h.AuthHandler.RequireMasterKey(h.getCollection)).Methods("GET")
        admin.HandleFunc("/collections/{name}", h.AuthHandler.RequireMasterKey(h.createCollection)).Methods("POST")
        admin.HandleFunc("/collections/{name}", h.AuthHandler.RequireMasterKey(h.updateCollection)).Methods("PUT")
        admin.HandleFunc("/collections/{name}", h.AuthHandler.RequireMasterKey(h.deleteCollection)).Methods("DELETE")
        
        // Protected event management endpoints (master key required)
        admin.HandleFunc("/collections/{name}/events", h.AuthHandler.RequireMasterKey(h.getEvents)).Methods("GET")
        admin.HandleFunc("/collections/{name}/events/{event}", h.AuthHandler.RequireMasterKey(h.updateEvent)).Methods("PUT")
        admin.HandleFunc("/collections/{name}/events/{event}/test", h.AuthHandler.RequireMasterKey(h.testEvent)).Methods("POST")
        
        // Security settings management (master key required)
        admin.HandleFunc("/settings/security", h.AuthHandler.RequireMasterKey(h.getSecuritySettings)).Methods("GET")
        admin.HandleFunc("/settings/security", h.AuthHandler.RequireMasterKey(h.updateSecuritySettings)).Methods("PUT")
        
        // Email settings management (master key required)
        admin.HandleFunc("/settings/email", h.AuthHandler.RequireMasterKey(h.getEmailSettings)).Methods("GET")
        admin.HandleFunc("/settings/email", h.AuthHandler.RequireMasterKey(h.updateEmailSettings)).Methods("PUT")
        admin.HandleFunc("/settings/email/test", h.AuthHandler.RequireMasterKey(h.testEmailSettings)).Methods("POST")
        admin.HandleFunc("/settings/email/templates", h.AuthHandler.RequireMasterKey(h.getEmailTemplates)).Methods("GET")
        admin.HandleFunc("/settings/email/templates", h.AuthHandler.RequireMasterKey(h.updateEmailTemplates)).Methods("PUT")
        
        // Logging endpoints (master key required)
        admin.HandleFunc("/logs", h.AuthHandler.RequireMasterKey(h.getLogs)).Methods("GET")
        admin.HandleFunc("/logs/files", h.AuthHandler.RequireMasterKey(h.getLogFiles)).Methods("GET")
        admin.HandleFunc("/logs/download", h.AuthHandler.RequireMasterKey(h.downloadLogs)).Methods("GET")
}</span>

func (h *AdminHandler) getServerInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        info := ServerInfo{
                Version:     "1.0.0",
                GoVersion:   runtime.Version(),
                Database:    string(h.db.GetType()) + " - Connected",
                Environment: "development",
                StartTime:   time.Now().Add(-2 * time.Hour), // Mock uptime
                Uptime:      "2h 15m",
        }
        
        if h.config.Development </span><span class="cov0" title="0">{
                info.Environment = "development"
        }</span> else<span class="cov0" title="0"> {
                info.Environment = "production"
        }</span>
        
        <span class="cov0" title="0">json.NewEncoder(w).Encode(info)</span>
}

func (h *AdminHandler) getCollections(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        collections := []CollectionInfo{}
        
        // Scan resources directory for actual collections
        if _, err := os.Stat(h.resourcesDir); err == nil </span><span class="cov0" title="0">{
                err := filepath.WalkDir(h.resourcesDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        
                        <span class="cov0" title="0">if d.IsDir() &amp;&amp; path != h.resourcesDir </span><span class="cov0" title="0">{
                                configFile := filepath.Join(path, "config.json")
                                if _, err := os.Stat(configFile); err == nil </span><span class="cov0" title="0">{
                                        // Load collection config
                                        data, err := os.ReadFile(configFile)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>
                                        
                                        <span class="cov0" title="0">var config resources.CollectionConfig
                                        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>
                                        
                                        // Get document count from database
                                        <span class="cov0" title="0">collectionName := filepath.Base(path)
                                        store := h.db.CreateStore(collectionName)
                                        count, _ := store.Count(r.Context(), database.NewQueryBuilder())
                                        
                                        // Get file modification time
                                        stat, _ := os.Stat(configFile)
                                        
                                        // Convert properties to interface map and add hardcoded timestamp fields
                                        props := h.buildPropertiesMap(config.Properties)
                                        
                                        collections = append(collections, CollectionInfo{
                                                Name:          collectionName,
                                                DocumentCount: count,
                                                Properties:    props,
                                                LastModified:  stat.ModTime(),
                                        })</span>
                                }
                        }
                        
                        <span class="cov0" title="0">return nil</span>
                })
                
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("Failed to scan collections: %v", err), http.StatusInternalServerError)
                        return
                }</span>
        }
        
        <span class="cov0" title="0">json.NewEncoder(w).Encode(collections)</span>
}

func (h *AdminHandler) getCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        name := vars["name"]
        
        w.Header().Set("Content-Type", "application/json")
        
        collectionDir := filepath.Join(h.resourcesDir, name)
        configFile := filepath.Join(collectionDir, "config.json")
        
        if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>
        
        // Load collection config
        <span class="cov0" title="0">data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to read config: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        <span class="cov0" title="0">var config resources.CollectionConfig
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to parse config: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        // Get document count from database
        <span class="cov0" title="0">store := h.db.CreateStore(name)
        count, _ := store.Count(r.Context(), database.NewQueryBuilder())
        
        // Get file modification time
        stat, _ := os.Stat(configFile)
        
        // Convert properties to interface map and add hardcoded timestamp fields
        props := h.buildPropertiesMap(config.Properties)
        
        collection := CollectionInfo{
                Name:          name,
                DocumentCount: count,
                Properties:    props,
                LastModified:  stat.ModTime(),
        }
        
        json.NewEncoder(w).Encode(collection)</span>
}

func getString(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, exists := m[key]; exists </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// buildPropertiesMap converts collection properties to interface map 
func (h *AdminHandler) buildPropertiesMap(configProperties map[string]resources.Property) map[string]interface{} <span class="cov0" title="0">{
        props := make(map[string]interface{})
        
        // Add properties from config
        for name, prop := range configProperties </span><span class="cov0" title="0">{
                propMap := map[string]interface{}{
                        "type": prop.Type,
                }
                if prop.Required </span><span class="cov0" title="0">{
                        propMap["required"] = true
                }</span>
                <span class="cov0" title="0">if prop.Default != nil </span><span class="cov0" title="0">{
                        propMap["default"] = prop.Default
                }</span>
                <span class="cov0" title="0">if prop.Order != 0 </span><span class="cov0" title="0">{
                        propMap["order"] = prop.Order
                }</span>
                <span class="cov0" title="0">if prop.Unique </span><span class="cov0" title="0">{
                        propMap["unique"] = true
                }</span>
                <span class="cov0" title="0">if prop.System </span><span class="cov0" title="0">{
                        propMap["system"] = true
                        // Only set readonly for specific system fields that should never be edited
                        if name == "createdAt" || name == "updatedAt" || name == "id" || name == "verificationToken" || name == "verificationExpires" </span><span class="cov0" title="0">{
                                propMap["readonly"] = true
                        }</span>
                }
                <span class="cov0" title="0">props[name] = propMap</span>
        }
        
        <span class="cov0" title="0">return props</span>
}

func (h *AdminHandler) createCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        name := vars["name"]
        
        w.Header().Set("Content-Type", "application/json")
        
        var properties map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;properties); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>
        
        // Create collection directory
        <span class="cov0" title="0">collectionDir := filepath.Join(h.resourcesDir, name)
        if err := os.MkdirAll(collectionDir, 0755); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to create directory: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        // Convert properties to proper format
        <span class="cov0" title="0">configProps := make(map[string]resources.Property)
        for propName, propData := range properties </span><span class="cov0" title="0">{
                if propMap, ok := propData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        prop := resources.Property{
                                Type: getString(propMap, "type"),
                        }
                        if required, exists := propMap["required"]; exists </span><span class="cov0" title="0">{
                                if reqBool, ok := required.(bool); ok </span><span class="cov0" title="0">{
                                        prop.Required = reqBool
                                }</span>
                        }
                        <span class="cov0" title="0">if defaultVal, exists := propMap["default"]; exists </span><span class="cov0" title="0">{
                                prop.Default = defaultVal
                        }</span>
                        <span class="cov0" title="0">if order, exists := propMap["order"]; exists </span><span class="cov0" title="0">{
                                if orderInt, ok := order.(float64); ok </span><span class="cov0" title="0">{
                                        prop.Order = int(orderInt)
                                }</span>
                        }
                        <span class="cov0" title="0">if unique, exists := propMap["unique"]; exists </span><span class="cov0" title="0">{
                                if uniqueBool, ok := unique.(bool); ok </span><span class="cov0" title="0">{
                                        prop.Unique = uniqueBool
                                }</span>
                        }
                        <span class="cov0" title="0">if system, exists := propMap["system"]; exists </span><span class="cov0" title="0">{
                                if systemBool, ok := system.(bool); ok </span><span class="cov0" title="0">{
                                        prop.System = systemBool
                                }</span>
                        }
                        <span class="cov0" title="0">configProps[propName] = prop</span>
                }
        }
        
        // Create config structure
        <span class="cov0" title="0">config := resources.CollectionConfig{
                Properties: configProps,
        }
        
        // Write config.json
        configFile := filepath.Join(collectionDir, "config.json")
        configData, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to marshal config: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        <span class="cov0" title="0">if err := os.WriteFile(configFile, configData, 0644); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to write config: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        // Load and register the collection with router
        <span class="cov0" title="0">collection, err := resources.LoadCollectionFromConfig(name, collectionDir, h.db)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to load collection: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        // Add to router (we need to implement this)
        <span class="cov0" title="0">h.router.AddResource(collection)
        
        // Return created collection info with hardcoded timestamp fields
        // Convert the created properties to the proper format
        createdProps := h.buildPropertiesMap(configProps)
        response := CollectionInfo{
                Name:          name,
                DocumentCount: 0,
                Properties:    createdProps,
                LastModified:  time.Now(),
        }
        
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(response)</span>
}

func (h *AdminHandler) updateCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        name := vars["name"]
        
        w.Header().Set("Content-Type", "application/json")
        
        var properties map[string]interface{}
        if err := json.NewDecoder(r.Body).Decode(&amp;properties); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>
        
        <span class="cov0" title="0">collectionDir := filepath.Join(h.resourcesDir, name)
        configFile := filepath.Join(collectionDir, "config.json")
        
        if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>
        
        // Convert properties to proper format
        <span class="cov0" title="0">configProps := make(map[string]resources.Property)
        for propName, propData := range properties </span><span class="cov0" title="0">{
                if propMap, ok := propData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        prop := resources.Property{
                                Type: getString(propMap, "type"),
                        }
                        if required, exists := propMap["required"]; exists </span><span class="cov0" title="0">{
                                if reqBool, ok := required.(bool); ok </span><span class="cov0" title="0">{
                                        prop.Required = reqBool
                                }</span>
                        }
                        <span class="cov0" title="0">if defaultVal, exists := propMap["default"]; exists </span><span class="cov0" title="0">{
                                prop.Default = defaultVal
                        }</span>
                        <span class="cov0" title="0">if order, exists := propMap["order"]; exists </span><span class="cov0" title="0">{
                                if orderInt, ok := order.(float64); ok </span><span class="cov0" title="0">{
                                        prop.Order = int(orderInt)
                                }</span>
                        }
                        <span class="cov0" title="0">if unique, exists := propMap["unique"]; exists </span><span class="cov0" title="0">{
                                if uniqueBool, ok := unique.(bool); ok </span><span class="cov0" title="0">{
                                        prop.Unique = uniqueBool
                                }</span>
                        }
                        <span class="cov0" title="0">if system, exists := propMap["system"]; exists </span><span class="cov0" title="0">{
                                if systemBool, ok := system.(bool); ok </span><span class="cov0" title="0">{
                                        prop.System = systemBool
                                }</span>
                        }
                        <span class="cov0" title="0">configProps[propName] = prop</span>
                }
        }
        
        // Create config structure
        <span class="cov0" title="0">config := resources.CollectionConfig{
                Properties: configProps,
        }
        
        // Write updated config.json
        configData, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to marshal config: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        <span class="cov0" title="0">if err := os.WriteFile(configFile, configData, 0644); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to write config: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        // Reload collection in router
        <span class="cov0" title="0">collection, err := resources.LoadCollectionFromConfig(name, collectionDir, h.db)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to reload collection: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        <span class="cov0" title="0">h.router.UpdateResource(name, collection)
        
        // Get document count from database
        store := h.db.CreateStore(name)
        count, _ := store.Count(r.Context(), database.NewQueryBuilder())
        
        // Convert the updated properties to include hardcoded timestamp fields
        updatedProps := h.buildPropertiesMap(configProps)
        response := CollectionInfo{
                Name:          name,
                DocumentCount: count,
                Properties:    updatedProps,
                LastModified:  time.Now(),
        }
        
        json.NewEncoder(w).Encode(response)</span>
}

func (h *AdminHandler) deleteCollection(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        name := vars["name"]
        
        w.Header().Set("Content-Type", "application/json")
        
        collectionDir := filepath.Join(h.resourcesDir, name)
        
        // Remove from router first
        h.router.RemoveResource(name)
        
        // Delete the directory
        if err := os.RemoveAll(collectionDir); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to delete collection: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        <span class="cov0" title="0">response := map[string]interface{}{
                "deleted": name,
                "success": true,
        }
        
        json.NewEncoder(w).Encode(response)</span>
}

// Event management methods
func (h *AdminHandler) getEvents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        collectionName := vars["name"]
        
        w.Header().Set("Content-Type", "application/json")
        
        collectionDir := filepath.Join(h.resourcesDir, collectionName)
        
        if _, err := os.Stat(collectionDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>
        
        <span class="cov0" title="0">scripts := make(map[string]string)
        types := make(map[string]string)
        
        eventFiles := []string{"get", "post", "put", "delete", "validate", "beforerequest", "aftercommit"}
        
        for _, eventName := range eventFiles </span><span class="cov0" title="0">{
                // Check for JavaScript file
                jsFile := filepath.Join(collectionDir, eventName+".js")
                if data, err := os.ReadFile(jsFile); err == nil </span><span class="cov0" title="0">{
                        scripts[eventName] = string(data)
                        types[eventName] = "js"
                }</span>
                
                // Check for Go file (only if no JS file)
                <span class="cov0" title="0">if _, exists := scripts[eventName]; !exists </span><span class="cov0" title="0">{
                        goFile := filepath.Join(collectionDir, eventName+".go")
                        if data, err := os.ReadFile(goFile); err == nil </span><span class="cov0" title="0">{
                                scripts[eventName] = string(data)
                                types[eventName] = "go"
                        }</span>
                }
        }
        
        // Get hot-reload info if available
        <span class="cov0" title="0">hotReload := make(map[string]interface{})
        if collection := h.router.GetCollection(collectionName); collection != nil </span><span class="cov0" title="0">{
                hotReload = collection.GetHotReloadInfo()
        }</span>
        
        <span class="cov0" title="0">response := map[string]interface{}{
                "scripts":    scripts,
                "types":      types,
                "hotReload":  hotReload,
                "collection": collectionName,
        }
        
        json.NewEncoder(w).Encode(response)</span>
}

func (h *AdminHandler) updateEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        collectionName := vars["name"]
        eventName := vars["event"]
        
        w.Header().Set("Content-Type", "application/json")
        
        var request struct {
                Script string `json:"script"`
                Type   string `json:"type"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>
        
        <span class="cov0" title="0">collectionDir := filepath.Join(h.resourcesDir, collectionName)
        
        if _, err := os.Stat(collectionDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>
        
        // Remove existing event files
        <span class="cov0" title="0">jsFile := filepath.Join(collectionDir, eventName+".js")
        goFile := filepath.Join(collectionDir, eventName+".go")
        os.Remove(jsFile)
        os.Remove(goFile)
        
        var filePath string
        if request.Type == "go" </span><span class="cov0" title="0">{
                filePath = goFile
        }</span> else<span class="cov0" title="0"> {
                filePath = jsFile
        }</span>
        
        // Write the script file
        <span class="cov0" title="0">if err := os.WriteFile(filePath, []byte(request.Script), 0644); err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to write script: %v", err), http.StatusInternalServerError)
                return
        }</span>
        
        // Reload scripts in collection
        <span class="cov0" title="0">if collection := h.router.GetCollection(collectionName); collection != nil </span><span class="cov0" title="0">{
                if request.Type == "go" </span><span class="cov0" title="0">{
                        // Use hot-reload for Go scripts
                        eventType := events.EventType(strings.ToUpper(eventName))
                        if err := collection.LoadHotReloadScript(eventType, request.Script); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, fmt.Sprintf("Failed to load Go script: %v", err), http.StatusInternalServerError)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Reload all scripts for JS
                        if err := collection.ReloadScripts(); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, fmt.Sprintf("Failed to reload scripts: %v", err), http.StatusInternalServerError)
                                return
                        }</span>
                }
        }
        
        <span class="cov0" title="0">response := map[string]interface{}{
                "success":    true,
                "message":    eventName + " event updated successfully",
                "type":       request.Type,
                "hotReload":  request.Type == "go",
                "collection": collectionName,
                "event":      eventName,
        }
        
        json.NewEncoder(w).Encode(response)</span>
}

func (h *AdminHandler) testEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        collectionName := vars["name"]
        eventName := vars["event"]
        
        w.Header().Set("Content-Type", "application/json")
        
        var request struct {
                Data       map[string]interface{} `json:"data"`
                User       map[string]interface{} `json:"user"`
                Query      map[string]interface{} `json:"query"`
                ScriptType string                 `json:"scriptType"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>
        
        <span class="cov0" title="0">collection := h.router.GetCollection(collectionName)
        if collection == nil </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>
        
        // Create a mock context for testing
        // TODO: Create proper test context
        <span class="cov0" title="0">response := map[string]interface{}{
                "success":    true,
                "duration":   50,
                "data":       request.Data,
                "collection": collectionName,
                "event":      eventName,
                "scriptType": request.ScriptType,
        }
        
        // Simulate some validation
        if eventName == "validate" </span><span class="cov0" title="0">{
                if title, exists := request.Data["title"]; !exists || title == "" </span><span class="cov0" title="0">{
                        response["success"] = false
                        response["errors"] = map[string]string{
                                "title": "Title is required",
                        }
                }</span>
        }
        
        <span class="cov0" title="0">json.NewEncoder(w).Encode(response)</span>
}

// handleDashboardLogin handles dashboard login with master key
func (h *AdminHandler) handleDashboardLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        var req struct {
                MasterKey string `json:"masterKey"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // Validate master key
        <span class="cov0" title="0">if !h.AuthHandler.Security.ValidateMasterKey(req.MasterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid master key",
                })
                return
        }</span>
        
        // Set master key cookie for dashboard access
        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     "masterKey",
                Value:    req.MasterKey,
                Path:     "/_dashboard",
                HttpOnly: true,
                Secure:   false, // Set to true in production with HTTPS
                SameSite: http.SameSiteStrictMode,
        })
        
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Dashboard login successful",
        })</span>
}

// getSecuritySettings returns the current security settings
func (h *AdminHandler) getSecuritySettings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        response := map[string]interface{}{
                "jwtExpiration":     h.AuthHandler.Security.JWTExpiration,
                "allowRegistration": h.AuthHandler.Security.AllowRegistration,
                "hasMasterKey":      h.AuthHandler.Security.MasterKey != "",
        }
        
        json.NewEncoder(w).Encode(response)
}</span>

// updateSecuritySettings updates the security settings
func (h *AdminHandler) updateSecuritySettings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        var req struct {
                JWTExpiration     string `json:"jwtExpiration"`
                AllowRegistration bool   `json:"allowRegistration"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // Update security config
        <span class="cov0" title="0">h.AuthHandler.Security.JWTExpiration = req.JWTExpiration
        h.AuthHandler.Security.AllowRegistration = req.AllowRegistration
        
        // Save updated configuration
        if err := config.SaveSecurityConfig(h.AuthHandler.Security, config.GetConfigDir()); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to save security settings",
                })
                return
        }</span>
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Security settings updated successfully",
        })</span>
}

// getLogs returns application logs with optional filtering
func (h *AdminHandler) getLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        // Get query parameters
        level := r.URL.Query().Get("level")
        filename := r.URL.Query().Get("file")
        limitStr := r.URL.Query().Get("limit")
        
        // Set default limit
        limit := 100
        if limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }
        
        <span class="cov0" title="0">logger := logging.GetLogger()
        logLevel := logging.LogLevel(level)
        
        logs, err := logger.ReadLogs(filename, logLevel)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to read logs",
                        "error":   err.Error(),
                })
                return
        }</span>
        
        // Apply limit (get most recent entries)
        <span class="cov0" title="0">if len(logs) &gt; limit </span><span class="cov0" title="0">{
                logs = logs[len(logs)-limit:]
        }</span>
        
        <span class="cov0" title="0">response := map[string]interface{}{
                "success": true,
                "logs":    logs,
                "count":   len(logs),
        }
        
        json.NewEncoder(w).Encode(response)</span>
}

// getLogFiles returns available log files
func (h *AdminHandler) getLogFiles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        logger := logging.GetLogger()
        files, err := logger.GetLogFiles()
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to list log files",
                        "error":   err.Error(),
                })
                return
        }</span>
        
        <span class="cov0" title="0">response := map[string]interface{}{
                "success": true,
                "files":   files,
        }
        
        json.NewEncoder(w).Encode(response)</span>
}

// downloadLogs allows downloading log files
func (h *AdminHandler) downloadLogs(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get query parameters
        level := r.URL.Query().Get("level")
        filename := r.URL.Query().Get("file")
        
        logger := logging.GetLogger()
        logPath := logger.GetLogPath(filename)
        
        // Check if file exists
        if _, err := os.Stat(logPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusNotFound)
                w.Write([]byte("Log file not found"))
                return
        }</span>
        
        // Set headers for file download
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", filepath.Base(logPath)))
        
        // If level filter is specified, filter the logs
        if level != "" </span><span class="cov0" title="0">{
                logs, err := logger.ReadLogs(filename, logging.LogLevel(level))
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        w.Write([]byte("Failed to read logs"))
                        return
                }</span>
                
                // Write filtered logs as JSONL
                <span class="cov0" title="0">for _, log := range logs </span><span class="cov0" title="0">{
                        data, _ := json.Marshal(log)
                        w.Write(data)
                        w.Write([]byte("\n"))
                }</span>
                <span class="cov0" title="0">return</span>
        }
        
        // Otherwise, serve the raw file
        <span class="cov0" title="0">http.ServeFile(w, r, logPath)</span>
}

// getEmailSettings returns the current email settings
func (h *AdminHandler) getEmailSettings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        response := map[string]interface{}{
                "provider": h.AuthHandler.Security.Email.Provider,
                "smtp": map[string]interface{}{
                        "host":     h.AuthHandler.Security.Email.SMTP.Host,
                        "port":     h.AuthHandler.Security.Email.SMTP.Port,
                        "username": h.AuthHandler.Security.Email.SMTP.Username,
                        "tls":      h.AuthHandler.Security.Email.SMTP.TLS,
                        // Don't expose password
                        "hasPassword": h.AuthHandler.Security.Email.SMTP.Password != "",
                },
                "ses": map[string]interface{}{
                        "region": h.AuthHandler.Security.Email.SES.Region,
                        // Don't expose credentials
                        "hasAccessKeyId":     h.AuthHandler.Security.Email.SES.AccessKeyID != "",
                        "hasSecretAccessKey": h.AuthHandler.Security.Email.SES.SecretAccessKey != "",
                },
                "from":                h.AuthHandler.Security.Email.From,
                "fromName":            h.AuthHandler.Security.Email.FromName,
                "requireVerification": h.AuthHandler.Security.RequireVerification,
        }
        
        json.NewEncoder(w).Encode(response)
}</span>

// updateEmailSettings updates the email settings
func (h *AdminHandler) updateEmailSettings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        var req struct {
                Provider string `json:"provider"`
                SMTP     struct {
                        Host     string `json:"host"`
                        Port     int    `json:"port"`
                        Username string `json:"username"`
                        Password string `json:"password"`
                        TLS      bool   `json:"tls"`
                } `json:"smtp"`
                SES struct {
                        Region          string `json:"region"`
                        AccessKeyID     string `json:"accessKeyId"`
                        SecretAccessKey string `json:"secretAccessKey"`
                } `json:"ses"`
                From                string `json:"from"`
                FromName            string `json:"fromName"`
                RequireVerification bool   `json:"requireVerification"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // Update email config
        <span class="cov0" title="0">h.AuthHandler.Security.Email.Provider = req.Provider
        h.AuthHandler.Security.Email.From = req.From
        h.AuthHandler.Security.Email.FromName = req.FromName
        h.AuthHandler.Security.RequireVerification = req.RequireVerification
        
        // Update SMTP settings
        h.AuthHandler.Security.Email.SMTP.Host = req.SMTP.Host
        h.AuthHandler.Security.Email.SMTP.Port = req.SMTP.Port
        h.AuthHandler.Security.Email.SMTP.Username = req.SMTP.Username
        h.AuthHandler.Security.Email.SMTP.TLS = req.SMTP.TLS
        // Only update password if provided
        if req.SMTP.Password != "" </span><span class="cov0" title="0">{
                h.AuthHandler.Security.Email.SMTP.Password = req.SMTP.Password
        }</span>
        
        // Update SES settings
        <span class="cov0" title="0">h.AuthHandler.Security.Email.SES.Region = req.SES.Region
        // Only update credentials if provided
        if req.SES.AccessKeyID != "" </span><span class="cov0" title="0">{
                h.AuthHandler.Security.Email.SES.AccessKeyID = req.SES.AccessKeyID
        }</span>
        <span class="cov0" title="0">if req.SES.SecretAccessKey != "" </span><span class="cov0" title="0">{
                h.AuthHandler.Security.Email.SES.SecretAccessKey = req.SES.SecretAccessKey
        }</span>
        
        // Save updated configuration
        <span class="cov0" title="0">if err := config.SaveSecurityConfig(h.AuthHandler.Security, config.GetConfigDir()); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to save email settings",
                })
                return
        }</span>
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Email settings updated successfully",
        })</span>
}

// testEmailSettings sends a test email
func (h *AdminHandler) testEmailSettings(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        var req struct {
                To string `json:"to"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        <span class="cov0" title="0">if req.To == "" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Recipient email address is required",
                })
                return
        }</span>
        
        // Create email service and send test email
        <span class="cov0" title="0">emailService := email.NewEmailService(&amp;h.AuthHandler.Security.Email)
        if err := emailService.TestEmail(req.To); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": fmt.Sprintf("Failed to send test email: %v", err),
                })
                return
        }</span>
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Test email sent successfully",
        })</span>
}

// EmailTemplate represents a customizable email template
type EmailTemplate struct {
        Name      string `json:"name"`
        Subject   string `json:"subject"`
        HTMLBody  string `json:"htmlBody"`
        TextBody  string `json:"textBody"`
        Variables []string `json:"variables"`
}

// getEmailTemplates returns available email templates
func (h *AdminHandler) getEmailTemplates(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        // Define available templates with their default content
        templates := []EmailTemplate{
                {
                        Name:    "verification",
                        Subject: "Verify your email address",
                        HTMLBody: `&lt;html&gt;
&lt;body&gt;
        &lt;h2&gt;Welcome to Go-Deployd!&lt;/h2&gt;
        &lt;p&gt;Hi {{.Username}},&lt;/p&gt;
        &lt;p&gt;Please verify your email address by clicking the link below:&lt;/p&gt;
        &lt;p&gt;&lt;a href="{{.VerificationURL}}" style="background-color: #4CAF50; color: white; padding: 14px 25px; text-decoration: none; display: inline-block;"&gt;Verify Email&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;Or copy and paste this URL into your browser:&lt;/p&gt;
        &lt;p&gt;{{.VerificationURL}}&lt;/p&gt;
        &lt;p&gt;This link will expire in 24 hours.&lt;/p&gt;
        &lt;p&gt;If you didn't create an account, please ignore this email.&lt;/p&gt;
        &lt;br&gt;
        &lt;p&gt;Best regards,&lt;br&gt;Go-Deployd Team&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`,
                        TextBody: `Welcome to Go-Deployd!

Hi {{.Username}},

Please verify your email address by visiting this URL:
{{.VerificationURL}}

This link will expire in 24 hours.

If you didn't create an account, please ignore this email.

Best regards,
Go-Deployd Team`,
                        Variables: []string{"Username", "VerificationURL"},
                },
                {
                        Name:    "passwordReset",
                        Subject: "Reset your password",
                        HTMLBody: `&lt;html&gt;
&lt;body&gt;
        &lt;h2&gt;Password Reset Request&lt;/h2&gt;
        &lt;p&gt;Hi {{.Username}},&lt;/p&gt;
        &lt;p&gt;We received a request to reset your password. Click the link below to create a new password:&lt;/p&gt;
        &lt;p&gt;&lt;a href="{{.ResetURL}}" style="background-color: #2196F3; color: white; padding: 14px 25px; text-decoration: none; display: inline-block;"&gt;Reset Password&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;Or copy and paste this URL into your browser:&lt;/p&gt;
        &lt;p&gt;{{.ResetURL}}&lt;/p&gt;
        &lt;p&gt;This link will expire in 1 hour.&lt;/p&gt;
        &lt;p&gt;If you didn't request a password reset, please ignore this email.&lt;/p&gt;
        &lt;br&gt;
        &lt;p&gt;Best regards,&lt;br&gt;Go-Deployd Team&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`,
                        TextBody: `Password Reset Request

Hi {{.Username}},

We received a request to reset your password. Visit this URL to create a new password:
{{.ResetURL}}

This link will expire in 1 hour.

If you didn't request a password reset, please ignore this email.

Best regards,
Go-Deployd Team`,
                        Variables: []string{"Username", "ResetURL"},
                },
        }
        
        // TODO: Load custom templates from storage if they exist
        
        json.NewEncoder(w).Encode(map[string]interface{}{
                "templates": templates,
        })
}</span>

// updateEmailTemplates updates email templates
func (h *AdminHandler) updateEmailTemplates(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        var req struct {
                Templates []EmailTemplate `json:"templates"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // TODO: Save custom templates to storage
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Email templates updated successfully",
        })</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package admin

import (
        "context"
        "encoding/json"
        "net/http"
        "strings"
        "time"

        "github.com/hjanuschka/go-deployd/internal/auth"
        "github.com/hjanuschka/go-deployd/internal/config"
        "github.com/hjanuschka/go-deployd/internal/database"
        "golang.org/x/crypto/bcrypt"
)

// AuthHandler handles system-level authentication with master key
type AuthHandler struct {
        db         database.DatabaseInterface
        Security   *config.SecurityConfig
        jwtManager *auth.JWTManager
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(db database.DatabaseInterface, security *config.SecurityConfig) *AuthHandler <span class="cov0" title="0">{
        // Parse JWT expiration duration
        jwtDuration, err := time.ParseDuration(security.JWTExpiration)
        if err != nil </span><span class="cov0" title="0">{
                jwtDuration = 24 * time.Hour // Default to 24 hours
        }</span>
        
        // Create JWT manager
        <span class="cov0" title="0">jwtManager := auth.NewJWTManager(security.JWTSecret, jwtDuration)
        
        return &amp;AuthHandler{
                db:         db,
                Security:   security,
                jwtManager: jwtManager,
        }</span>
}

// SystemLoginRequest represents a system login request using master key
type SystemLoginRequest struct {
        Username string `json:"username"`
        Email    string `json:"email"`
}

// SystemLoginResponse represents the response from system login
// DEPRECATED: Use JWT authentication endpoints instead
type SystemLoginResponse struct {
        Success     bool        `json:"success"`
        Token       string      `json:"token"`
        User        interface{} `json:"user"`
        Message     string      `json:"message"`
        ExpiresAt   string      `json:"expiresAt"`
}

// HandleSystemLogin performs authentication using master key and user identifier
func (ah *AuthHandler) HandleSystemLogin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method != "POST" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Method not allowed",
                })
                return
        }</span>
        
        <span class="cov0" title="0">var req struct {
                Email string `json:"email"`
                Username string `json:"username"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // Either email or username must be provided
        <span class="cov0" title="0">if req.Email == "" &amp;&amp; req.Username == "" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Either email or username must be provided",
                })
                return
        }</span>
        
        // Find user by email or username
        <span class="cov0" title="0">store := ah.db.CreateStore("users")
        query := database.NewQueryBuilder()
        
        if req.Email != "" </span><span class="cov0" title="0">{
                query.Where("email", "=", req.Email)
        }</span> else<span class="cov0" title="0"> {
                query.Where("username", "=", req.Username)
        }</span>
        
        <span class="cov0" title="0">userData, err := store.FindOne(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusNotFound)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "User not found",
                })
                return
        }</span>
        
        // Extract user information
        <span class="cov0" title="0">userID, _ := userData["id"].(string)
        username, _ := userData["username"].(string)
        role, _ := userData["role"].(string)
        isRoot := (role == "admin")
        
        // Generate JWT token for the user
        token, err := ah.jwtManager.GenerateToken(userID, username, isRoot)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to generate token",
                })
                return
        }</span>
        
        // Parse JWT expiration duration
        <span class="cov0" title="0">jwtDuration, err := time.ParseDuration(ah.Security.JWTExpiration)
        if err != nil </span><span class="cov0" title="0">{
                jwtDuration = 24 * time.Hour // Default to 24 hours
        }</span>
        <span class="cov0" title="0">expiresAt := time.Now().Add(jwtDuration).Unix()
        
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "token": token,
                "expiresAt": expiresAt,
                "isRoot": isRoot,
                "user": map[string]interface{}{
                        "id": userID,
                        "username": username,
                        "email": userData["email"],
                        "role": role,
                },
        })</span>
}

// HandleMasterKeyValidation validates a master key without performing authentication
func (ah *AuthHandler) HandleMasterKeyValidation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method != "POST" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "valid": false,
                        "message": "Method not allowed",
                })
                return
        }</span>
        
        <span class="cov0" title="0">var req struct {
                MasterKey string `json:"masterKey"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "valid": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        <span class="cov0" title="0">valid := ah.Security.ValidateMasterKey(req.MasterKey)
        
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "valid": valid,
                "message": func() string </span><span class="cov0" title="0">{
                        if valid </span><span class="cov0" title="0">{
                                return "Master key is valid"
                        }</span>
                        <span class="cov0" title="0">return "Invalid master key"</span>
                }(),
        })
}

// HandleGetSecurityInfo returns non-sensitive security configuration info
func (ah *AuthHandler) HandleGetSecurityInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method != "GET" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Method not allowed",
                })
                return
        }</span>
        
        // Check if master key is provided for admin access
        <span class="cov0" title="0">masterKey := r.Header.Get("X-Master-Key")
        isAdmin := ah.Security.ValidateMasterKey(masterKey)
        
        response := map[string]interface{}{
                "jwtExpiration":     ah.Security.JWTExpiration,
                "allowRegistration": ah.Security.AllowRegistration,
        }
        
        // Only show master key info to authenticated admin
        if isAdmin </span><span class="cov0" title="0">{
                response["hasMasterKey"] = ah.Security.MasterKey != ""
                response["masterKeyPrefix"] = func() string </span><span class="cov0" title="0">{
                        if len(ah.Security.MasterKey) &gt; 10 </span><span class="cov0" title="0">{
                                return ah.Security.MasterKey[:10] + "..."
                        }</span>
                        <span class="cov0" title="0">return "***"</span>
                }()
        }
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(response)</span>
}

// HandleRegenerateMasterKey regenerates the master key (requires current master key)
func (ah *AuthHandler) HandleRegenerateMasterKey(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method != "POST" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Method not allowed",
                })
                return
        }</span>
        
        <span class="cov0" title="0">var req struct {
                CurrentMasterKey string `json:"currentMasterKey"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // Validate current master key
        <span class="cov0" title="0">if !ah.Security.ValidateMasterKey(req.CurrentMasterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid current master key",
                })
                return
        }</span>
        
        // Generate new master key
        <span class="cov0" title="0">newMasterKey := generateNewMasterKey()
        ah.Security.MasterKey = newMasterKey
        
        // Save updated configuration
        if err := config.SaveSecurityConfig(ah.Security, config.GetConfigDir()); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to save new master key",
                })
                return
        }</span>
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Master key regenerated successfully",
                "newMasterKey": newMasterKey,
        })</span>
}

// Middleware to require master key authentication
func (ah *AuthHandler) RequireMasterKey(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                masterKey := r.Header.Get("X-Master-Key")
                if masterKey == "" </span><span class="cov0" title="0">{
                        // Also check Authorization header with Bearer format
                        auth := r.Header.Get("Authorization")
                        if strings.HasPrefix(auth, "Bearer ") </span><span class="cov0" title="0">{
                                masterKey = strings.TrimPrefix(auth, "Bearer ")
                        }</span>
                }
                
                // Also check cookie for dashboard requests
                <span class="cov0" title="0">if masterKey == "" </span><span class="cov0" title="0">{
                        if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                                masterKey = cookie.Value
                        }</span>
                }
                
                <span class="cov0" title="0">if !ah.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "error": "Master key required",
                                "message": "This endpoint requires a valid master key",
                        })
                        return
                }</span>
                
                // Master key authentication provides admin privileges automatically
                // isRoot behavior is handled by the master key validation itself
                
                <span class="cov0" title="0">next(w, r)</span>
        }
}

// CreateUserRequest represents a request to create a user with master key
type CreateUserRequest struct {
        UserData map[string]interface{} `json:"userData"`
}

// HandleCreateUser creates a user with master key authentication
func (ah *AuthHandler) HandleCreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method != "POST" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Method not allowed",
                })
                return
        }</span>
        
        <span class="cov0" title="0">var req CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Invalid JSON body",
                })
                return
        }</span>
        
        // Master key is validated by RequireMasterKey middleware
        // No need to validate it again here
        
        // Validate required user data
        <span class="cov0" title="0">email, hasEmail := req.UserData["email"].(string)
        username, hasUsername := req.UserData["username"].(string)
        password, hasPassword := req.UserData["password"].(string)
        
        if !hasEmail &amp;&amp; !hasUsername </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Username or email is required",
                })
                return
        }</span>
        
        <span class="cov0" title="0">if !hasPassword || password == "" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Password is required",
                })
                return
        }</span>
        
        // Check if user already exists
        <span class="cov0" title="0">userStore := ah.db.CreateStore("users")
        
        if hasEmail </span><span class="cov0" title="0">{
                query := database.NewQueryBuilder().Where("email", "$eq", email)
                existing, err := userStore.FindOne(r.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "success": false,
                                "message": "Database error",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusConflict)
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "success": false,
                                "message": "User with this email already exists",
                        })
                        return
                }</span>
        }
        
        <span class="cov0" title="0">if hasUsername </span><span class="cov0" title="0">{
                query := database.NewQueryBuilder().Where("username", "$eq", username)
                existing, err := userStore.FindOne(r.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "success": false,
                                "message": "Database error",
                        })
                        return
                }</span>
                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusConflict)
                        json.NewEncoder(w).Encode(map[string]interface{}{
                                "success": false,
                                "message": "User with this username already exists",
                        })
                        return
                }</span>
        }
        
        // Hash password
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), 12)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to hash password",
                })
                return
        }</span>
        
        // Set hashed password and default role
        <span class="cov0" title="0">req.UserData["password"] = string(hashedPassword)
        if _, hasRole := req.UserData["role"]; !hasRole </span><span class="cov0" title="0">{
                req.UserData["role"] = "user"
        }</span>
        
        // Create user
        <span class="cov0" title="0">result, err := userStore.Insert(r.Context(), req.UserData)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Failed to create user",
                })
                return
        }</span>
        
        // Convert result to map and remove password from response
        <span class="cov0" title="0">var userResult map[string]interface{}
        if resultMap, ok := result.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                userResult = resultMap
                delete(userResult, "password")
        }</span> else<span class="cov0" title="0"> {
                // Fallback - return the original user data without password
                userResult = make(map[string]interface{})
                for k, v := range req.UserData </span><span class="cov0" title="0">{
                        if k != "password" </span><span class="cov0" title="0">{
                                userResult[k] = v
                        }</span>
                }
        }
        
        <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "User created successfully",
                "user":    userResult,
        })</span>
}

// Helper functions
func getStringField(data map[string]interface{}, field string) string <span class="cov0" title="0">{
        if val, ok := data[field].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func generateNewMasterKey() string <span class="cov0" title="0">{
        // Use the same generation logic as in config package
        return "mk_regenerated_" + strings.Replace(time.Now().Format("20060102150405"), " ", "", -1)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package admin

import (
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/hjanuschka/go-deployd/internal/events"
        "github.com/hjanuschka/go-deployd/internal/resources"
        appcontext "github.com/hjanuschka/go-deployd/internal/context"
        "go.mongodb.org/mongo-driver/bson"
)

// EventsHandler handles event script management
type EventsHandler struct {
        collections map[string]*resources.Collection
}

// NewEventsHandler creates a new events handler
func NewEventsHandler(collections map[string]*resources.Collection) *EventsHandler <span class="cov0" title="0">{
        return &amp;EventsHandler{
                collections: collections,
        }
}</span>

// GetEvents returns all event scripts for a collection
func (eh *EventsHandler) GetEvents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        collectionName := strings.TrimPrefix(r.URL.Path, "/api/_admin/collections/")
        collectionName = strings.Split(collectionName, "/")[0]

        collection, exists := eh.collections[collectionName]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>

        // Get script information
        <span class="cov0" title="0">scripts := make(map[string]interface{})
        types := make(map[string]string)

        // Check for existing script files
        eventTypes := []string{"get", "validate", "post", "put", "delete", "aftercommit", "beforerequest"}
        
        for _, eventType := range eventTypes </span><span class="cov0" title="0">{
                // Check for .js file
                jsPath := filepath.Join(collection.GetConfigPath(), eventType+".js")
                if content, err := os.ReadFile(jsPath); err == nil </span><span class="cov0" title="0">{
                        scripts[eventType] = string(content)
                        types[eventType] = "js"
                }</span>

                // Check for .go file
                <span class="cov0" title="0">goPath := filepath.Join(collection.GetConfigPath(), eventType+".go")
                if content, err := os.ReadFile(goPath); err == nil </span><span class="cov0" title="0">{
                        scripts[eventType] = string(content)
                        types[eventType] = "go"
                }</span>
        }

        // Get hot-reload info
        <span class="cov0" title="0">hotReloadInfo := collection.GetHotReloadInfo()

        response := map[string]interface{}{
                "scripts":    scripts,
                "types":      types,
                "hotReload":  hotReloadInfo,
                "collection": collectionName,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// UpdateEvent updates a specific event script
func (eh *EventsHandler) UpdateEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/_admin/collections/"), "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                http.Error(w, "Invalid path", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">collectionName := parts[0]
        eventName := parts[2]

        collection, exists := eh.collections[collectionName]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Script string `json:"script"`
                Type   string `json:"type"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Validate event type
        <span class="cov0" title="0">validEvents := map[string]events.EventType{
                "get":           events.EventGet,
                "validate":      events.EventValidate,
                "post":          events.EventPost,
                "put":           events.EventPut,
                "delete":        events.EventDelete,
                "aftercommit":   events.EventAfterCommit,
                "beforerequest": events.EventBeforeRequest,
        }

        eventType, validEvent := validEvents[eventName]
        if !validEvent </span><span class="cov0" title="0">{
                http.Error(w, "Invalid event type", http.StatusBadRequest)
                return
        }</span>

        // Handle different script types
        <span class="cov0" title="0">switch request.Type </span>{
        case "go":<span class="cov0" title="0">
                // Hot-reload Go script using interpreter
                if err := collection.LoadHotReloadScript(eventType, request.Script); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("Failed to load Go script: %v", err), http.StatusBadRequest)
                        return
                }</span>

                // Optionally save to file
                <span class="cov0" title="0">filePath := filepath.Join(collection.GetConfigPath(), eventName+".go")
                if err := eh.saveScriptToFile(filePath, request.Script, "go"); err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail the request
                        fmt.Printf("Warning: Failed to save Go script to file: %v\n", err)
                }</span>

        case "js":<span class="cov0" title="0">
                // Save JavaScript file and reload
                filePath := filepath.Join(collection.GetConfigPath(), eventName+".js")
                if err := eh.saveScriptToFile(filePath, request.Script, "js"); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("Failed to save script: %v", err), http.StatusInternalServerError)
                        return
                }</span>

                // Reload JavaScript scripts
                <span class="cov0" title="0">if err := collection.ReloadScripts(); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("Failed to reload scripts: %v", err), http.StatusInternalServerError)
                        return
                }</span>

        default:<span class="cov0" title="0">
                http.Error(w, "Invalid script type", http.StatusBadRequest)
                return</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "success":    true,
                "message":    fmt.Sprintf("%s event updated successfully", eventName),
                "type":       request.Type,
                "hotReload":  request.Type == "go",
                "collection": collectionName,
                "event":      eventName,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// TestEvent tests an event script with mock data
func (eh *EventsHandler) TestEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        parts := strings.Split(strings.TrimPrefix(r.URL.Path, "/api/_admin/collections/"), "/")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                http.Error(w, "Invalid path", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">collectionName := parts[0]
        eventName := parts[2]

        collection, exists := eh.collections[collectionName]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Collection not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                Data       bson.M `json:"data"`
                User       bson.M `json:"user,omitempty"`
                Query      bson.M `json:"query,omitempty"`
                ScriptType string `json:"scriptType"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Create mock context
        <span class="cov0" title="0">mockCtx := eh.createMockContext(request.Data, request.User, request.Query)

        // Map event name to event type
        eventTypeMap := map[string]events.EventType{
                "get":           events.EventGet,
                "validate":      events.EventValidate,
                "post":          events.EventPost,
                "put":           events.EventPut,
                "delete":        events.EventDelete,
                "aftercommit":   events.EventAfterCommit,
                "beforerequest": events.EventBeforeRequest,
        }

        eventType, exists := eventTypeMap[eventName]
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Invalid event type", http.StatusBadRequest)
                return
        }</span>

        // Test the event
        <span class="cov0" title="0">startTime := now()
        var testErr error
        var resultData bson.M = request.Data

        if request.ScriptType == "go" </span><span class="cov0" title="0">{
                // Test hot-reloaded Go script
                testErr = collection.TestHotReloadScript(eventType, mockCtx, resultData)
        }</span> else<span class="cov0" title="0"> {
                // Test JavaScript script
                testErr = collection.TestScript(eventType, mockCtx, resultData)
        }</span>

        <span class="cov0" title="0">duration := int(now().Sub(startTime).Milliseconds())

        // Prepare response
        response := map[string]interface{}{
                "success":    testErr == nil,
                "duration":   duration,
                "data":       resultData,
                "collection": collectionName,
                "event":      eventName,
                "scriptType": request.ScriptType,
        }

        if testErr != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := testErr.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        response["error"] = scriptErr.Message
                        response["statusCode"] = scriptErr.StatusCode
                }</span> else<span class="cov0" title="0"> if validationErr, ok := testErr.(*events.ValidationError); ok </span><span class="cov0" title="0">{
                        response["errors"] = validationErr.Errors
                }</span> else<span class="cov0" title="0"> {
                        response["error"] = testErr.Error()
                }</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// saveScriptToFile saves a script to the filesystem
func (eh *EventsHandler) saveScriptToFile(filePath, content, scriptType string) error <span class="cov0" title="0">{
        // Create directory if it doesn't exist
        dir := filepath.Dir(filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add package declaration for Go files  
        <span class="cov0" title="0">if scriptType == "go" &amp;&amp; !strings.Contains(content, "package ") </span><span class="cov0" title="0">{
                content = "package main\n\n" + content
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filePath, []byte(content), 0644)</span>
}

// createMockContext creates a mock context for testing
func (eh *EventsHandler) createMockContext(data, user, query bson.M) *appcontext.Context <span class="cov0" title="0">{
        // This is a simplified mock context for testing
        // In a real implementation, you'd create a proper mock HTTP request/response
        return &amp;appcontext.Context{
                Query:  query,
                Body:   data,
                Method: "POST", // Default method
                // Session: mockSession with user data
        }
}</span>

// Helper function to get current time (for easier testing)
var now = func() time.Time <span class="cov0" title="0">{
        return time.Now()
}</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "crypto/rand"
        "encoding/base64"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

var (
        ErrInvalidToken = errors.New("invalid token")
        ErrTokenExpired = errors.New("token expired")
)

type JWTClaims struct {
        UserID   string `json:"user_id,omitempty"`
        Username string `json:"username,omitempty"`
        IsRoot   bool   `json:"is_root"`
        jwt.RegisteredClaims
}

type JWTManager struct {
        secretKey      []byte
        tokenDuration  time.Duration
        issuer         string
}

func NewJWTManager(secretKey string, tokenDuration time.Duration) *JWTManager <span class="cov7" title="8">{
        return &amp;JWTManager{
                secretKey:     []byte(secretKey),
                tokenDuration: tokenDuration,
                issuer:        "go-deployd",
        }
}</span>

// GenerateToken creates a new JWT token
func (m *JWTManager) GenerateToken(userID, username string, isRoot bool) (string, error) <span class="cov9" title="13">{
        claims := &amp;JWTClaims{
                UserID:   userID,
                Username: username,
                IsRoot:   isRoot,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    m.issuer,
                        Subject:   userID,
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(m.tokenDuration)),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        ID:        generateTokenID(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(m.secretKey)
}</span>

// ValidateToken verifies and parses a JWT token
func (m *JWTManager) ValidateToken(tokenString string) (*JWTClaims, error) <span class="cov10" title="17">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov9" title="14">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov9" title="14">return m.secretKey, nil</span>
        })

        <span class="cov10" title="17">if err != nil </span><span class="cov7" title="8">{
                // Check if it's an expiration error
                if strings.Contains(err.Error(), "token is expired") </span><span class="cov4" title="3">{
                        return nil, ErrTokenExpired
                }</span>
                <span class="cov6" title="5">return nil, err</span>
        }

        <span class="cov7" title="9">claims, ok := token.Claims.(*JWTClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov7" title="9">if !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov7" title="9">return claims, nil</span>
}

// GenerateSecretKey creates a new random secret key
func GenerateSecretKey() (string, error) <span class="cov8" title="10">{
        key := make([]byte, 32)
        if _, err := rand.Read(key); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="10">return base64.URLEncoding.EncodeToString(key), nil</span>
}

func generateTokenID() string <span class="cov9" title="13">{
        b := make([]byte, 16)
        rand.Read(b)
        return base64.URLEncoding.EncodeToString(b)
}</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// SecurityConfig holds security-related configuration
type SecurityConfig struct {
        MasterKey           string      `json:"masterKey"`
        AllowRegistration   bool        `json:"allowRegistration"`   // allow public user registration
        JWTSecret           string      `json:"jwtSecret"`           // JWT signing secret
        JWTExpiration       string      `json:"jwtExpiration"`       // JWT expiration duration (e.g., "24h", "1d")
        RequireVerification bool        `json:"requireVerification"` // require email verification for new users
        Email               EmailConfig `json:"email"`               // email configuration for verification
}

// EmailConfig holds email service configuration
type EmailConfig struct {
        Provider string     `json:"provider"` // "smtp" or "ses"
        SMTP     SMTPConfig `json:"smtp"`     // SMTP configuration
        SES      SESConfig  `json:"ses"`      // AWS SES configuration
        From     string     `json:"from"`     // sender email address
        FromName string     `json:"fromName"` // sender display name
}

// SMTPConfig holds SMTP server configuration
type SMTPConfig struct {
        Host     string `json:"host"`     // SMTP server hostname
        Port     int    `json:"port"`     // SMTP server port
        Username string `json:"username"` // SMTP username
        Password string `json:"password"` // SMTP password
        TLS      bool   `json:"tls"`      // use TLS encryption
}

// SESConfig holds AWS SES configuration
type SESConfig struct {
        Region          string `json:"region"`          // AWS region
        AccessKeyID     string `json:"accessKeyId"`     // AWS access key ID
        SecretAccessKey string `json:"secretAccessKey"` // AWS secret access key
}

// DefaultSecurityConfig returns the default security configuration
func DefaultSecurityConfig() *SecurityConfig <span class="cov0" title="0">{
        return &amp;SecurityConfig{
                MasterKey:           "",
                AllowRegistration:   true,  // allow registration by default
                JWTSecret:           "",
                JWTExpiration:       "24h", // 24 hours default
                RequireVerification: true,  // require email verification by default
                Email: EmailConfig{
                        Provider: "smtp", // SMTP is default
                        SMTP: SMTPConfig{
                                Host:     "smtp.gmail.com",
                                Port:     587,
                                Username: "",
                                Password: "",
                                TLS:      true,
                        },
                        SES: SESConfig{
                                Region:          "us-east-1",
                                AccessKeyID:     "",
                                SecretAccessKey: "",
                        },
                        From:     "noreply@example.com",
                        FromName: "Go-Deployd",
                },
        }
}</span>

// LoadSecurityConfig loads security configuration from file or creates default
func LoadSecurityConfig(configDir string) (*SecurityConfig, error) <span class="cov0" title="0">{
        // Ensure config directory exists
        if err := os.MkdirAll(configDir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create config directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">configFile := filepath.Join(configDir, "security.json")
        
        // Check if config file exists
        if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create default config with generated master key
                config := DefaultSecurityConfig()
                config.MasterKey = generateMasterKey()
                
                if err := SaveSecurityConfig(config, configDir); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save default security config: %w", err)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("üîê Generated new master key and saved to %s\n", configFile)
                fmt.Printf("   Master Key: %s\n", config.MasterKey)
                fmt.Printf("   Keep this key secure! It provides administrative access.\n")
                
                return config, nil</span>
        }
        
        // Load existing config
        <span class="cov0" title="0">data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read security config: %w", err)
        }</span>
        
        <span class="cov0" title="0">var config SecurityConfig
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse security config: %w", err)
        }</span>
        
        // Generate master key if it's missing
        <span class="cov0" title="0">if config.MasterKey == "" </span><span class="cov0" title="0">{
                config.MasterKey = generateMasterKey()
                if err := SaveSecurityConfig(&amp;config, configDir); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save updated security config: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("üîê Generated missing master key: %s\n", config.MasterKey)</span>
        }
        
        // Generate JWT secret if it's missing
        <span class="cov0" title="0">if config.JWTSecret == "" </span><span class="cov0" title="0">{
                config.JWTSecret = generateJWTSecret()
                if err := SaveSecurityConfig(&amp;config, configDir); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save updated security config: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("üîë Generated JWT secret\n")</span>
        }
        
        // Set default JWT expiration if missing
        <span class="cov0" title="0">if config.JWTExpiration == "" </span><span class="cov0" title="0">{
                config.JWTExpiration = "24h"
                if err := SaveSecurityConfig(&amp;config, configDir); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save updated security config: %w", err)
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;config, nil</span>
}

// SaveSecurityConfig saves security configuration to file
func SaveSecurityConfig(config *SecurityConfig, configDir string) error <span class="cov0" title="0">{
        configFile := filepath.Join(configDir, "security.json")
        
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal security config: %w", err)
        }</span>
        
        // Write with restricted permissions (600 = owner read/write only)
        <span class="cov0" title="0">if err := os.WriteFile(configFile, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write security config: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// generateMasterKey generates a cryptographically secure master key
func generateMasterKey() string <span class="cov0" title="0">{
        // Generate 48 bytes (384 bits) of random data
        bytes := make([]byte, 48)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                // Fallback to a deterministic but still reasonably secure method
                panic(fmt.Sprintf("failed to generate secure random key: %v", err))</span>
        }
        
        <span class="cov0" title="0">return "mk_" + hex.EncodeToString(bytes)</span>
}

// generateJWTSecret generates a cryptographically secure JWT secret
func generateJWTSecret() string <span class="cov0" title="0">{
        // Generate 32 bytes (256 bits) of random data
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to generate secure JWT secret: %v", err))</span>
        }
        
        <span class="cov0" title="0">return hex.EncodeToString(bytes)</span>
}

// ValidateMasterKey checks if the provided key matches the configured master key
func (sc *SecurityConfig) ValidateMasterKey(providedKey string) bool <span class="cov0" title="0">{
        return providedKey != "" &amp;&amp; providedKey == sc.MasterKey
}</span>

// GetConfigDir returns the default configuration directory
func GetConfigDir() string <span class="cov0" title="0">{
        // Use current directory + .deployd for configuration
        // In production, this could be /etc/deployd or ~/.deployd
        return ".deployd"
}</pre>
		
		<pre class="file" id="file5" style="display: none">package context

import (
        "context"
        "encoding/json"
        "net/http"
        "strconv"
        "strings"

)

type Context struct {
        Request      *http.Request
        Response     http.ResponseWriter
        Resource     Resource
        Router       Router
        URL          string
        Query        map[string]interface{}
        Body         map[string]interface{}
        Method       string
        Development  bool
        // JWT Authentication data
        UserID       string
        Username     string
        IsRoot       bool
        IsAuthenticated bool
        ctx          context.Context
}

type Resource interface {
        GetName() string
        GetPath() string
}


type Router interface {
        Route(ctx *Context) error
}

// AuthData contains authentication information
type AuthData struct {
        UserID       string
        Username     string
        IsRoot       bool
        IsAuthenticated bool
}

func New(req *http.Request, res http.ResponseWriter, resource Resource, auth *AuthData, development bool) *Context <span class="cov0" title="0">{
        ctx := &amp;Context{
                Request:      req,
                Response:     res,
                Resource:     resource,
                Method:       req.Method,
                Development:  development,
                ctx:          req.Context(),
        }

        // Set authentication data
        if auth != nil </span><span class="cov0" title="0">{
                ctx.UserID = auth.UserID
                ctx.Username = auth.Username
                ctx.IsRoot = auth.IsRoot
                ctx.IsAuthenticated = auth.IsAuthenticated
        }</span>

        <span class="cov0" title="0">ctx.parseURL()
        ctx.parseQuery()
        ctx.parseBody()

        return ctx</span>
}


func (c *Context) parseURL() <span class="cov0" title="0">{
        c.URL = c.Request.URL.Path
        if c.Resource != nil </span><span class="cov0" title="0">{
                resourcePath := c.Resource.GetPath()
                if strings.HasPrefix(c.URL, resourcePath) </span><span class="cov0" title="0">{
                        c.URL = strings.TrimPrefix(c.URL, resourcePath)
                }</span>
        }
        <span class="cov0" title="0">if c.URL == "" </span><span class="cov0" title="0">{
                c.URL = "/"
        }</span>
}

func (c *Context) parseQuery() <span class="cov0" title="0">{
        c.Query = make(map[string]interface{})
        
        for key, values := range c.Request.URL.Query() </span><span class="cov0" title="0">{
                if len(values) == 1 </span><span class="cov0" title="0">{
                        // Try to parse as different types
                        value := values[0]
                        
                        // Try to parse as JSON
                        if strings.HasPrefix(value, "{") &amp;&amp; strings.HasSuffix(value, "}") </span><span class="cov0" title="0">{
                                var jsonValue interface{}
                                if err := json.Unmarshal([]byte(value), &amp;jsonValue); err == nil </span><span class="cov0" title="0">{
                                        c.Query[key] = jsonValue
                                        continue</span>
                                }
                        }
                        
                        // Try to parse as number
                        <span class="cov0" title="0">if num, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                                c.Query[key] = num
                                continue</span>
                        }
                        
                        // Try to parse as boolean
                        <span class="cov0" title="0">if value == "true" </span><span class="cov0" title="0">{
                                c.Query[key] = true
                                continue</span>
                        }
                        <span class="cov0" title="0">if value == "false" </span><span class="cov0" title="0">{
                                c.Query[key] = false
                                continue</span>
                        }
                        
                        // Default to string
                        <span class="cov0" title="0">c.Query[key] = value</span>
                } else<span class="cov0" title="0"> {
                        // Multiple values as array
                        var convertedValues []interface{}
                        for _, v := range values </span><span class="cov0" title="0">{
                                convertedValues = append(convertedValues, v)
                        }</span>
                        <span class="cov0" title="0">c.Query[key] = convertedValues</span>
                }
        }
}

func (c *Context) parseBody() <span class="cov0" title="0">{
        c.Body = make(map[string]interface{})
        
        if c.Request.Body == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">contentType := c.Request.Header.Get("Content-Type")
        
        if strings.Contains(contentType, "application/json") </span><span class="cov0" title="0">{
                var jsonBody map[string]interface{}
                err := json.NewDecoder(c.Request.Body).Decode(&amp;jsonBody)
                if err == nil </span><span class="cov0" title="0">{
                        for k, v := range jsonBody </span><span class="cov0" title="0">{
                                c.Body[k] = v
                        }</span>
                }
        } else<span class="cov0" title="0"> if strings.Contains(contentType, "application/x-www-form-urlencoded") </span><span class="cov0" title="0">{
                if err := c.Request.ParseForm(); err == nil </span><span class="cov0" title="0">{
                        for key, values := range c.Request.PostForm </span><span class="cov0" title="0">{
                                if len(values) == 1 </span><span class="cov0" title="0">{
                                        c.Body[key] = values[0]
                                }</span> else<span class="cov0" title="0"> {
                                        c.Body[key] = values
                                }</span>
                        }
                }
        }
}

func (c *Context) ParseJSON(v interface{}) error <span class="cov0" title="0">{
        return json.NewDecoder(c.Request.Body).Decode(v)
}</span>

func (c *Context) WriteJSON(data interface{}) error <span class="cov0" title="0">{
        c.Response.Header().Set("Content-Type", "application/json")
        return json.NewEncoder(c.Response).Encode(data)
}</span>

func (c *Context) WriteError(statusCode int, message string) error <span class="cov0" title="0">{
        c.Response.Header().Set("Content-Type", "application/json")
        c.Response.WriteHeader(statusCode)
        return json.NewEncoder(c.Response).Encode(map[string]interface{}{
                "error":   true,
                "message": message,
                "status":  statusCode,
        })
}</span>

func (c *Context) GetID() string <span class="cov0" title="0">{
        // Try to get ID from URL path
        if c.URL != "/" </span><span class="cov0" title="0">{
                parts := strings.Split(strings.Trim(c.URL, "/"), "/")
                if len(parts) &gt; 0 &amp;&amp; parts[0] != "" </span><span class="cov0" title="0">{
                        return parts[0]
                }</span>
        }
        
        // Try to get ID from query
        <span class="cov0" title="0">if id, exists := c.Query["id"]; exists </span><span class="cov0" title="0">{
                if idStr, ok := id.(string); ok </span><span class="cov0" title="0">{
                        return idStr
                }</span>
        }
        
        // Try to get ID from body
        <span class="cov0" title="0">if id, exists := c.Body["id"]; exists </span><span class="cov0" title="0">{
                if idStr, ok := id.(string); ok </span><span class="cov0" title="0">{
                        return idStr
                }</span>
        }
        
        <span class="cov0" title="0">return ""</span>
}

func (c *Context) Context() context.Context <span class="cov0" title="0">{
        return c.ctx
}</span>

func (c *Context) Done(err error, result interface{}) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                c.WriteError(500, err.Error())
                return
        }</span>
        
        <span class="cov0" title="0">if result != nil </span><span class="cov0" title="0">{
                c.WriteJSON(result)
        }</span> else<span class="cov0" title="0"> {
                c.Response.WriteHeader(204) // No Content
        }</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/hjanuschka/go-deployd/internal/metrics"
)

// ColumnStore implements StoreInterface using column-based storage
type ColumnStore struct {
        tableName     string
        db            *sql.DB
        database      DatabaseInterface
        schema        *CollectionSchema
        schemaManager *SchemaManager
}

// NewColumnStore creates a new column-based store
func NewColumnStore(tableName string, db *sql.DB, database DatabaseInterface, schemaManager *SchemaManager) (*ColumnStore, error) <span class="cov0" title="0">{
        store := &amp;ColumnStore{
                tableName:     tableName,
                db:            db,
                database:      database,
                schemaManager: schemaManager,
        }

        // Load schema and ensure table exists
        schema, err := schemaManager.GetSchema(tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get schema: %w", err)
        }</span>

        <span class="cov0" title="0">store.schema = schema

        // Ensure table schema is up to date
        if err := schemaManager.EnsureSchema(tableName); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ensure schema: %w", err)
        }</span>

        <span class="cov0" title="0">return store, nil</span>
}

// CreateUniqueIdentifier generates a unique ID
func (s *ColumnStore) CreateUniqueIdentifier() string <span class="cov0" title="0">{
        return generateUniqueID()
}</span>

// Insert inserts a document using column-based storage
func (s *ColumnStore) Insert(ctx context.Context, document interface{}) (interface{}, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                metrics.RecordDatabaseOperation("insert", time.Since(start), nil)
        }</span>()

        <span class="cov0" title="0">doc, ok := document.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                err := fmt.Errorf("document must be a map[string]interface{}")
                metrics.RecordDatabaseOperation("insert", time.Since(start), err)
                return nil, err
        }</span>

        // Ensure the document has an ID
        <span class="cov0" title="0">if _, exists := doc["id"]; !exists </span><span class="cov0" title="0">{
                doc["id"] = s.CreateUniqueIdentifier()
        }</span>

        // Add timestamps
        <span class="cov0" title="0">now := time.Now()
        if _, exists := doc["createdAt"]; !exists </span><span class="cov0" title="0">{
                doc["createdAt"] = now
        }</span>
        <span class="cov0" title="0">if _, exists := doc["updatedAt"]; !exists </span><span class="cov0" title="0">{
                doc["updatedAt"] = now
        }</span>

        // Separate fields into columns and JSON data
        <span class="cov0" title="0">columnValues, jsonData, err := s.separateData(doc)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to separate data: %w", err)
                metrics.RecordDatabaseOperation("insert", time.Since(start), err)
                return nil, err
        }</span>

        // Build INSERT SQL
        <span class="cov0" title="0">sql, args, err := s.buildInsertSQL(columnValues, jsonData)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to build insert SQL: %w", err)
                metrics.RecordDatabaseOperation("insert", time.Since(start), err)
                return nil, err
        }</span>

        // Execute insert
        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to insert document: %w", err)
                metrics.RecordDatabaseOperation("insert", time.Since(start), err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return doc, nil</span>
}

// separateData separates document data into column values and JSON overflow
func (s *ColumnStore) separateData(doc map[string]interface{}) (map[string]interface{}, map[string]interface{}, error) <span class="cov0" title="0">{
        if !s.schema.UseColumns </span><span class="cov0" title="0">{
                // Use JSON-only storage
                return map[string]interface{}{
                        "id":         doc["id"],
                        "created_at": doc["createdAt"],
                        "updated_at": doc["updatedAt"],
                }, doc, nil
        }</span>

        <span class="cov0" title="0">columnValues := make(map[string]interface{})
        jsonData := make(map[string]interface{})

        // Create column name lookup
        columnMap := make(map[string]ColumnDefinition)
        for _, col := range s.schema.Columns </span><span class="cov0" title="0">{
                columnMap[col.Name] = col
        }</span>

        <span class="cov0" title="0">for key, value := range doc </span><span class="cov0" title="0">{
                if col, hasColumn := columnMap[key]; hasColumn &amp;&amp; col.Name != "data" </span><span class="cov0" title="0">{
                        // Store in column
                        convertedValue, err := s.convertValueForColumn(value, col)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("failed to convert value for column %s: %w", key, err)
                        }</span>
                        <span class="cov0" title="0">columnValues[key] = convertedValue</span>
                } else<span class="cov0" title="0"> {
                        // Store in JSON data column
                        jsonData[key] = value
                }</span>
        }

        <span class="cov0" title="0">return columnValues, jsonData, nil</span>
}

// convertValueForColumn converts a value to the appropriate type for a column
func (s *ColumnStore) convertValueForColumn(value interface{}, col ColumnDefinition) (interface{}, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">switch col.Type </span>{
        case ColumnTypeText:<span class="cov0" title="0">
                return fmt.Sprintf("%v", value), nil</span>
        case ColumnTypeInteger:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case int:<span class="cov0" title="0">
                        return int64(v), nil</span>
                case int32:<span class="cov0" title="0">
                        return int64(v), nil</span>
                case int64:<span class="cov0" title="0">
                        return v, nil</span>
                case float64:<span class="cov0" title="0">
                        return int64(v), nil</span>
                case string:<span class="cov0" title="0">
                        // Try to parse as number
                        return fmt.Sprintf("%v", value), nil</span>
                default:<span class="cov0" title="0">
                        return fmt.Sprintf("%v", value), nil</span>
                }
        case ColumnTypeReal:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case float64:<span class="cov0" title="0">
                        return v, nil</span>
                case float32:<span class="cov0" title="0">
                        return float64(v), nil</span>
                case int:<span class="cov0" title="0">
                        return float64(v), nil</span>
                case int64:<span class="cov0" title="0">
                        return float64(v), nil</span>
                default:<span class="cov0" title="0">
                        return fmt.Sprintf("%v", value), nil</span>
                }
        case ColumnTypeBoolean:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case bool:<span class="cov0" title="0">
                        return v, nil</span>
                case string:<span class="cov0" title="0">
                        return v == "true" || v == "1", nil</span>
                case int:<span class="cov0" title="0">
                        return v != 0, nil</span>
                case float64:<span class="cov0" title="0">
                        return v != 0, nil</span>
                default:<span class="cov0" title="0">
                        return false, nil</span>
                }
        case ColumnTypeDate:<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case time.Time:<span class="cov0" title="0">
                        return v, nil</span>
                case string:<span class="cov0" title="0">
                        // Try to parse as time
                        if t, err := time.Parse(time.RFC3339, v); err == nil </span><span class="cov0" title="0">{
                                return t, nil
                        }</span>
                        <span class="cov0" title="0">return v, nil</span>
                default:<span class="cov0" title="0">
                        return fmt.Sprintf("%v", value), nil</span>
                }
        case ColumnTypeJSON:<span class="cov0" title="0">
                // Convert to JSON string
                jsonBytes, err := json.Marshal(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return string(jsonBytes), nil</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", value), nil</span>
        }
}

// buildInsertSQL builds the INSERT SQL statement
func (s *ColumnStore) buildInsertSQL(columnValues map[string]interface{}, jsonData map[string]interface{}) (string, []interface{}, error) <span class="cov0" title="0">{
        quotedTable := s.quoteIdentifier(s.tableName)
        
        var columns []string
        var placeholders []string
        var args []interface{}

        // Add column values
        for key, value := range columnValues </span><span class="cov0" title="0">{
                columns = append(columns, s.quoteIdentifier(key))
                placeholders = append(placeholders, "?")
                args = append(args, value)
        }</span>

        // Add JSON data if there's any overflow or if using JSON-only mode
        <span class="cov0" title="0">if len(jsonData) &gt; 0 </span><span class="cov0" title="0">{
                jsonBytes, err := json.Marshal(jsonData)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("failed to marshal JSON data: %w", err)
                }</span>

                <span class="cov0" title="0">columns = append(columns, s.quoteIdentifier("data"))
                placeholders = append(placeholders, "?")
                args = append(args, string(jsonBytes))</span>
        }

        <span class="cov0" title="0">sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)",
                quotedTable,
                strings.Join(columns, ", "),
                strings.Join(placeholders, ", "))

        return sql, args, nil</span>
}

// Find performs a column-aware query
func (s *ColumnStore) Find(ctx context.Context, query QueryBuilder, opts QueryOptions) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        sql, args, err := s.buildSelectSQL(query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build select SQL: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return s.scanRows(rows, opts.Fields)</span>
}

// buildSelectSQL builds the SELECT SQL statement with column-aware WHERE clauses
func (s *ColumnStore) buildSelectSQL(query QueryBuilder, opts QueryOptions) (string, []interface{}, error) <span class="cov0" title="0">{
        quotedTable := s.quoteIdentifier(s.tableName)
        
        // Select all columns by default
        selectClause := "*"
        if len(opts.Fields) &gt; 0 </span><span class="cov0" title="0">{
                selectClause = s.buildSelectClause(opts.Fields)
        }</span>

        <span class="cov0" title="0">sql := fmt.Sprintf("SELECT %s FROM %s", selectClause, quotedTable)
        var args []interface{}

        // Build WHERE clause using column-aware query builder
        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                sql += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        // Add ORDER BY with column-aware sorting
        <span class="cov0" title="0">if len(opts.Sort) &gt; 0 </span><span class="cov0" title="0">{
                orderClause := s.buildOrderClause(opts.Sort)
                sql += " ORDER BY " + orderClause
        }</span>

        // Add LIMIT and OFFSET
        <span class="cov0" title="0">if opts.Limit != nil </span><span class="cov0" title="0">{
                sql += fmt.Sprintf(" LIMIT %d", *opts.Limit)
        }</span>
        <span class="cov0" title="0">if opts.Skip != nil </span><span class="cov0" title="0">{
                sql += fmt.Sprintf(" OFFSET %d", *opts.Skip)
        }</span>

        <span class="cov0" title="0">return sql, args, nil</span>
}

// buildSelectClause builds the SELECT clause for field projection
func (s *ColumnStore) buildSelectClause(fields map[string]int) string <span class="cov0" title="0">{
        if !s.schema.UseColumns </span><span class="cov0" title="0">{
                return "*" // For JSON-only tables, select everything
        }</span>

        <span class="cov0" title="0">var columns []string
        hasInclusions := false
        
        // Check if this is inclusion or exclusion mode
        for _, include := range fields </span><span class="cov0" title="0">{
                if include == 1 </span><span class="cov0" title="0">{
                        hasInclusions = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if hasInclusions </span><span class="cov0" title="0">{
                // Include mode: only select specified fields
                columns = append(columns, s.quoteIdentifier("id")) // Always include id
                
                for field, include := range fields </span><span class="cov0" title="0">{
                        if include == 1 &amp;&amp; field != "id" </span><span class="cov0" title="0">{
                                if s.hasColumn(field) </span><span class="cov0" title="0">{
                                        columns = append(columns, s.quoteIdentifier(field))
                                }</span>
                        }
                }
                
                // If any non-column fields are requested, include data column
                <span class="cov0" title="0">for field, include := range fields </span><span class="cov0" title="0">{
                        if include == 1 &amp;&amp; !s.hasColumn(field) </span><span class="cov0" title="0">{
                                columns = append(columns, s.quoteIdentifier("data"))
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Exclusion mode: select all except specified fields
                for _, col := range s.schema.Columns </span><span class="cov0" title="0">{
                        if exclude, exists := fields[col.Name]; !exists || exclude != 0 </span><span class="cov0" title="0">{
                                columns = append(columns, s.quoteIdentifier(col.Name))
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(columns) == 0 </span><span class="cov0" title="0">{
                return "*"
        }</span>

        <span class="cov0" title="0">return strings.Join(columns, ", ")</span>
}

// hasColumn checks if a field has a dedicated column
func (s *ColumnStore) hasColumn(fieldName string) bool <span class="cov0" title="0">{
        for _, col := range s.schema.Columns </span><span class="cov0" title="0">{
                if col.Name == fieldName &amp;&amp; col.Name != "data" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// buildWhereClause builds a column-aware WHERE clause
func (s *ColumnStore) buildWhereClause(query QueryBuilder) (string, []interface{}) <span class="cov0" title="0">{
        if sqlQuery, ok := query.(*SQLQueryBuilder); ok </span><span class="cov0" title="0">{
                return sqlQuery.ToSQL()
        }</span>

        // Convert from map-based query with column awareness
        <span class="cov0" title="0">queryMap := query.ToMap()
        if len(queryMap) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">sqlBuilder := NewSQLQueryBuilder()
        s.convertMapToColumnSQL(queryMap, sqlBuilder)
        return sqlBuilder.ToSQL()</span>
}

// convertMapToColumnSQL converts a MongoDB-style query to column-aware SQL
func (s *ColumnStore) convertMapToColumnSQL(queryMap map[string]interface{}, builder *SQLQueryBuilder) <span class="cov0" title="0">{
        for field, value := range queryMap </span><span class="cov0" title="0">{
                if field == "$or" </span><span class="cov0" title="0">{
                        // Handle OR conditions
                        if orConditions, ok := value.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                                var orBuilders []QueryBuilder
                                for _, orCond := range orConditions </span><span class="cov0" title="0">{
                                        orBuilder := NewSQLQueryBuilder()
                                        s.convertMapToColumnSQL(orCond, orBuilder)
                                        orBuilders = append(orBuilders, orBuilder)
                                }</span>
                                <span class="cov0" title="0">builder.Or(orBuilders...)</span>
                        }
                } else<span class="cov0" title="0"> if strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        // Skip other MongoDB operators at root level
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // Regular field condition - use column if available
                        if valueMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                // Field has operators
                                for op, opValue := range valueMap </span><span class="cov0" title="0">{
                                        s.addColumnCondition(builder, field, op, opValue)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Simple equality
                                s.addColumnCondition(builder, field, "$eq", value)
                        }</span>
                }
        }
}

// addColumnCondition adds a condition using column-aware field access
func (s *ColumnStore) addColumnCondition(builder *SQLQueryBuilder, field, op string, value interface{}) <span class="cov0" title="0">{
        if s.hasColumn(field) </span><span class="cov0" title="0">{
                // Use direct column access
                builder.Where(field, op, value)
        }</span> else<span class="cov0" title="0"> {
                // Use JSON extraction from data column
                jsonPath := fmt.Sprintf("$.%s", field)
                switch s.database.GetType() </span>{
                case DatabaseTypeSQLite:<span class="cov0" title="0">
                        builder.WhereRaw(fmt.Sprintf("JSON_EXTRACT(data, ?) %s ?", s.mongoOpToSQL(op)), jsonPath, value)</span>
                case DatabaseTypeMySQL:<span class="cov0" title="0">
                        builder.WhereRaw(fmt.Sprintf("JSON_EXTRACT(data, ?) %s ?", s.mongoOpToSQL(op)), jsonPath, value)</span>
                }
        }
}

// mongoOpToSQL converts MongoDB operators to SQL operators
func (s *ColumnStore) mongoOpToSQL(op string) string <span class="cov0" title="0">{
        switch op </span>{
        case "$eq":<span class="cov0" title="0">
                return "="</span>
        case "$ne":<span class="cov0" title="0">
                return "!="</span>
        case "$gt":<span class="cov0" title="0">
                return "&gt;"</span>
        case "$gte":<span class="cov0" title="0">
                return "&gt;="</span>
        case "$lt":<span class="cov0" title="0">
                return "&lt;"</span>
        case "$lte":<span class="cov0" title="0">
                return "&lt;="</span>
        case "$in":<span class="cov0" title="0">
                return "IN"</span>
        case "$nin":<span class="cov0" title="0">
                return "NOT IN"</span>
        case "$regex":<span class="cov0" title="0">
                return "REGEXP"</span>
        default:<span class="cov0" title="0">
                return "="</span>
        }
}

// buildOrderClause builds column-aware ORDER BY clause
func (s *ColumnStore) buildOrderClause(sort map[string]int) string <span class="cov0" title="0">{
        var orderParts []string
        
        for field, direction := range sort </span><span class="cov0" title="0">{
                dir := "ASC"
                if direction == -1 </span><span class="cov0" title="0">{
                        dir = "DESC"
                }</span>

                <span class="cov0" title="0">if s.hasColumn(field) </span><span class="cov0" title="0">{
                        // Use direct column
                        orderParts = append(orderParts, fmt.Sprintf("%s %s", s.quoteIdentifier(field), dir))
                }</span> else<span class="cov0" title="0"> {
                        // Use JSON extraction
                        jsonPath := fmt.Sprintf("$.%s", field)
                        switch s.database.GetType() </span>{
                        case DatabaseTypeSQLite:<span class="cov0" title="0">
                                orderParts = append(orderParts, fmt.Sprintf("JSON_EXTRACT(data, '%s') %s", jsonPath, dir))</span>
                        case DatabaseTypeMySQL:<span class="cov0" title="0">
                                orderParts = append(orderParts, fmt.Sprintf("JSON_EXTRACT(data, '%s') %s", jsonPath, dir))</span>
                        }
                }
        }

        <span class="cov0" title="0">return strings.Join(orderParts, ", ")</span>
}

// scanRows scans database rows and reconstructs documents
func (s *ColumnStore) scanRows(rows *sql.Rows, fields map[string]int) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}

        for rows.Next() </span><span class="cov0" title="0">{
                // Create slice for scanning
                values := make([]interface{}, len(columns))
                valuePtrs := make([]interface{}, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                // Reconstruct document
                <span class="cov0" title="0">doc := make(map[string]interface{})

                for i, columnName := range columns </span><span class="cov0" title="0">{
                        value := values[i]

                        if columnName == "data" &amp;&amp; value != nil </span><span class="cov0" title="0">{
                                // Merge JSON data
                                if jsonStr, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        var jsonData map[string]interface{}
                                        if err := json.Unmarshal([]byte(jsonStr), &amp;jsonData); err == nil </span><span class="cov0" title="0">{
                                                for k, v := range jsonData </span><span class="cov0" title="0">{
                                                        doc[k] = v
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> if value != nil </span><span class="cov0" title="0">{
                                // Direct column value
                                doc[columnName] = s.convertFromDB(value)
                        }</span>
                }

                // Apply field projection if specified
                <span class="cov0" title="0">if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                        doc = s.applyFieldProjection(doc, fields)
                }</span>

                <span class="cov0" title="0">results = append(results, doc)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// convertFromDB converts database values to Go types
func (s *ColumnStore) convertFromDB(value interface{}) interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case []byte:<span class="cov0" title="0">
                // Convert byte arrays to strings
                return string(v)</span>
        case time.Time:<span class="cov0" title="0">
                return v</span>
        default:<span class="cov0" title="0">
                return v</span>
        }
}

// applyFieldProjection applies field projection to a document
func (s *ColumnStore) applyFieldProjection(doc map[string]interface{}, fields map[string]int) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})

        // Check if this is inclusion or exclusion
        hasInclusions := false
        for _, include := range fields </span><span class="cov0" title="0">{
                if include == 1 </span><span class="cov0" title="0">{
                        hasInclusions = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if hasInclusions </span><span class="cov0" title="0">{
                // Inclusion mode: only include specified fields
                for field, include := range fields </span><span class="cov0" title="0">{
                        if include == 1 </span><span class="cov0" title="0">{
                                if value, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                        result[field] = value
                                }</span>
                        }
                }
                // Always include id
                <span class="cov0" title="0">if _, hasID := fields["id"]; !hasID </span><span class="cov0" title="0">{
                        if id, exists := doc["id"]; exists </span><span class="cov0" title="0">{
                                result["id"] = id
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Exclusion mode: include all except specified fields
                for field, value := range doc </span><span class="cov0" title="0">{
                        if exclude, exists := fields[field]; !exists || exclude != 0 </span><span class="cov0" title="0">{
                                result[field] = value
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// quoteIdentifier quotes database identifiers
func (s *ColumnStore) quoteIdentifier(name string) string <span class="cov0" title="0">{
        return s.schemaManager.quoteIdentifier(name)
}</span>

// Implement remaining StoreInterface methods by delegating to appropriate logic...

func (s *ColumnStore) FindOne(ctx context.Context, query QueryBuilder) (map[string]interface{}, error) <span class="cov0" title="0">{
        limit := int64(1)
        opts := QueryOptions{Limit: &amp;limit}
        results, err := s.Find(ctx, query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return results[0], nil</span>
}

func (s *ColumnStore) Update(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        return s.performUpdate(ctx, query, update, false)
}</span>

func (s *ColumnStore) UpdateOne(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        return s.performUpdate(ctx, query, update, true)
}</span>

func (s *ColumnStore) performUpdate(ctx context.Context, query QueryBuilder, update UpdateBuilder, updateOne bool) (UpdateResult, error) <span class="cov0" title="0">{
        // Implementation similar to SQLiteStore but with column awareness
        // For now, delegate to finding and updating individual documents
        existingDocs, err := s.Find(ctx, query, QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find documents to update: %w", err)
        }</span>

        <span class="cov0" title="0">if len(existingDocs) == 0 </span><span class="cov0" title="0">{
                return &amp;SQLiteUpdateResult{modifiedCount: 0}, nil
        }</span>

        <span class="cov0" title="0">if updateOne &amp;&amp; len(existingDocs) &gt; 1 </span><span class="cov0" title="0">{
                existingDocs = existingDocs[:1]
        }</span>

        <span class="cov0" title="0">updateMap := update.ToMap()
        modifiedCount := int64(0)

        for _, doc := range existingDocs </span><span class="cov0" title="0">{
                if err := s.updateSingleDocument(ctx, doc, updateMap); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update document: %w", err)
                }</span>
                <span class="cov0" title="0">modifiedCount++</span>
        }

        <span class="cov0" title="0">return &amp;SQLiteUpdateResult{modifiedCount: modifiedCount}, nil</span>
}

func (s *ColumnStore) updateSingleDocument(ctx context.Context, doc map[string]interface{}, updateMap map[string]interface{}) error <span class="cov0" title="0">{
        originalDoc := make(map[string]interface{})
        for k, v := range doc </span><span class="cov0" title="0">{
                originalDoc[k] = v
        }</span>

        // Apply update operations
        <span class="cov0" title="0">s.applyUpdateOperations(doc, updateMap)

        // Update timestamp
        doc["updatedAt"] = time.Now()

        // Check if document actually changed
        if s.documentsEqual(originalDoc, doc) </span><span class="cov0" title="0">{
                return nil // No changes
        }</span>

        // Separate data and build UPDATE SQL
        <span class="cov0" title="0">columnValues, jsonData, err := s.separateData(doc)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to separate data: %w", err)
        }</span>

        <span class="cov0" title="0">sql, args, err := s.buildUpdateSQL(columnValues, jsonData, doc["id"])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build update SQL: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, sql, args...)
        return err</span>
}

func (s *ColumnStore) buildUpdateSQL(columnValues map[string]interface{}, jsonData map[string]interface{}, id interface{}) (string, []interface{}, error) <span class="cov0" title="0">{
        quotedTable := s.quoteIdentifier(s.tableName)
        
        var setParts []string
        var args []interface{}

        // Update column values
        for key, value := range columnValues </span><span class="cov0" title="0">{
                if key != "id" </span><span class="cov0" title="0">{ // Don't update ID
                        setParts = append(setParts, fmt.Sprintf("%s = ?", s.quoteIdentifier(key)))
                        args = append(args, value)
                }</span>
        }

        // Update JSON data if needed
        <span class="cov0" title="0">if len(jsonData) &gt; 0 </span><span class="cov0" title="0">{
                jsonBytes, err := json.Marshal(jsonData)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("failed to marshal JSON data: %w", err)
                }</span>

                <span class="cov0" title="0">setParts = append(setParts, fmt.Sprintf("%s = ?", s.quoteIdentifier("data")))
                args = append(args, string(jsonBytes))</span>
        }

        // Add ID to WHERE clause
        <span class="cov0" title="0">args = append(args, id)

        sql := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?",
                quotedTable,
                strings.Join(setParts, ", "),
                s.quoteIdentifier("id"))

        return sql, args, nil</span>
}

// Helper methods from SQLiteStore
func (s *ColumnStore) applyUpdateOperations(doc map[string]interface{}, updateMap map[string]interface{}) <span class="cov0" title="0">{
        for operation, fields := range updateMap </span><span class="cov0" title="0">{
                if fieldMap, ok := fields.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        switch operation </span>{
                        case "$set":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        doc[field] = value
                                }</span>
                        case "$unset":<span class="cov0" title="0">
                                for field := range fieldMap </span><span class="cov0" title="0">{
                                        delete(doc, field)
                                }</span>
                        case "$inc":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingNum, ok := s.toFloat64(existing); ok </span><span class="cov0" title="0">{
                                                        if incNum, ok := s.toFloat64(value); ok </span><span class="cov0" title="0">{
                                                                doc[field] = existingNum + incNum
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = value
                                        }</span>
                                }
                        case "$push":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        doc[field] = append(existingArray, value)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{value}
                                        }</span>
                                }
                        case "$pull":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        var newArray []interface{}
                                                        for _, item := range existingArray </span><span class="cov0" title="0">{
                                                                if !s.valuesEqual(item, value) </span><span class="cov0" title="0">{
                                                                        newArray = append(newArray, item)
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">doc[field] = newArray</span>
                                                }
                                        }
                                }
                        case "$addToSet":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        // Check if value already exists
                                                        exists := false
                                                        for _, item := range existingArray </span><span class="cov0" title="0">{
                                                                if s.valuesEqual(item, value) </span><span class="cov0" title="0">{
                                                                        exists = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                                                doc[field] = append(existingArray, value)
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{value}
                                        }</span>
                                }
                        }
                }
        }
}

func (s *ColumnStore) toFloat64(value interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

func (s *ColumnStore) valuesEqual(a, b interface{}) bool <span class="cov0" title="0">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

func (s *ColumnStore) documentsEqual(a, b map[string]interface{}) bool <span class="cov0" title="0">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

// Additional StoreInterface methods to implement...
func (s *ColumnStore) Remove(ctx context.Context, query QueryBuilder) (DeleteResult, error) <span class="cov0" title="0">{
        // Implementation similar to SQLiteStore.Remove
        return &amp;SQLiteDeleteResult{deletedCount: 0}, fmt.Errorf("Remove not yet implemented for ColumnStore")
}</span>

func (s *ColumnStore) Count(ctx context.Context, query QueryBuilder) (int64, error) <span class="cov0" title="0">{
        // Implementation similar to SQLiteStore.Count
        return 0, fmt.Errorf("Count not yet implemented for ColumnStore")
}</span>

// Additional MongoDB-style operations...
func (s *ColumnStore) Increment(ctx context.Context, query QueryBuilder, increments map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range increments </span><span class="cov0" title="0">{
                update.Inc(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *ColumnStore) Push(ctx context.Context, query QueryBuilder, pushOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range pushOps </span><span class="cov0" title="0">{
                update.Push(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *ColumnStore) Pull(ctx context.Context, query QueryBuilder, pullOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range pullOps </span><span class="cov0" title="0">{
                update.Pull(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *ColumnStore) AddToSet(ctx context.Context, query QueryBuilder, addOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range addOps </span><span class="cov0" title="0">{
                update.AddToSet(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *ColumnStore) PopFirst(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        return &amp;SQLiteUpdateResult{modifiedCount: 0}, fmt.Errorf("PopFirst not yet implemented for ColumnStore")
}</span>

func (s *ColumnStore) PopLast(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        return &amp;SQLiteUpdateResult{modifiedCount: 0}, fmt.Errorf("PopLast not yet implemented for ColumnStore")
}</span>

func (s *ColumnStore) Upsert(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        // Try update first
        result, err := s.Update(ctx, query, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount() &gt; 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // If no documents were updated, create a new one
        <span class="cov0" title="0">updateMap := update.ToMap()
        queryMap := query.ToMap()

        // Merge query and update into a new document
        newDoc := make(map[string]interface{})
        
        // Add query fields
        for field, value := range queryMap </span><span class="cov0" title="0">{
                if !strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        newDoc[field] = value
                }</span>
        }

        // Apply update operations to create the document
        <span class="cov0" title="0">s.applyUpdateOperations(newDoc, updateMap)

        // Insert the new document
        _, err = s.Insert(ctx, newDoc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upsert document: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SQLiteUpdateResult{
                modifiedCount: 0,
                upsertedCount: 1,
                upsertedID:    newDoc["id"],
        }, nil</span>
}

func (s *ColumnStore) Aggregate(ctx context.Context, pipeline []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Basic aggregation support
        query := NewQueryBuilder()
        return s.Find(ctx, query, QueryOptions{})
}</pre>
		
		<pre class="file" id="file7" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type LegacyConfig struct {
        Host string
        Port int
        Name string
}

type Database struct {
        client *mongo.Client
        db     *mongo.Database
        config *LegacyConfig
}

func New(config *LegacyConfig) (*Database, error) <span class="cov0" title="0">{
        uri := fmt.Sprintf("mongodb://%s:%d", config.Host, config.Port)
        
        clientOptions := options.Client().ApplyURI(uri)
        
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := client.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping MongoDB: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;Database{
                client: client,
                db:     client.Database(config.Name),
                config: config,
        }, nil</span>
}

func (d *Database) Close() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        return d.client.Disconnect(ctx)
}</span>

func (d *Database) CreateStore(namespace string) *Store <span class="cov0" title="0">{
        return &amp;Store{
                namespace:  namespace,
                collection: d.db.Collection(namespace),
                db:         d,
        }
}</span>

func (d *Database) Drop() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        return d.db.Drop(ctx)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "context"
)

// DatabaseType represents the type of database backend
type DatabaseType string

const (
        DatabaseTypeMongoDB DatabaseType = "mongodb"
        DatabaseTypeSQLite  DatabaseType = "sqlite"
        DatabaseTypeMySQL   DatabaseType = "mysql"
        DatabaseTypePostgres DatabaseType = "postgres"
)

// Config represents database connection configuration
type Config struct {
        Host     string
        Port     int
        Name     string
        Username string // For MySQL/PostgreSQL
        Password string // For MySQL/PostgreSQL
        SSL      bool   // For MySQL/PostgreSQL
}

// DatabaseInterface defines the common interface for all database implementations
type DatabaseInterface interface {
        CreateStore(namespace string) StoreInterface
        Close() error
        Drop() error
        GetType() DatabaseType
}

// StoreInterface defines the common interface for all store implementations
type StoreInterface interface {
        CreateUniqueIdentifier() string
        Insert(ctx context.Context, document interface{}) (interface{}, error)
        Find(ctx context.Context, query QueryBuilder, opts QueryOptions) ([]map[string]interface{}, error)
        FindOne(ctx context.Context, query QueryBuilder) (map[string]interface{}, error)
        Update(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error)
        UpdateOne(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error)
        Remove(ctx context.Context, query QueryBuilder) (DeleteResult, error)
        Count(ctx context.Context, query QueryBuilder) (int64, error)
        
        // MongoDB-style operations that need translation for SQL
        Increment(ctx context.Context, query QueryBuilder, increments map[string]interface{}) (UpdateResult, error)
        Push(ctx context.Context, query QueryBuilder, pushOps map[string]interface{}) (UpdateResult, error)
        Pull(ctx context.Context, query QueryBuilder, pullOps map[string]interface{}) (UpdateResult, error)
        AddToSet(ctx context.Context, query QueryBuilder, addOps map[string]interface{}) (UpdateResult, error)
        PopFirst(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error)
        PopLast(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error)
        Upsert(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error)
        Aggregate(ctx context.Context, pipeline []map[string]interface{}) ([]map[string]interface{}, error)
}

// QueryBuilder provides a database-agnostic query building interface
type QueryBuilder interface {
        Where(field string, operator string, value interface{}) QueryBuilder
        WhereIn(field string, values []interface{}) QueryBuilder
        WhereNotIn(field string, values []interface{}) QueryBuilder
        WhereNull(field string) QueryBuilder
        WhereNotNull(field string) QueryBuilder
        WhereRegex(field string, pattern string) QueryBuilder
        Or(conditions ...QueryBuilder) QueryBuilder
        And(conditions ...QueryBuilder) QueryBuilder
        Clone() QueryBuilder
        ToMap() map[string]interface{} // For MongoDB compatibility
}

// QueryOptions represents query options like sorting, limiting, etc.
type QueryOptions struct {
        Sort   map[string]int // field -&gt; direction (1 or -1)
        Limit  *int64
        Skip   *int64
        Fields map[string]int // field -&gt; include (1) or exclude (0)
}

// UpdateBuilder provides a database-agnostic update building interface
type UpdateBuilder interface {
        Set(field string, value interface{}) UpdateBuilder
        Unset(field string) UpdateBuilder
        Inc(field string, value interface{}) UpdateBuilder
        Push(field string, value interface{}) UpdateBuilder
        Pull(field string, value interface{}) UpdateBuilder
        AddToSet(field string, value interface{}) UpdateBuilder
        ToMap() map[string]interface{} // For MongoDB compatibility
}

// UpdateResult represents the result of an update operation
type UpdateResult interface {
        ModifiedCount() int64
        UpsertedCount() int64
        UpsertedID() interface{}
}

// DeleteResult represents the result of a delete operation
type DeleteResult interface {
        DeletedCount() int64
}

// Factory function type for creating database instances
type DatabaseFactory func(config *Config) (DatabaseInterface, error)

// Registry for database factories
var databaseFactories = make(map[DatabaseType]DatabaseFactory)

// RegisterDatabaseFactory registers a new database factory
func RegisterDatabaseFactory(dbType DatabaseType, factory DatabaseFactory) <span class="cov7" title="3">{
        databaseFactories[dbType] = factory
}</span>

// NewDatabase creates a new database instance based on the type
func NewDatabase(dbType DatabaseType, config *Config) (DatabaseInterface, error) <span class="cov10" title="5">{
        factory, exists := databaseFactories[dbType]
        if !exists </span><span class="cov1" title="1">{
                return nil, &amp;UnsupportedDatabaseError{Type: dbType}
        }</span>
        <span class="cov8" title="4">return factory(config)</span>
}

// UnsupportedDatabaseError is returned when an unsupported database type is requested
type UnsupportedDatabaseError struct {
        Type DatabaseType
}

func (e *UnsupportedDatabaseError) Error() string <span class="cov0" title="0">{
        return "unsupported database type: " + string(e.Type)
}</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "context"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// MongoDatabase wraps the existing Database struct to implement DatabaseInterface
type MongoDatabase struct {
        *Database
}

// MongoStore wraps the existing Store struct to implement StoreInterface
type MongoStore struct {
        *Store
}

// MongoUpdateResult wraps mongo.UpdateResult to implement UpdateResult interface
type MongoUpdateResult struct {
        *mongo.UpdateResult
}

func (r *MongoUpdateResult) ModifiedCount() int64   <span class="cov0" title="0">{ return r.UpdateResult.ModifiedCount }</span>
func (r *MongoUpdateResult) UpsertedCount() int64   <span class="cov0" title="0">{ 
        if r.UpdateResult.UpsertedID != nil </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}
func (r *MongoUpdateResult) UpsertedID() interface{} <span class="cov0" title="0">{ return r.UpdateResult.UpsertedID }</span>

// MongoDeleteResult wraps mongo.DeleteResult to implement DeleteResult interface
type MongoDeleteResult struct {
        *mongo.DeleteResult
}

func (r *MongoDeleteResult) DeletedCount() int64 <span class="cov0" title="0">{ return r.DeleteResult.DeletedCount }</span>

// NewMongoDatabase creates a new MongoDB database instance that implements DatabaseInterface
func NewMongoDatabase(config *Config) (DatabaseInterface, error) <span class="cov0" title="0">{
        legacyConfig := &amp;LegacyConfig{
                Host: config.Host,
                Port: config.Port,
                Name: config.Name,
        }
        db, err := New(legacyConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;MongoDatabase{Database: db}, nil</span>
}

func (d *MongoDatabase) CreateStore(namespace string) StoreInterface <span class="cov0" title="0">{
        store := d.Database.CreateStore(namespace)
        return &amp;MongoStore{Store: store}
}</span>

func (d *MongoDatabase) GetType() DatabaseType <span class="cov0" title="0">{
        return DatabaseTypeMongoDB
}</span>

// Adapter methods for MongoStore to implement StoreInterface

func (s *MongoStore) Find(ctx context.Context, query QueryBuilder, opts QueryOptions) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Convert QueryBuilder to bson.M
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)

        // Convert QueryOptions to MongoDB options
        findOpts := options.Find()
        
        if len(opts.Sort) &gt; 0 </span><span class="cov0" title="0">{
                sortBSON := bson.D{}
                for field, direction := range opts.Sort </span><span class="cov0" title="0">{
                        sortBSON = append(sortBSON, bson.E{Key: field, Value: direction})
                }</span>
                <span class="cov0" title="0">findOpts.SetSort(sortBSON)</span>
        }
        
        <span class="cov0" title="0">if opts.Limit != nil </span><span class="cov0" title="0">{
                findOpts.SetLimit(*opts.Limit)
        }</span>
        
        <span class="cov0" title="0">if opts.Skip != nil </span><span class="cov0" title="0">{
                findOpts.SetSkip(*opts.Skip)
        }</span>
        
        <span class="cov0" title="0">if len(opts.Fields) &gt; 0 </span><span class="cov0" title="0">{
                projection := bson.M{}
                for field, include := range opts.Fields </span><span class="cov0" title="0">{
                        projection[field] = include
                }</span>
                <span class="cov0" title="0">findOpts.SetProjection(projection)</span>
        }

        // Use the existing Find method
        <span class="cov0" title="0">results, err := s.Store.Find(ctx, bsonQuery, findOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert []bson.M to []map[string]interface{} with BSON conversion
        <span class="cov0" title="0">mapResults := make([]map[string]interface{}, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                mapResults[i] = s.convertBSONToMap(map[string]interface{}(result))
        }</span>

        <span class="cov0" title="0">return mapResults, nil</span>
}

func (s *MongoStore) FindOne(ctx context.Context, query QueryBuilder) (map[string]interface{}, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        
        result, err := s.Store.FindOne(ctx, bsonQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if result == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        // Convert bson.M to map[string]interface{} recursively
        <span class="cov0" title="0">return s.convertBSONToMap(map[string]interface{}(result)), nil</span>
}

func (s *MongoStore) Update(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        updateMap := update.ToMap()
        
        bsonQuery := s.mapToBSON(queryMap)
        bsonUpdate := s.mapToBSON(updateMap)
        
        result, err := s.Store.Update(ctx, bsonQuery, bsonUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) UpdateOne(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        updateMap := update.ToMap()
        
        bsonQuery := s.mapToBSON(queryMap)
        bsonUpdate := s.mapToBSON(updateMap)
        
        result, err := s.Store.UpdateOne(ctx, bsonQuery, bsonUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) Remove(ctx context.Context, query QueryBuilder) (DeleteResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        
        result, err := s.Store.Remove(ctx, bsonQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoDeleteResult{DeleteResult: result}, nil</span>
}

func (s *MongoStore) Count(ctx context.Context, query QueryBuilder) (int64, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        
        return s.Store.Count(ctx, bsonQuery)
}</span>

func (s *MongoStore) Increment(ctx context.Context, query QueryBuilder, increments map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        bsonInc := s.mapToBSON(increments)
        
        result, err := s.Store.Increment(ctx, bsonQuery, bsonInc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) Push(ctx context.Context, query QueryBuilder, pushOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        bsonPush := s.mapToBSON(pushOps)
        
        result, err := s.Store.Push(ctx, bsonQuery, bsonPush)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) Pull(ctx context.Context, query QueryBuilder, pullOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        bsonPull := s.mapToBSON(pullOps)
        
        result, err := s.Store.Pull(ctx, bsonQuery, bsonPull)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) AddToSet(ctx context.Context, query QueryBuilder, addOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        bsonAdd := s.mapToBSON(addOps)
        
        result, err := s.Store.AddToSet(ctx, bsonQuery, bsonAdd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) PopFirst(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        
        result, err := s.Store.PopFirst(ctx, bsonQuery, fields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) PopLast(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        bsonQuery := s.mapToBSON(queryMap)
        
        result, err := s.Store.PopLast(ctx, bsonQuery, fields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) Upsert(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        queryMap := query.ToMap()
        updateMap := update.ToMap()
        
        bsonQuery := s.mapToBSON(queryMap)
        bsonUpdate := s.mapToBSON(updateMap)
        
        result, err := s.Store.Upsert(ctx, bsonQuery, bsonUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;MongoUpdateResult{UpdateResult: result}, nil</span>
}

func (s *MongoStore) Aggregate(ctx context.Context, pipeline []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Convert []map[string]interface{} to []bson.M
        bsonPipeline := make([]bson.M, len(pipeline))
        for i, stage := range pipeline </span><span class="cov0" title="0">{
                bsonPipeline[i] = s.mapToBSON(stage)
        }</span>
        
        <span class="cov0" title="0">results, err := s.Store.Aggregate(ctx, bsonPipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Convert []bson.M to []map[string]interface{}
        <span class="cov0" title="0">mapResults := make([]map[string]interface{}, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                mapResults[i] = map[string]interface{}(result)
        }</span>
        
        <span class="cov0" title="0">return mapResults, nil</span>
}

// Helper method to convert map[string]interface{} to bson.M
func (s *MongoStore) mapToBSON(m map[string]interface{}) bson.M <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">result := make(bson.M)
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

// convertBSONToMap recursively converts BSON types to standard Go types
func (s *MongoStore) convertBSONToMap(data map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        
        for key, value := range data </span><span class="cov0" title="0">{
                result[key] = s.convertBSONValue(value)
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// convertBSONValue converts individual BSON values to standard Go types
func (s *MongoStore) convertBSONValue(value interface{}) interface{} <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // Recursively convert nested maps
                return s.convertBSONToMap(v)</span>
        case primitive.M:<span class="cov0" title="0">
                // Convert primitive.M (which is the same as bson.M) to map[string]interface{}
                result := make(map[string]interface{})
                for key, val := range v </span><span class="cov0" title="0">{
                        result[key] = s.convertBSONValue(val)
                }</span>
                <span class="cov0" title="0">return result</span>
        case primitive.A:<span class="cov0" title="0">
                // Convert primitive.A (array) to []interface{}
                result := make([]interface{}, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        result[i] = s.convertBSONValue(item)
                }</span>
                <span class="cov0" title="0">return result</span>
        case []interface{}:<span class="cov0" title="0">
                // Convert arrays recursively
                result := make([]interface{}, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        result[i] = s.convertBSONValue(item)
                }</span>
                <span class="cov0" title="0">return result</span>
        default:<span class="cov0" title="0">
                // For primitive types, return as-is
                return value</span>
        }
}

// Register MongoDB database factory
func init() <span class="cov8" title="1">{
        RegisterDatabaseFactory(DatabaseTypeMongoDB, NewMongoDatabase)
}</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        _ "github.com/go-sql-driver/mysql"
)

// MySQLDatabase implements DatabaseInterface for MySQL
type MySQLDatabase struct {
        db            *sql.DB
        config        *Config
        schemaManager *SchemaManager
}

// MySQLStore implements StoreInterface for MySQL
type MySQLStore struct {
        tableName string
        db        *sql.DB
        database  *MySQLDatabase
}

// MySQLUpdateResult implements UpdateResult interface
type MySQLUpdateResult struct {
        modifiedCount int64
        upsertedCount int64
        upsertedID    interface{}
}

func (r *MySQLUpdateResult) ModifiedCount() int64   <span class="cov0" title="0">{ return r.modifiedCount }</span>
func (r *MySQLUpdateResult) UpsertedCount() int64   <span class="cov0" title="0">{ return r.upsertedCount }</span>
func (r *MySQLUpdateResult) UpsertedID() interface{} <span class="cov0" title="0">{ return r.upsertedID }</span>

// MySQLDeleteResult implements DeleteResult interface
type MySQLDeleteResult struct {
        deletedCount int64
}

func (r *MySQLDeleteResult) DeletedCount() int64 <span class="cov0" title="0">{ return r.deletedCount }</span>

// NewMySQLDatabase creates a new MySQL database instance
func NewMySQLDatabase(config *Config) (DatabaseInterface, error) <span class="cov0" title="0">{
        // Build MySQL connection string
        var dsn string
        if config.Username != "" &amp;&amp; config.Password != "" </span><span class="cov0" title="0">{
                dsn = fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&amp;charset=utf8mb4&amp;collation=utf8mb4_unicode_ci",
                        config.Username, config.Password, config.Host, config.Port, config.Name)
        }</span> else<span class="cov0" title="0"> if config.Username != "" </span><span class="cov0" title="0">{
                dsn = fmt.Sprintf("%s@tcp(%s:%d)/%s?parseTime=true&amp;charset=utf8mb4&amp;collation=utf8mb4_unicode_ci",
                        config.Username, config.Host, config.Port, config.Name)
        }</span> else<span class="cov0" title="0"> {
                dsn = fmt.Sprintf("tcp(%s:%d)/%s?parseTime=true&amp;charset=utf8mb4&amp;collation=utf8mb4_unicode_ci",
                        config.Host, config.Port, config.Name)
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open MySQL database: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">db.SetMaxOpenConns(50)          // Increased from 25
        db.SetMaxIdleConns(10)          // Increased from 5
        db.SetConnMaxLifetime(30 * time.Minute)
        db.SetConnMaxIdleTime(5 * time.Minute)  // Add idle timeout

        // Test connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping MySQL database: %w", err)
        }</span>

        <span class="cov0" title="0">mysqlDB := &amp;MySQLDatabase{
                db:     db,
                config: config,
        }

        // Initialize schema manager
        mysqlDB.schemaManager = NewSchemaManager(db, DatabaseTypeMySQL, "")

        return mysqlDB, nil</span>
}

func (d *MySQLDatabase) CreateStore(namespace string) StoreInterface <span class="cov0" title="0">{
        // Check if this collection should use column-based storage
        schema, err := d.schemaManager.GetSchema(namespace)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but fall back to JSON store
                fmt.Printf("Warning: failed to get schema for %s, using JSON storage: %v\n", namespace, err)
                store := &amp;MySQLStore{
                        tableName: namespace,
                        db:        d.db,
                        database:  d,
                }
                store.ensureTable()
                return store
        }</span>

        <span class="cov0" title="0">if schema.UseColumns </span><span class="cov0" title="0">{
                // Use column-based storage
                columnStore, err := NewColumnStore(namespace, d.db, d, d.schemaManager)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but fall back to JSON store
                        fmt.Printf("Warning: failed to create column store for %s, using JSON storage: %v\n", namespace, err)
                        store := &amp;MySQLStore{
                                tableName: namespace,
                                db:        d.db,
                                database:  d,
                        }
                        store.ensureTable()
                        return store
                }</span>
                <span class="cov0" title="0">return columnStore</span>
        }

        // Use traditional JSON-based storage
        <span class="cov0" title="0">store := &amp;MySQLStore{
                tableName: namespace,
                db:        d.db,
                database:  d,
        }

        // Ensure table exists
        store.ensureTable()

        return store</span>
}

func (d *MySQLDatabase) Close() error <span class="cov0" title="0">{
        return d.db.Close()
}</span>

func (d *MySQLDatabase) Drop() error <span class="cov0" title="0">{
        // Get all table names from information_schema
        rows, err := d.db.Query("SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = DATABASE() AND TABLE_TYPE = 'BASE TABLE'")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get table names: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := rows.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan table name: %w", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        // Drop all tables
        <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                if _, err := d.db.Exec(fmt.Sprintf("DROP TABLE IF EXISTS `%s`", table)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to drop table %s: %w", table, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *MySQLDatabase) GetType() DatabaseType <span class="cov0" title="0">{
        return DatabaseTypeMySQL
}</span>

// ensureTable creates the table if it doesn't exist
func (s *MySQLStore) ensureTable() error <span class="cov0" title="0">{
        quotedTable := s.quotedTableName()
        createSQL := fmt.Sprintf(`
                CREATE TABLE IF NOT EXISTS %s (
                        id VARCHAR(255) PRIMARY KEY,
                        data JSON NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                        INDEX idx_created_at (created_at),
                        INDEX idx_updated_at (updated_at)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        `, quotedTable)

        if _, err := s.db.Exec(createSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create table %s: %w", s.tableName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *MySQLStore) CreateUniqueIdentifier() string <span class="cov0" title="0">{
        return generateUniqueID()
}</span>

func (s *MySQLStore) Insert(ctx context.Context, document interface{}) (interface{}, error) <span class="cov0" title="0">{
        doc, ok := document.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document must be a map[string]interface{}")
        }</span>

        // Ensure the document has an ID
        <span class="cov0" title="0">if _, exists := doc["id"]; !exists </span><span class="cov0" title="0">{
                doc["id"] = s.CreateUniqueIdentifier()
        }</span>

        // Add timestamps
        <span class="cov0" title="0">now := time.Now()
        if _, exists := doc["createdAt"]; !exists </span><span class="cov0" title="0">{
                doc["createdAt"] = now
        }</span>
        <span class="cov0" title="0">if _, exists := doc["updatedAt"]; !exists </span><span class="cov0" title="0">{
                doc["updatedAt"] = now
        }</span>

        // Serialize to JSON
        <span class="cov0" title="0">jsonData, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal document: %w", err)
        }</span>

        <span class="cov0" title="0">insertSQL := fmt.Sprintf("INSERT INTO %s (id, data, created_at, updated_at) VALUES (?, ?, ?, ?)", s.quotedTableName())
        _, err = s.db.ExecContext(ctx, insertSQL, doc["id"], string(jsonData), now, now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to insert document: %w", err)
        }</span>

        <span class="cov0" title="0">return doc, nil</span>
}

func (s *MySQLStore) Find(ctx context.Context, query QueryBuilder, opts QueryOptions) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        baseSQL := fmt.Sprintf("SELECT data FROM %s", s.quotedTableName())
        var args []interface{}

        // Build WHERE clause
        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                baseSQL += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        // Add ORDER BY
        <span class="cov0" title="0">if len(opts.Sort) &gt; 0 </span><span class="cov0" title="0">{
                var orderParts []string
                for field, direction := range opts.Sort </span><span class="cov0" title="0">{
                        dir := "ASC"
                        if direction == -1 </span><span class="cov0" title="0">{
                                dir = "DESC"
                        }</span>
                        <span class="cov0" title="0">orderParts = append(orderParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s", field, dir))</span>
                }
                <span class="cov0" title="0">baseSQL += " ORDER BY " + strings.Join(orderParts, ", ")</span>
        }

        // Add LIMIT and OFFSET
        <span class="cov0" title="0">if opts.Limit != nil </span><span class="cov0" title="0">{
                baseSQL += fmt.Sprintf(" LIMIT %d", *opts.Limit)
        }</span>
        <span class="cov0" title="0">if opts.Skip != nil </span><span class="cov0" title="0">{
                baseSQL += fmt.Sprintf(" OFFSET %d", *opts.Skip)
        }</span>

        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, baseSQL, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var jsonData string
                if err := rows.Scan(&amp;jsonData); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                <span class="cov0" title="0">var doc map[string]interface{}
                if err := json.Unmarshal([]byte(jsonData), &amp;doc); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal document: %w", err)
                }</span>

                // Apply field projection if specified
                <span class="cov0" title="0">if len(opts.Fields) &gt; 0 </span><span class="cov0" title="0">{
                        doc = s.applyFieldProjection(doc, opts.Fields)
                }</span>

                <span class="cov0" title="0">results = append(results, doc)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (s *MySQLStore) FindOne(ctx context.Context, query QueryBuilder) (map[string]interface{}, error) <span class="cov0" title="0">{
        opts := QueryOptions{Limit: &amp;[]int64{1}[0]}
        results, err := s.Find(ctx, query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return results[0], nil</span>
}

func (s *MySQLStore) Update(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        return s.performUpdate(ctx, query, update, false)
}</span>

func (s *MySQLStore) UpdateOne(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        return s.performUpdate(ctx, query, update, true)
}</span>

func (s *MySQLStore) performUpdate(ctx context.Context, query QueryBuilder, update UpdateBuilder, updateOne bool) (UpdateResult, error) <span class="cov0" title="0">{
        // First, find the documents to update
        existingDocs, err := s.Find(ctx, query, QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find documents to update: %w", err)
        }</span>

        <span class="cov0" title="0">if len(existingDocs) == 0 </span><span class="cov0" title="0">{
                return &amp;MySQLUpdateResult{modifiedCount: 0}, nil
        }</span>

        // If updateOne is true, only update the first document
        <span class="cov0" title="0">if updateOne &amp;&amp; len(existingDocs) &gt; 1 </span><span class="cov0" title="0">{
                existingDocs = existingDocs[:1]
        }</span>

        <span class="cov0" title="0">updateMap := update.ToMap()
        modifiedCount := int64(0)

        for _, doc := range existingDocs </span><span class="cov0" title="0">{
                originalDoc := make(map[string]interface{})
                for k, v := range doc </span><span class="cov0" title="0">{
                        originalDoc[k] = v
                }</span>

                // Apply update operations
                <span class="cov0" title="0">s.applyUpdateOperations(doc, updateMap)

                // Update timestamp
                doc["updatedAt"] = time.Now()

                // Check if document actually changed
                if !s.documentsEqual(originalDoc, doc) </span><span class="cov0" title="0">{
                        // Serialize and update in database
                        jsonData, err := json.Marshal(doc)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal updated document: %w", err)
                        }</span>

                        <span class="cov0" title="0">updateSQL := fmt.Sprintf("UPDATE %s SET data = ?, updated_at = ? WHERE id = ?", s.quotedTableName())
                        _, err = s.db.ExecContext(ctx, updateSQL, string(jsonData), doc["updatedAt"], doc["id"])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update document: %w", err)
                        }</span>

                        <span class="cov0" title="0">modifiedCount++</span>
                }
        }

        <span class="cov0" title="0">return &amp;MySQLUpdateResult{modifiedCount: modifiedCount}, nil</span>
}

func (s *MySQLStore) Remove(ctx context.Context, query QueryBuilder) (DeleteResult, error) <span class="cov0" title="0">{
        // First count how many will be deleted
        count, err := s.Count(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count documents to delete: %w", err)
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return &amp;MySQLDeleteResult{deletedCount: 0}, nil
        }</span>

        // Build DELETE query
        <span class="cov0" title="0">deleteSQL := fmt.Sprintf("DELETE FROM %s", s.quotedTableName())
        var args []interface{}

        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                deleteSQL += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, deleteSQL, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete documents: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MySQLDeleteResult{deletedCount: count}, nil</span>
}

func (s *MySQLStore) Count(ctx context.Context, query QueryBuilder) (int64, error) <span class="cov0" title="0">{
        countSQL := fmt.Sprintf("SELECT COUNT(*) FROM %s", s.quotedTableName())
        var args []interface{}

        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                countSQL += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        <span class="cov0" title="0">var count int64
        err := s.db.QueryRowContext(ctx, countSQL, args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count documents: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// Specialized MongoDB-style operations
func (s *MySQLStore) Increment(ctx context.Context, query QueryBuilder, increments map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range increments </span><span class="cov0" title="0">{
                update.Inc(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *MySQLStore) Push(ctx context.Context, query QueryBuilder, pushOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range pushOps </span><span class="cov0" title="0">{
                update.Push(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *MySQLStore) Pull(ctx context.Context, query QueryBuilder, pullOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range pullOps </span><span class="cov0" title="0">{
                update.Pull(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *MySQLStore) AddToSet(ctx context.Context, query QueryBuilder, addOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range addOps </span><span class="cov0" title="0">{
                update.AddToSet(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *MySQLStore) PopFirst(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        // For MySQL, we'll implement this by updating arrays manually
        return &amp;MySQLUpdateResult{modifiedCount: 0}, fmt.Errorf("PopFirst not yet implemented for MySQL")
}</span>

func (s *MySQLStore) PopLast(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        // For MySQL, we'll implement this by updating arrays manually
        return &amp;MySQLUpdateResult{modifiedCount: 0}, fmt.Errorf("PopLast not yet implemented for MySQL")
}</span>

func (s *MySQLStore) Upsert(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        // Try update first
        result, err := s.Update(ctx, query, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount() &gt; 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // If no documents were updated, create a new one
        <span class="cov0" title="0">updateMap := update.ToMap()
        queryMap := query.ToMap()

        // Merge query and update into a new document
        newDoc := make(map[string]interface{})
        
        // Add query fields
        for field, value := range queryMap </span><span class="cov0" title="0">{
                if !strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        newDoc[field] = value
                }</span>
        }

        // Apply update operations to create the document
        <span class="cov0" title="0">s.applyUpdateOperations(newDoc, updateMap)

        // Insert the new document
        _, err = s.Insert(ctx, newDoc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upsert document: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MySQLUpdateResult{
                modifiedCount: 0,
                upsertedCount: 1,
                upsertedID:    newDoc["id"],
        }, nil</span>
}

func (s *MySQLStore) Aggregate(ctx context.Context, pipeline []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Basic aggregation support - this is a simplified implementation
        // For now, just return all documents
        query := NewQueryBuilder()
        return s.Find(ctx, query, QueryOptions{})
}</span>

// Helper methods

func (s *MySQLStore) quotedTableName() string <span class="cov0" title="0">{
        // Quote table names with backticks for MySQL
        return fmt.Sprintf("`%s`", s.tableName)
}</span>

func (s *MySQLStore) buildWhereClause(query QueryBuilder) (string, []interface{}) <span class="cov0" title="0">{
        if sqlQuery, ok := query.(*SQLQueryBuilder); ok </span><span class="cov0" title="0">{
                return sqlQuery.ToSQL()
        }</span>

        // Convert from map-based query
        <span class="cov0" title="0">queryMap := query.ToMap()
        if len(queryMap) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">sqlBuilder := NewSQLQueryBuilder()
        s.convertMapToSQLQuery(queryMap, sqlBuilder)
        return sqlBuilder.ToSQL()</span>
}

func (s *MySQLStore) convertMapToSQLQuery(queryMap map[string]interface{}, builder *SQLQueryBuilder) <span class="cov0" title="0">{
        for field, value := range queryMap </span><span class="cov0" title="0">{
                if field == "$or" </span><span class="cov0" title="0">{
                        // Handle OR conditions
                        if orConditions, ok := value.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                                var orBuilders []QueryBuilder
                                for _, orCond := range orConditions </span><span class="cov0" title="0">{
                                        orBuilder := NewSQLQueryBuilder()
                                        s.convertMapToSQLQuery(orCond, orBuilder)
                                        orBuilders = append(orBuilders, orBuilder)
                                }</span>
                                <span class="cov0" title="0">builder.Or(orBuilders...)</span>
                        }
                } else<span class="cov0" title="0"> if strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        // Skip other MongoDB operators at root level
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // Regular field condition
                        if valueMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                // Field has operators
                                for op, opValue := range valueMap </span><span class="cov0" title="0">{
                                        builder.Where(field, op, opValue)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Simple equality
                                builder.Where(field, "$eq", value)
                        }</span>
                }
        }
}

func (s *MySQLStore) applyFieldProjection(doc map[string]interface{}, fields map[string]int) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})

        // Check if this is inclusion or exclusion
        hasInclusions := false
        for _, include := range fields </span><span class="cov0" title="0">{
                if include == 1 </span><span class="cov0" title="0">{
                        hasInclusions = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if hasInclusions </span><span class="cov0" title="0">{
                // Inclusion mode: only include specified fields
                for field, include := range fields </span><span class="cov0" title="0">{
                        if include == 1 </span><span class="cov0" title="0">{
                                if value, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                        result[field] = value
                                }</span>
                        }
                }
                // Always include id
                <span class="cov0" title="0">if _, hasID := fields["id"]; !hasID </span><span class="cov0" title="0">{
                        if id, exists := doc["id"]; exists </span><span class="cov0" title="0">{
                                result["id"] = id
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Exclusion mode: include all except specified fields
                for field, value := range doc </span><span class="cov0" title="0">{
                        if exclude, exists := fields[field]; !exists || exclude != 0 </span><span class="cov0" title="0">{
                                result[field] = value
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func (s *MySQLStore) applyUpdateOperations(doc map[string]interface{}, updateMap map[string]interface{}) <span class="cov0" title="0">{
        for operation, fields := range updateMap </span><span class="cov0" title="0">{
                if fieldMap, ok := fields.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        switch operation </span>{
                        case "$set":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        doc[field] = value
                                }</span>
                        case "$unset":<span class="cov0" title="0">
                                for field := range fieldMap </span><span class="cov0" title="0">{
                                        delete(doc, field)
                                }</span>
                        case "$inc":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingNum, ok := s.toFloat64(existing); ok </span><span class="cov0" title="0">{
                                                        if incNum, ok := s.toFloat64(value); ok </span><span class="cov0" title="0">{
                                                                doc[field] = existingNum + incNum
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = value
                                        }</span>
                                }
                        case "$push":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        doc[field] = append(existingArray, value)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{value}
                                        }</span>
                                }
                        case "$pull":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        var newArray []interface{}
                                                        for _, item := range existingArray </span><span class="cov0" title="0">{
                                                                if !s.valuesEqual(item, value) </span><span class="cov0" title="0">{
                                                                        newArray = append(newArray, item)
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">doc[field] = newArray</span>
                                                }
                                        }
                                }
                        case "$addToSet":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        // Check if value already exists
                                                        exists := false
                                                        for _, item := range existingArray </span><span class="cov0" title="0">{
                                                                if s.valuesEqual(item, value) </span><span class="cov0" title="0">{
                                                                        exists = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                                                doc[field] = append(existingArray, value)
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{value}
                                        }</span>
                                }
                        }
                }
        }
}

func (s *MySQLStore) toFloat64(value interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

func (s *MySQLStore) valuesEqual(a, b interface{}) bool <span class="cov0" title="0">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

func (s *MySQLStore) documentsEqual(a, b map[string]interface{}) bool <span class="cov0" title="0">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

// Register MySQL database factory
func init() <span class="cov8" title="1">{
        RegisterDatabaseFactory(DatabaseTypeMySQL, NewMySQLDatabase)
}</pre>
		
		<pre class="file" id="file11" style="display: none">package database

import (
        "fmt"
        "strings"
)

// BaseQueryBuilder provides a basic implementation of QueryBuilder
type BaseQueryBuilder struct {
        conditions []QueryCondition
        orGroups   [][]QueryCondition
}

type QueryCondition struct {
        Field    string
        Operator string
        Value    interface{}
}

// NewQueryBuilder creates a new query builder
func NewQueryBuilder() QueryBuilder <span class="cov0" title="0">{
        return &amp;BaseQueryBuilder{
                conditions: make([]QueryCondition, 0),
                orGroups:   make([][]QueryCondition, 0),
        }
}</span>

func (q *BaseQueryBuilder) Where(field string, operator string, value interface{}) QueryBuilder <span class="cov0" title="0">{
        q.conditions = append(q.conditions, QueryCondition{
                Field:    field,
                Operator: operator,
                Value:    value,
        })
        return q
}</span>

func (q *BaseQueryBuilder) WhereIn(field string, values []interface{}) QueryBuilder <span class="cov0" title="0">{
        return q.Where(field, "$in", values)
}</span>

func (q *BaseQueryBuilder) WhereNotIn(field string, values []interface{}) QueryBuilder <span class="cov0" title="0">{
        return q.Where(field, "$nin", values)
}</span>

func (q *BaseQueryBuilder) WhereNull(field string) QueryBuilder <span class="cov0" title="0">{
        return q.Where(field, "$eq", nil)
}</span>

func (q *BaseQueryBuilder) WhereNotNull(field string) QueryBuilder <span class="cov0" title="0">{
        return q.Where(field, "$ne", nil)
}</span>

func (q *BaseQueryBuilder) WhereRegex(field string, pattern string) QueryBuilder <span class="cov0" title="0">{
        return q.Where(field, "$regex", pattern)
}</span>

func (q *BaseQueryBuilder) Or(conditions ...QueryBuilder) QueryBuilder <span class="cov0" title="0">{
        orGroup := make([]QueryCondition, 0)
        for _, cond := range conditions </span><span class="cov0" title="0">{
                if baseBuilder, ok := cond.(*BaseQueryBuilder); ok </span><span class="cov0" title="0">{
                        orGroup = append(orGroup, baseBuilder.conditions...)
                }</span>
        }
        <span class="cov0" title="0">q.orGroups = append(q.orGroups, orGroup)
        return q</span>
}

func (q *BaseQueryBuilder) And(conditions ...QueryBuilder) QueryBuilder <span class="cov0" title="0">{
        for _, cond := range conditions </span><span class="cov0" title="0">{
                if baseBuilder, ok := cond.(*BaseQueryBuilder); ok </span><span class="cov0" title="0">{
                        q.conditions = append(q.conditions, baseBuilder.conditions...)
                }</span>
        }
        <span class="cov0" title="0">return q</span>
}

func (q *BaseQueryBuilder) Clone() QueryBuilder <span class="cov0" title="0">{
        clone := &amp;BaseQueryBuilder{
                conditions: make([]QueryCondition, len(q.conditions)),
                orGroups:   make([][]QueryCondition, len(q.orGroups)),
        }
        copy(clone.conditions, q.conditions)
        copy(clone.orGroups, q.orGroups)
        return clone
}</span>

func (q *BaseQueryBuilder) ToMap() map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        
        // Add regular conditions
        for _, cond := range q.conditions </span><span class="cov0" title="0">{
                if cond.Operator == "$eq" || cond.Operator == "=" </span><span class="cov0" title="0">{
                        result[cond.Field] = cond.Value
                }</span> else<span class="cov0" title="0"> {
                        if existing, exists := result[cond.Field]; exists </span><span class="cov0" title="0">{
                                if existingMap, ok := existing.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        existingMap[cond.Operator] = cond.Value
                                }</span> else<span class="cov0" title="0"> {
                                        result[cond.Field] = map[string]interface{}{
                                                cond.Operator: cond.Value,
                                        }
                                }</span>
                        } else<span class="cov0" title="0"> {
                                result[cond.Field] = map[string]interface{}{
                                        cond.Operator: cond.Value,
                                }
                        }</span>
                }
        }
        
        // Add OR groups
        <span class="cov0" title="0">if len(q.orGroups) &gt; 0 </span><span class="cov0" title="0">{
                orConditions := make([]map[string]interface{}, 0)
                for _, group := range q.orGroups </span><span class="cov0" title="0">{
                        groupMap := make(map[string]interface{})
                        for _, cond := range group </span><span class="cov0" title="0">{
                                if cond.Operator == "$eq" || cond.Operator == "=" </span><span class="cov0" title="0">{
                                        groupMap[cond.Field] = cond.Value
                                }</span> else<span class="cov0" title="0"> {
                                        groupMap[cond.Field] = map[string]interface{}{
                                                cond.Operator: cond.Value,
                                        }
                                }</span>
                        }
                        <span class="cov0" title="0">orConditions = append(orConditions, groupMap)</span>
                }
                <span class="cov0" title="0">result["$or"] = orConditions</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// SQLQueryBuilder extends BaseQueryBuilder for SQL-specific functionality
type SQLQueryBuilder struct {
        *BaseQueryBuilder
        rawConditions []RawCondition
}

type RawCondition struct {
        SQL  string
        Args []interface{}
}

func NewSQLQueryBuilder() *SQLQueryBuilder <span class="cov0" title="0">{
        return &amp;SQLQueryBuilder{
                BaseQueryBuilder: &amp;BaseQueryBuilder{
                        conditions: make([]QueryCondition, 0),
                        orGroups:   make([][]QueryCondition, 0),
                },
                rawConditions: make([]RawCondition, 0),
        }
}</span>

// WhereRaw adds a raw SQL condition
func (q *SQLQueryBuilder) WhereRaw(sql string, args ...interface{}) *SQLQueryBuilder <span class="cov0" title="0">{
        q.rawConditions = append(q.rawConditions, RawCondition{
                SQL:  sql,
                Args: args,
        })
        return q
}</span>

// ToSQL converts the query to SQL WHERE clause
func (q *SQLQueryBuilder) ToSQL() (string, []interface{}) <span class="cov0" title="0">{
        if len(q.conditions) == 0 &amp;&amp; len(q.orGroups) == 0 &amp;&amp; len(q.rawConditions) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">var whereParts []string
        var args []interface{}
        
        // Add regular conditions
        for _, cond := range q.conditions </span><span class="cov0" title="0">{
                sqlOperator, argCount := q.convertOperator(cond.Operator)
                if argCount == 0 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s", cond.Field, sqlOperator))
                }</span> else<span class="cov0" title="0"> if argCount == 1 </span><span class="cov0" title="0">{
                        whereParts = append(whereParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s ?", cond.Field, sqlOperator))
                        args = append(args, cond.Value)
                }</span> else<span class="cov0" title="0"> {
                        // Handle IN/NOT IN operators
                        if values, ok := cond.Value.([]interface{}); ok </span><span class="cov0" title="0">{
                                placeholders := strings.Repeat("?,", len(values))
                                placeholders = placeholders[:len(placeholders)-1] // remove trailing comma
                                whereParts = append(whereParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s (%s)", cond.Field, sqlOperator, placeholders))
                                args = append(args, values...)
                        }</span>
                }
        }
        
        // Add OR groups
        <span class="cov0" title="0">for _, group := range q.orGroups </span><span class="cov0" title="0">{
                if len(group) &gt; 0 </span><span class="cov0" title="0">{
                        var orParts []string
                        for _, cond := range group </span><span class="cov0" title="0">{
                                sqlOperator, argCount := q.convertOperator(cond.Operator)
                                if argCount == 0 </span><span class="cov0" title="0">{
                                        orParts = append(orParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s", cond.Field, sqlOperator))
                                }</span> else<span class="cov0" title="0"> if argCount == 1 </span><span class="cov0" title="0">{
                                        orParts = append(orParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s ?", cond.Field, sqlOperator))
                                        args = append(args, cond.Value)
                                }</span> else<span class="cov0" title="0"> {
                                        // Handle IN/NOT IN operators
                                        if values, ok := cond.Value.([]interface{}); ok </span><span class="cov0" title="0">{
                                                placeholders := strings.Repeat("?,", len(values))
                                                placeholders = placeholders[:len(placeholders)-1]
                                                orParts = append(orParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s (%s)", cond.Field, sqlOperator, placeholders))
                                                args = append(args, values...)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if len(orParts) &gt; 0 </span><span class="cov0" title="0">{
                                whereParts = append(whereParts, fmt.Sprintf("(%s)", strings.Join(orParts, " OR ")))
                        }</span>
                }
        }
        
        // Add raw conditions
        <span class="cov0" title="0">for _, rawCond := range q.rawConditions </span><span class="cov0" title="0">{
                whereParts = append(whereParts, rawCond.SQL)
                args = append(args, rawCond.Args...)
        }</span>
        
        <span class="cov0" title="0">if len(whereParts) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        
        <span class="cov0" title="0">return strings.Join(whereParts, " AND "), args</span>
}

// convertOperator converts MongoDB operators to SQL operators
func (q *SQLQueryBuilder) convertOperator(mongoOp string) (string, int) <span class="cov0" title="0">{
        switch mongoOp </span>{
        case "$eq", "=":<span class="cov0" title="0">
                return "=", 1</span>
        case "$ne", "!=":<span class="cov0" title="0">
                return "!=", 1</span>
        case "$gt", "&gt;":<span class="cov0" title="0">
                return "&gt;", 1</span>
        case "$gte", "&gt;=":<span class="cov0" title="0">
                return "&gt;=", 1</span>
        case "$lt", "&lt;":<span class="cov0" title="0">
                return "&lt;", 1</span>
        case "$lte", "&lt;=":<span class="cov0" title="0">
                return "&lt;=", 1</span>
        case "$in":<span class="cov0" title="0">
                return "IN", 2</span> // Special case for multiple values
        case "$nin":<span class="cov0" title="0">
                return "NOT IN", 2</span> // Special case for multiple values
        case "$regex":<span class="cov0" title="0">
                return "LIKE", 1</span> // Convert regex to LIKE for basic pattern matching
        case "$exists":<span class="cov0" title="0">
                return "IS NOT NULL", 0</span>
        default:<span class="cov0" title="0">
                return "=", 1</span> // Default to equality
        }
}

// BaseUpdateBuilder provides a basic implementation of UpdateBuilder
type BaseUpdateBuilder struct {
        operations map[string]map[string]interface{}
}

func NewUpdateBuilder() UpdateBuilder <span class="cov0" title="0">{
        return &amp;BaseUpdateBuilder{
                operations: make(map[string]map[string]interface{}),
        }
}</span>

func (u *BaseUpdateBuilder) Set(field string, value interface{}) UpdateBuilder <span class="cov0" title="0">{
        if u.operations["$set"] == nil </span><span class="cov0" title="0">{
                u.operations["$set"] = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">u.operations["$set"][field] = value
        return u</span>
}

func (u *BaseUpdateBuilder) Unset(field string) UpdateBuilder <span class="cov0" title="0">{
        if u.operations["$unset"] == nil </span><span class="cov0" title="0">{
                u.operations["$unset"] = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">u.operations["$unset"][field] = ""
        return u</span>
}

func (u *BaseUpdateBuilder) Inc(field string, value interface{}) UpdateBuilder <span class="cov0" title="0">{
        if u.operations["$inc"] == nil </span><span class="cov0" title="0">{
                u.operations["$inc"] = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">u.operations["$inc"][field] = value
        return u</span>
}

func (u *BaseUpdateBuilder) Push(field string, value interface{}) UpdateBuilder <span class="cov0" title="0">{
        if u.operations["$push"] == nil </span><span class="cov0" title="0">{
                u.operations["$push"] = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">u.operations["$push"][field] = value
        return u</span>
}

func (u *BaseUpdateBuilder) Pull(field string, value interface{}) UpdateBuilder <span class="cov0" title="0">{
        if u.operations["$pull"] == nil </span><span class="cov0" title="0">{
                u.operations["$pull"] = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">u.operations["$pull"][field] = value
        return u</span>
}

func (u *BaseUpdateBuilder) AddToSet(field string, value interface{}) UpdateBuilder <span class="cov0" title="0">{
        if u.operations["$addToSet"] == nil </span><span class="cov0" title="0">{
                u.operations["$addToSet"] = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">u.operations["$addToSet"][field] = value
        return u</span>
}

func (u *BaseUpdateBuilder) ToMap() map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for op, fields := range u.operations </span><span class="cov0" title="0">{
                result[op] = fields
        }</span>
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// ColumnType represents the SQL column type for a field
type ColumnType string

const (
        ColumnTypeText    ColumnType = "TEXT"
        ColumnTypeInteger ColumnType = "INTEGER"
        ColumnTypeReal    ColumnType = "REAL"
        ColumnTypeBoolean ColumnType = "BOOLEAN"
        ColumnTypeDate    ColumnType = "DATETIME"
        ColumnTypeJSON    ColumnType = "JSON"
)

// FieldDefinition represents a field definition from config.json
type FieldDefinition struct {
        Type     string      `json:"type"`
        Required bool        `json:"required"`
        Default  interface{} `json:"default"`
        Index    bool        `json:"index"`
}

// ColumnDefinition represents a database column
type ColumnDefinition struct {
        Name         string
        Type         ColumnType
        Required     bool
        Default      interface{}
        Index        bool
        IsPrimary    bool
        IsTimestamp  bool
        OriginalType string // Original deployd type (string, number, etc.)
}

// CollectionSchema represents the schema for a collection
type CollectionSchema struct {
        Name       string
        Columns    []ColumnDefinition
        UseColumns bool // Whether to use column-based or JSON-based storage
        ConfigPath string
        ModTime    time.Time
}

// SchemaManager handles schema detection, migration, and management
type SchemaManager struct {
        db         *sql.DB
        dbType     DatabaseType
        configPath string
        schemas    map[string]*CollectionSchema
}

// NewSchemaManager creates a new schema manager
func NewSchemaManager(db *sql.DB, dbType DatabaseType, configPath string) *SchemaManager <span class="cov10" title="4">{
        return &amp;SchemaManager{
                db:         db,
                dbType:     dbType,
                configPath: configPath,
                schemas:    make(map[string]*CollectionSchema),
        }
}</span>

// GetSchema returns the schema for a collection, loading it if necessary
func (sm *SchemaManager) GetSchema(collectionName string) (*CollectionSchema, error) <span class="cov8" title="3">{
        // Check if we have a cached schema
        if schema, exists := sm.schemas[collectionName]; exists </span><span class="cov0" title="0">{
                // Check if config file has been modified
                configPath := sm.getConfigPath(collectionName)
                if stat, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                        if stat.ModTime().After(schema.ModTime) </span><span class="cov0" title="0">{
                                // Config file was modified, reload schema
                                delete(sm.schemas, collectionName)
                        }</span> else<span class="cov0" title="0"> {
                                return schema, nil
                        }</span>
                }
        }

        // Load schema from config
        <span class="cov8" title="3">schema, err := sm.loadSchemaFromConfig(collectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">sm.schemas[collectionName] = schema
        return schema, nil</span>
}

// loadSchemaFromConfig loads schema definition from config.json
func (sm *SchemaManager) loadSchemaFromConfig(collectionName string) (*CollectionSchema, error) <span class="cov8" title="3">{
        configPath := sm.getConfigPath(collectionName)
        
        // Check if config file exists
        stat, err := os.Stat(configPath)
        if os.IsNotExist(err) </span><span class="cov8" title="3">{
                // No config file, use default JSON-based schema
                return &amp;CollectionSchema{
                        Name:       collectionName,
                        UseColumns: false,
                        Columns:    sm.getDefaultColumns(),
                        ConfigPath: configPath,
                        ModTime:    time.Now(),
                }, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat config file: %w", err)
        }</span>

        // Read config file
        <span class="cov0" title="0">configData, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var config struct {
                Properties map[string]FieldDefinition `json:"properties"`
                Options    struct {
                        UseColumns bool `json:"useColumns"`
                } `json:"options"`
        }

        if err := json.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Convert field definitions to column definitions
        <span class="cov0" title="0">columns := sm.getDefaultColumns() // Always include id, created_at, updated_at
        
        for fieldName, fieldDef := range config.Properties </span><span class="cov0" title="0">{
                // Skip system fields that are already included
                if fieldName == "id" || fieldName == "createdAt" || fieldName == "updatedAt" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">column := ColumnDefinition{
                        Name:         fieldName,
                        Type:         sm.mapFieldTypeToColumn(fieldDef.Type),
                        Required:     fieldDef.Required,
                        Default:      fieldDef.Default,
                        Index:        fieldDef.Index,
                        OriginalType: fieldDef.Type,
                }

                columns = append(columns, column)</span>
        }

        <span class="cov0" title="0">return &amp;CollectionSchema{
                Name:       collectionName,
                UseColumns: config.Options.UseColumns,
                Columns:    columns,
                ConfigPath: configPath,
                ModTime:    stat.ModTime(),
        }, nil</span>
}

// getConfigPath returns the path to the config.json file for a collection
func (sm *SchemaManager) getConfigPath(collectionName string) string <span class="cov8" title="3">{
        if sm.configPath != "" </span><span class="cov0" title="0">{
                return filepath.Join(sm.configPath, collectionName, "config.json")
        }</span>
        <span class="cov8" title="3">return filepath.Join("resources", collectionName, "config.json")</span>
}

// getDefaultColumns returns the default system columns
func (sm *SchemaManager) getDefaultColumns() []ColumnDefinition <span class="cov8" title="3">{
        return []ColumnDefinition{
                {
                        Name:        "id",
                        Type:        ColumnTypeText,
                        Required:    true,
                        IsPrimary:   true,
                        OriginalType: "string",
                },
                {
                        Name:        "created_at",
                        Type:        ColumnTypeDate,
                        Required:    true,
                        IsTimestamp: true,
                        OriginalType: "date",
                },
                {
                        Name:        "updated_at",
                        Type:        ColumnTypeDate,
                        Required:    true,
                        IsTimestamp: true,
                        OriginalType: "date",
                },
                {
                        Name:        "data",
                        Type:        ColumnTypeJSON,
                        Required:    false,
                        OriginalType: "object",
                },
        }
}</span>

// mapFieldTypeToColumn maps deployd field types to SQL column types
func (sm *SchemaManager) mapFieldTypeToColumn(fieldType string) ColumnType <span class="cov0" title="0">{
        switch strings.ToLower(fieldType) </span>{
        case "string", "text":<span class="cov0" title="0">
                return ColumnTypeText</span>
        case "number", "integer", "int":<span class="cov0" title="0">
                return ColumnTypeReal</span>
        case "boolean", "bool":<span class="cov0" title="0">
                return ColumnTypeBoolean</span>
        case "date", "datetime", "timestamp":<span class="cov0" title="0">
                return ColumnTypeDate</span>
        case "array", "object":<span class="cov0" title="0">
                return ColumnTypeJSON</span>
        default:<span class="cov0" title="0">
                return ColumnTypeText</span> // Default to text for unknown types
        }
}

// EnsureSchema ensures the table schema matches the collection config
func (sm *SchemaManager) EnsureSchema(collectionName string) error <span class="cov0" title="0">{
        schema, err := sm.GetSchema(collectionName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if table exists
        <span class="cov0" title="0">exists, err := sm.tableExists(collectionName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return sm.createTable(schema)
        }</span>

        // Table exists, check if schema needs updating
        <span class="cov0" title="0">if schema.UseColumns </span><span class="cov0" title="0">{
                return sm.migrateSchema(schema)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// tableExists checks if a table exists
func (sm *SchemaManager) tableExists(tableName string) (bool, error) <span class="cov0" title="0">{
        var query string
        var args []interface{}

        switch sm.dbType </span>{
        case DatabaseTypeSQLite:<span class="cov0" title="0">
                query = "SELECT name FROM sqlite_master WHERE type='table' AND name=?"
                args = []interface{}{tableName}</span>
        case DatabaseTypeMySQL:<span class="cov0" title="0">
                query = "SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = ?"
                args = []interface{}{tableName}</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsupported database type: %v", sm.dbType)</span>
        }

        <span class="cov0" title="0">var name string
        err := sm.db.QueryRow(query, args...).Scan(&amp;name)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// createTable creates a new table with the specified schema
func (sm *SchemaManager) createTable(schema *CollectionSchema) error <span class="cov0" title="0">{
        var sql strings.Builder
        quotedTable := sm.quoteIdentifier(schema.Name)
        
        sql.WriteString(fmt.Sprintf("CREATE TABLE %s (", quotedTable))

        for i, column := range schema.Columns </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        sql.WriteString(", ")
                }</span>

                <span class="cov0" title="0">sql.WriteString(sm.buildColumnDefinition(column))</span>
        }

        <span class="cov0" title="0">sql.WriteString(")")

        if _, err := sm.db.Exec(sql.String()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create table %s: %w", schema.Name, err)
        }</span>

        // Create indexes
        <span class="cov0" title="0">for _, column := range schema.Columns </span><span class="cov0" title="0">{
                if column.Index &amp;&amp; !column.IsPrimary </span><span class="cov0" title="0">{
                        if err := sm.createIndex(schema.Name, column.Name); err != nil </span><span class="cov0" title="0">{
                                // Log warning but don't fail
                                fmt.Printf("Warning: failed to create index for %s.%s: %v\n", schema.Name, column.Name, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// buildColumnDefinition builds the SQL column definition
func (sm *SchemaManager) buildColumnDefinition(column ColumnDefinition) string <span class="cov0" title="0">{
        var def strings.Builder
        
        def.WriteString(sm.quoteIdentifier(column.Name))
        def.WriteString(" ")
        def.WriteString(sm.getColumnTypeSQL(column.Type))

        if column.IsPrimary </span><span class="cov0" title="0">{
                def.WriteString(" PRIMARY KEY")
        }</span>

        <span class="cov0" title="0">if column.Required &amp;&amp; !column.IsPrimary </span><span class="cov0" title="0">{
                def.WriteString(" NOT NULL")
        }</span>

        <span class="cov0" title="0">if column.Default != nil &amp;&amp; !column.IsTimestamp </span><span class="cov0" title="0">{
                switch v := column.Default.(type) </span>{
                case string:<span class="cov0" title="0">
                        if v == "now" &amp;&amp; column.Type == ColumnTypeDate </span><span class="cov0" title="0">{
                                def.WriteString(" DEFAULT CURRENT_TIMESTAMP")
                        }</span> else<span class="cov0" title="0"> {
                                def.WriteString(fmt.Sprintf(" DEFAULT '%s'", v))
                        }</span>
                case bool:<span class="cov0" title="0">
                        if v </span><span class="cov0" title="0">{
                                def.WriteString(" DEFAULT 1")
                        }</span> else<span class="cov0" title="0"> {
                                def.WriteString(" DEFAULT 0")
                        }</span>
                default:<span class="cov0" title="0">
                        def.WriteString(fmt.Sprintf(" DEFAULT %v", v))</span>
                }
        } else<span class="cov0" title="0"> if column.IsTimestamp </span><span class="cov0" title="0">{
                def.WriteString(" DEFAULT CURRENT_TIMESTAMP")
        }</span>

        <span class="cov0" title="0">return def.String()</span>
}

// getColumnTypeSQL returns the database-specific SQL type for a column type
func (sm *SchemaManager) getColumnTypeSQL(colType ColumnType) string <span class="cov0" title="0">{
        switch sm.dbType </span>{
        case DatabaseTypeMySQL:<span class="cov0" title="0">
                switch colType </span>{
                case ColumnTypeText:<span class="cov0" title="0">
                        return "VARCHAR(255)"</span>
                case ColumnTypeInteger:<span class="cov0" title="0">
                        return "BIGINT"</span>
                case ColumnTypeReal:<span class="cov0" title="0">
                        return "DOUBLE"</span>
                case ColumnTypeBoolean:<span class="cov0" title="0">
                        return "TINYINT(1)"</span>
                case ColumnTypeDate:<span class="cov0" title="0">
                        return "DATETIME"</span>
                case ColumnTypeJSON:<span class="cov0" title="0">
                        return "JSON"</span>
                default:<span class="cov0" title="0">
                        return "VARCHAR(255)"</span>
                }
        case DatabaseTypeSQLite:<span class="cov0" title="0">
                // SQLite is flexible with types, use the generic names
                return string(colType)</span>
        default:<span class="cov0" title="0">
                return string(colType)</span>
        }
}

// quoteIdentifier quotes an SQL identifier (table or column name)
func (sm *SchemaManager) quoteIdentifier(name string) string <span class="cov0" title="0">{
        switch sm.dbType </span>{
        case DatabaseTypeSQLite:<span class="cov0" title="0">
                return fmt.Sprintf(`"%s"`, name)</span>
        case DatabaseTypeMySQL:<span class="cov0" title="0">
                return fmt.Sprintf("`%s`", name)</span>
        default:<span class="cov0" title="0">
                return name</span>
        }
}

// createIndex creates an index for a column
func (sm *SchemaManager) createIndex(tableName, columnName string) error <span class="cov0" title="0">{
        indexName := fmt.Sprintf("idx_%s_%s", tableName, columnName)
        quotedTable := sm.quoteIdentifier(tableName)
        quotedColumn := sm.quoteIdentifier(columnName)
        quotedIndex := sm.quoteIdentifier(indexName)

        query := fmt.Sprintf("CREATE INDEX %s ON %s (%s)", quotedIndex, quotedTable, quotedColumn)
        
        _, err := sm.db.Exec(query)
        return err
}</span>

// dropIndex drops an index for a column
func (sm *SchemaManager) dropIndex(tableName, columnName string) error <span class="cov0" title="0">{
        indexName := fmt.Sprintf("idx_%s_%s", tableName, columnName)
        quotedIndex := sm.quoteIdentifier(indexName)

        var query string
        switch sm.dbType </span>{
        case DatabaseTypeMySQL:<span class="cov0" title="0">
                quotedTable := sm.quoteIdentifier(tableName)
                query = fmt.Sprintf("DROP INDEX %s ON %s", quotedIndex, quotedTable)</span>
        case DatabaseTypeSQLite:<span class="cov0" title="0">
                query = fmt.Sprintf("DROP INDEX IF EXISTS %s", quotedIndex)</span>
        default:<span class="cov0" title="0">
                query = fmt.Sprintf("DROP INDEX %s", quotedIndex)</span>
        }
        
        <span class="cov0" title="0">_, err := sm.db.Exec(query)
        return err</span>
}

// migrateSchema migrates an existing table to match the schema
func (sm *SchemaManager) migrateSchema(schema *CollectionSchema) error <span class="cov0" title="0">{
        // Get current table structure
        currentColumns, err := sm.getTableColumns(schema.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Compare with desired schema and generate migrations
        <span class="cov0" title="0">migrations := sm.generateMigrations(currentColumns, schema.Columns)

        // Execute migrations
        for _, migration := range migrations </span><span class="cov0" title="0">{
                if err := sm.executeMigration(schema.Name, migration); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute migration %s: %w", migration.Type, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Migration represents a schema migration operation
type Migration struct {
        Type   string // ADD_COLUMN, DROP_COLUMN, MODIFY_COLUMN
        Column ColumnDefinition
        OldColumn *ColumnDefinition // For modify operations
}

// getTableColumns retrieves the current table column structure
func (sm *SchemaManager) getTableColumns(tableName string) ([]ColumnDefinition, error) <span class="cov0" title="0">{
        var columns []ColumnDefinition

        switch sm.dbType </span>{
        case DatabaseTypeSQLite:<span class="cov0" title="0">
                query := fmt.Sprintf("PRAGMA table_info(%s)", sm.quoteIdentifier(tableName))
                rows, err := sm.db.Query(query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        var cid int
                        var name, dataType string
                        var notNull bool
                        var dfltValue *string
                        var pk bool

                        if err := rows.Scan(&amp;cid, &amp;name, &amp;dataType, &amp;notNull, &amp;dfltValue, &amp;pk); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">column := ColumnDefinition{
                                Name:      name,
                                Type:      ColumnType(strings.ToUpper(dataType)),
                                Required:  notNull,
                                IsPrimary: pk,
                        }

                        if dfltValue != nil </span><span class="cov0" title="0">{
                                column.Default = *dfltValue
                        }</span>

                        <span class="cov0" title="0">columns = append(columns, column)</span>
                }

        case DatabaseTypeMySQL:<span class="cov0" title="0">
                query := `
                        SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT, COLUMN_KEY 
                        FROM information_schema.COLUMNS 
                        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = ?
                        ORDER BY ORDINAL_POSITION
                `
                rows, err := sm.db.Query(query, tableName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        var name, dataType, isNullable string
                        var columnDefault *string
                        var columnKey string

                        if err := rows.Scan(&amp;name, &amp;dataType, &amp;isNullable, &amp;columnDefault, &amp;columnKey); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">column := ColumnDefinition{
                                Name:      name,
                                Type:      sm.mapMySQLTypeToColumn(dataType),
                                Required:  isNullable == "NO",
                                IsPrimary: columnKey == "PRI",
                        }

                        if columnDefault != nil </span><span class="cov0" title="0">{
                                column.Default = *columnDefault
                        }</span>

                        <span class="cov0" title="0">columns = append(columns, column)</span>
                }
        }

        <span class="cov0" title="0">return columns, nil</span>
}

// mapMySQLTypeToColumn maps MySQL data types to our column types
func (sm *SchemaManager) mapMySQLTypeToColumn(mysqlType string) ColumnType <span class="cov0" title="0">{
        switch strings.ToLower(mysqlType) </span>{
        case "varchar", "text", "char":<span class="cov0" title="0">
                return ColumnTypeText</span>
        case "int", "bigint", "smallint":<span class="cov0" title="0">
                return ColumnTypeInteger</span>
        case "float", "double", "decimal":<span class="cov0" title="0">
                return ColumnTypeReal</span>
        case "tinyint":<span class="cov0" title="0">
                return ColumnTypeBoolean</span>
        case "datetime", "timestamp":<span class="cov0" title="0">
                return ColumnTypeDate</span>
        case "json":<span class="cov0" title="0">
                return ColumnTypeJSON</span>
        default:<span class="cov0" title="0">
                return ColumnTypeText</span>
        }
}

// generateMigrations compares current and desired schemas to generate migrations
func (sm *SchemaManager) generateMigrations(current, desired []ColumnDefinition) []Migration <span class="cov0" title="0">{
        var migrations []Migration

        // Create maps for easier lookup
        currentMap := make(map[string]ColumnDefinition)
        for _, col := range current </span><span class="cov0" title="0">{
                currentMap[col.Name] = col
        }</span>

        <span class="cov0" title="0">desiredMap := make(map[string]ColumnDefinition)
        for _, col := range desired </span><span class="cov0" title="0">{
                desiredMap[col.Name] = col
        }</span>

        // Find columns to add (safe for all databases)
        <span class="cov0" title="0">for _, desiredCol := range desired </span><span class="cov0" title="0">{
                if _, exists := currentMap[desiredCol.Name]; !exists </span><span class="cov0" title="0">{
                        migrations = append(migrations, Migration{
                                Type:   "ADD_COLUMN",
                                Column: desiredCol,
                        })
                }</span>
        }

        // Only attempt drops and modifications for databases that support them
        <span class="cov0" title="0">if sm.dbType != DatabaseTypeSQLite </span><span class="cov0" title="0">{
                // Find columns to drop (MySQL only - be careful here!)
                for _, currentCol := range current </span><span class="cov0" title="0">{
                        if _, exists := desiredMap[currentCol.Name]; !exists &amp;&amp; !sm.isSystemColumn(currentCol.Name) </span><span class="cov0" title="0">{
                                migrations = append(migrations, Migration{
                                        Type:   "DROP_COLUMN",
                                        Column: currentCol,
                                })
                        }</span>
                }

                // Find columns to modify (MySQL only)
                <span class="cov0" title="0">for _, desiredCol := range desired </span><span class="cov0" title="0">{
                        if currentCol, exists := currentMap[desiredCol.Name]; exists </span><span class="cov0" title="0">{
                                if sm.columnNeedsModification(currentCol, desiredCol) </span><span class="cov0" title="0">{
                                        migrations = append(migrations, Migration{
                                                Type:      "MODIFY_COLUMN",
                                                Column:    desiredCol,
                                                OldColumn: &amp;currentCol,
                                        })
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // For SQLite, log warnings about unsupported changes instead of failing
                for _, currentCol := range current </span><span class="cov0" title="0">{
                        if _, exists := desiredMap[currentCol.Name]; !exists &amp;&amp; !sm.isSystemColumn(currentCol.Name) </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: Cannot drop column %s from SQLite table (not supported)\n", currentCol.Name)
                        }</span>
                }

                <span class="cov0" title="0">for _, desiredCol := range desired </span><span class="cov0" title="0">{
                        if currentCol, exists := currentMap[desiredCol.Name]; exists </span><span class="cov0" title="0">{
                                if sm.columnNeedsModification(currentCol, desiredCol) </span><span class="cov0" title="0">{
                                        fmt.Printf("Warning: Cannot modify column %s in SQLite table (not supported), keeping existing definition\n", desiredCol.Name)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return migrations</span>
}

// isSystemColumn checks if a column is a system column that shouldn't be dropped
func (sm *SchemaManager) isSystemColumn(columnName string) bool <span class="cov0" title="0">{
        systemColumns := []string{"id", "created_at", "updated_at", "data"}
        for _, sysCol := range systemColumns </span><span class="cov0" title="0">{
                if columnName == sysCol </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// columnNeedsModification checks if a column definition needs to be modified
func (sm *SchemaManager) columnNeedsModification(current, desired ColumnDefinition) bool <span class="cov0" title="0">{
        return current.Type != desired.Type ||
                   current.Required != desired.Required ||
                   !sm.defaultsEqual(current.Default, desired.Default)
}</span>

// defaultsEqual compares two default values
func (sm *SchemaManager) defaultsEqual(a, b interface{}) bool <span class="cov0" title="0">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%v", a) == fmt.Sprintf("%v", b)</span>
}

// executeMigration executes a single migration
func (sm *SchemaManager) executeMigration(tableName string, migration Migration) error <span class="cov0" title="0">{
        quotedTable := sm.quoteIdentifier(tableName)
        quotedColumn := sm.quoteIdentifier(migration.Column.Name)

        switch migration.Type </span>{
        case "ADD_COLUMN":<span class="cov0" title="0">
                query := fmt.Sprintf("ALTER TABLE %s ADD COLUMN %s", quotedTable, sm.buildColumnDefinition(migration.Column))
                _, err := sm.db.Exec(query)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Create index if requested
                <span class="cov0" title="0">if migration.Column.Index &amp;&amp; !migration.Column.IsPrimary </span><span class="cov0" title="0">{
                        if err := sm.createIndex(tableName, migration.Column.Name); err != nil </span><span class="cov0" title="0">{
                                // Log warning but don't fail the migration
                                fmt.Printf("Warning: failed to create index for %s.%s: %v\n", tableName, migration.Column.Name, err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>

        case "DROP_COLUMN":<span class="cov0" title="0">
                if sm.dbType == DatabaseTypeSQLite </span><span class="cov0" title="0">{
                        // SQLite doesn't support DROP COLUMN directly, would need table recreation
                        return fmt.Errorf("DROP COLUMN not supported for SQLite (would require table recreation)")
                }</span>
                <span class="cov0" title="0">query := fmt.Sprintf("ALTER TABLE %s DROP COLUMN %s", quotedTable, quotedColumn)
                _, err := sm.db.Exec(query)
                return err</span>

        case "MODIFY_COLUMN":<span class="cov0" title="0">
                if sm.dbType == DatabaseTypeSQLite </span><span class="cov0" title="0">{
                        return fmt.Errorf("MODIFY COLUMN not supported for SQLite (would require table recreation)")
                }</span>
                // MySQL
                <span class="cov0" title="0">query := fmt.Sprintf("ALTER TABLE %s MODIFY COLUMN %s", quotedTable, sm.buildColumnDefinition(migration.Column))
                _, err := sm.db.Exec(query)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Handle index changes for modified columns
                <span class="cov0" title="0">if migration.Column.Index &amp;&amp; !migration.Column.IsPrimary </span><span class="cov0" title="0">{
                        // Check if index exists, if not create it
                        if err := sm.createIndex(tableName, migration.Column.Name); err != nil </span><span class="cov0" title="0">{
                                // Index might already exist, that's ok
                                fmt.Printf("Info: index creation for %s.%s: %v\n", tableName, migration.Column.Name, err)
                        }</span>
                } else<span class="cov0" title="0"> if migration.OldColumn != nil &amp;&amp; migration.OldColumn.Index &amp;&amp; !migration.Column.Index </span><span class="cov0" title="0">{
                        // Remove index if it was removed from the schema
                        if err := sm.dropIndex(tableName, migration.Column.Name); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to drop index for %s.%s: %v\n", tableName, migration.Column.Name, err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown migration type: %s", migration.Type)</span>
        }
}</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        _ "github.com/mattn/go-sqlite3"
)

// SQLiteDatabase implements DatabaseInterface for SQLite
type SQLiteDatabase struct {
        db            *sql.DB
        config        *Config
        schemaManager *SchemaManager
}

// SQLiteStore implements StoreInterface for SQLite
type SQLiteStore struct {
        tableName string
        db        *sql.DB
        database  *SQLiteDatabase
}

// SQLiteUpdateResult implements UpdateResult interface
type SQLiteUpdateResult struct {
        modifiedCount int64
        upsertedCount int64
        upsertedID    interface{}
}

func (r *SQLiteUpdateResult) ModifiedCount() int64   <span class="cov0" title="0">{ return r.modifiedCount }</span>
func (r *SQLiteUpdateResult) UpsertedCount() int64   <span class="cov0" title="0">{ return r.upsertedCount }</span>
func (r *SQLiteUpdateResult) UpsertedID() interface{} <span class="cov0" title="0">{ return r.upsertedID }</span>

// SQLiteDeleteResult implements DeleteResult interface
type SQLiteDeleteResult struct {
        deletedCount int64
}

func (r *SQLiteDeleteResult) DeletedCount() int64 <span class="cov0" title="0">{ return r.deletedCount }</span>

// NewSQLiteDatabase creates a new SQLite database instance
func NewSQLiteDatabase(config *Config) (DatabaseInterface, error) <span class="cov6" title="4">{
        var dbPath string
        if config.Host == "" || config.Host == "localhost" </span><span class="cov6" title="4">{
                // Use file-based SQLite
                if strings.HasSuffix(config.Name, ".db") || strings.HasSuffix(config.Name, ".sqlite") </span><span class="cov0" title="0">{
                        dbPath = config.Name
                }</span> else<span class="cov6" title="4"> {
                        // Default to deployd.sqlite if no specific file extension
                        if config.Name == "deployd" </span><span class="cov0" title="0">{
                                dbPath = "deployd.sqlite"
                        }</span> else<span class="cov6" title="4"> {
                                dbPath = config.Name + ".sqlite"
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                dbPath = config.Host
        }</span>

        // Ensure the directory exists
        <span class="cov6" title="4">dir := filepath.Dir(dbPath)
        if dir != "." &amp;&amp; dir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create database directory: %w", err)
                }</span>
        }

        <span class="cov6" title="4">db, err := sql.Open("sqlite3", dbPath+"?_journal_mode=WAL&amp;_foreign_keys=on")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open SQLite database: %w", err)
        }</span>

        // Test connection
        <span class="cov6" title="4">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping SQLite database: %w", err)
        }</span>

        <span class="cov6" title="4">sqliteDB := &amp;SQLiteDatabase{
                db:     db,
                config: config,
        }

        // Initialize schema manager
        sqliteDB.schemaManager = NewSchemaManager(db, DatabaseTypeSQLite, "")

        return sqliteDB, nil</span>
}

func (d *SQLiteDatabase) CreateStore(namespace string) StoreInterface <span class="cov5" title="3">{
        // Check if this collection should use column-based storage
        schema, err := d.schemaManager.GetSchema(namespace)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but fall back to JSON store
                fmt.Printf("Warning: failed to get schema for %s, using JSON storage: %v\n", namespace, err)
                store := &amp;SQLiteStore{
                        tableName: namespace,
                        db:        d.db,
                        database:  d,
                }
                store.ensureTable()
                return store
        }</span>

        <span class="cov5" title="3">if schema.UseColumns </span><span class="cov0" title="0">{
                // Use column-based storage
                columnStore, err := NewColumnStore(namespace, d.db, d, d.schemaManager)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but fall back to JSON store
                        fmt.Printf("Warning: failed to create column store for %s, using JSON storage: %v\n", namespace, err)
                        store := &amp;SQLiteStore{
                                tableName: namespace,
                                db:        d.db,
                                database:  d,
                        }
                        store.ensureTable()
                        return store
                }</span>
                <span class="cov0" title="0">return columnStore</span>
        }

        // Use traditional JSON-based storage
        <span class="cov5" title="3">store := &amp;SQLiteStore{
                tableName: namespace,
                db:        d.db,
                database:  d,
        }

        // Ensure table exists
        store.ensureTable()

        return store</span>
}

func (d *SQLiteDatabase) Close() error <span class="cov6" title="4">{
        return d.db.Close()
}</span>

func (d *SQLiteDatabase) Drop() error <span class="cov0" title="0">{
        // Get all table names
        rows, err := d.db.Query("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get table names: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := rows.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan table name: %w", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        // Drop all tables
        <span class="cov0" title="0">for _, table := range tables </span><span class="cov0" title="0">{
                if _, err := d.db.Exec(fmt.Sprintf(`DROP TABLE IF EXISTS "%s"`, table)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to drop table %s: %w", table, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *SQLiteDatabase) GetType() DatabaseType <span class="cov0" title="0">{
        return DatabaseTypeSQLite
}</span>

// ensureTable creates the table if it doesn't exist
func (s *SQLiteStore) ensureTable() error <span class="cov5" title="3">{
        quotedTable := s.quotedTableName()
        createSQL := fmt.Sprintf(`
                CREATE TABLE IF NOT EXISTS %s (
                        id TEXT PRIMARY KEY,
                        data JSON NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
        `, quotedTable)

        if _, err := s.db.Exec(createSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create table %s: %w", s.tableName, err)
        }</span>

        // Create indexes for common queries
        <span class="cov5" title="3">indexSQL := fmt.Sprintf(`
                CREATE INDEX IF NOT EXISTS "idx_%s_id" ON %s(id);
                CREATE INDEX IF NOT EXISTS "idx_%s_created_at" ON %s(created_at);
                CREATE INDEX IF NOT EXISTS "idx_%s_updated_at" ON %s(updated_at);
        `, s.tableName, quotedTable, s.tableName, quotedTable, s.tableName, quotedTable)

        if _, err := s.db.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create indexes for table %s: %w", s.tableName, err)
        }</span>

        <span class="cov5" title="3">return nil</span>
}

func (s *SQLiteStore) CreateUniqueIdentifier() string <span class="cov8" title="7">{
        return generateUniqueID()
}</span>

func (s *SQLiteStore) Insert(ctx context.Context, document interface{}) (interface{}, error) <span class="cov8" title="6">{
        doc, ok := document.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document must be a map[string]interface{}")
        }</span>

        // Ensure the document has an ID
        <span class="cov8" title="6">if _, exists := doc["id"]; !exists </span><span class="cov8" title="6">{
                doc["id"] = s.CreateUniqueIdentifier()
        }</span>

        // Add timestamps
        <span class="cov8" title="6">now := time.Now()
        if _, exists := doc["createdAt"]; !exists </span><span class="cov8" title="6">{
                doc["createdAt"] = now
        }</span>
        <span class="cov8" title="6">if _, exists := doc["updatedAt"]; !exists </span><span class="cov8" title="6">{
                doc["updatedAt"] = now
        }</span>

        // Serialize to JSON
        <span class="cov8" title="6">jsonData, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal document: %w", err)
        }</span>

        <span class="cov8" title="6">insertSQL := fmt.Sprintf("INSERT INTO %s (id, data, created_at, updated_at) VALUES (?, ?, ?, ?)", s.quotedTableName())
        _, err = s.db.ExecContext(ctx, insertSQL, doc["id"], string(jsonData), now, now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to insert document: %w", err)
        }</span>

        <span class="cov8" title="6">return doc, nil</span>
}

func (s *SQLiteStore) Find(ctx context.Context, query QueryBuilder, opts QueryOptions) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        baseSQL := fmt.Sprintf("SELECT data FROM %s", s.quotedTableName())
        var args []interface{}

        // Build WHERE clause
        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                baseSQL += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        // Add ORDER BY
        <span class="cov0" title="0">if len(opts.Sort) &gt; 0 </span><span class="cov0" title="0">{
                var orderParts []string
                for field, direction := range opts.Sort </span><span class="cov0" title="0">{
                        dir := "ASC"
                        if direction == -1 </span><span class="cov0" title="0">{
                                dir = "DESC"
                        }</span>
                        <span class="cov0" title="0">orderParts = append(orderParts, fmt.Sprintf("JSON_EXTRACT(data, '$.%s') %s", field, dir))</span>
                }
                <span class="cov0" title="0">baseSQL += " ORDER BY " + strings.Join(orderParts, ", ")</span>
        }

        // Add LIMIT and OFFSET
        <span class="cov0" title="0">if opts.Limit != nil </span><span class="cov0" title="0">{
                baseSQL += fmt.Sprintf(" LIMIT %d", *opts.Limit)
        }</span>
        <span class="cov0" title="0">if opts.Skip != nil </span><span class="cov0" title="0">{
                baseSQL += fmt.Sprintf(" OFFSET %d", *opts.Skip)
        }</span>

        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, baseSQL, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                var jsonData string
                if err := rows.Scan(&amp;jsonData); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                <span class="cov0" title="0">var doc map[string]interface{}
                if err := json.Unmarshal([]byte(jsonData), &amp;doc); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal document: %w", err)
                }</span>

                // Apply field projection if specified
                <span class="cov0" title="0">if len(opts.Fields) &gt; 0 </span><span class="cov0" title="0">{
                        doc = s.applyFieldProjection(doc, opts.Fields)
                }</span>

                <span class="cov0" title="0">results = append(results, doc)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (s *SQLiteStore) FindOne(ctx context.Context, query QueryBuilder) (map[string]interface{}, error) <span class="cov0" title="0">{
        opts := QueryOptions{Limit: &amp;[]int64{1}[0]}
        results, err := s.Find(ctx, query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return results[0], nil</span>
}

func (s *SQLiteStore) Update(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        return s.performUpdate(ctx, query, update, false)
}</span>

func (s *SQLiteStore) UpdateOne(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        return s.performUpdate(ctx, query, update, true)
}</span>

func (s *SQLiteStore) performUpdate(ctx context.Context, query QueryBuilder, update UpdateBuilder, updateOne bool) (UpdateResult, error) <span class="cov0" title="0">{
        // First, find the documents to update
        existingDocs, err := s.Find(ctx, query, QueryOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find documents to update: %w", err)
        }</span>

        <span class="cov0" title="0">if len(existingDocs) == 0 </span><span class="cov0" title="0">{
                return &amp;SQLiteUpdateResult{modifiedCount: 0}, nil
        }</span>

        // If updateOne is true, only update the first document
        <span class="cov0" title="0">if updateOne &amp;&amp; len(existingDocs) &gt; 1 </span><span class="cov0" title="0">{
                existingDocs = existingDocs[:1]
        }</span>

        <span class="cov0" title="0">updateMap := update.ToMap()
        modifiedCount := int64(0)

        for _, doc := range existingDocs </span><span class="cov0" title="0">{
                originalDoc := make(map[string]interface{})
                for k, v := range doc </span><span class="cov0" title="0">{
                        originalDoc[k] = v
                }</span>

                // Apply update operations
                <span class="cov0" title="0">s.applyUpdateOperations(doc, updateMap)

                // Update timestamp
                doc["updatedAt"] = time.Now()

                // Check if document actually changed
                if !s.documentsEqual(originalDoc, doc) </span><span class="cov0" title="0">{
                        // Serialize and update in database
                        jsonData, err := json.Marshal(doc)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal updated document: %w", err)
                        }</span>

                        <span class="cov0" title="0">updateSQL := fmt.Sprintf("UPDATE %s SET data = ?, updated_at = ? WHERE id = ?", s.quotedTableName())
                        _, err = s.db.ExecContext(ctx, updateSQL, string(jsonData), doc["updatedAt"], doc["id"])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update document: %w", err)
                        }</span>

                        <span class="cov0" title="0">modifiedCount++</span>
                }
        }

        <span class="cov0" title="0">return &amp;SQLiteUpdateResult{modifiedCount: modifiedCount}, nil</span>
}

func (s *SQLiteStore) Remove(ctx context.Context, query QueryBuilder) (DeleteResult, error) <span class="cov0" title="0">{
        // First count how many will be deleted
        count, err := s.Count(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count documents to delete: %w", err)
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return &amp;SQLiteDeleteResult{deletedCount: 0}, nil
        }</span>

        // Build DELETE query
        <span class="cov0" title="0">deleteSQL := fmt.Sprintf("DELETE FROM %s", s.quotedTableName())
        var args []interface{}

        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                deleteSQL += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, deleteSQL, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete documents: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SQLiteDeleteResult{deletedCount: count}, nil</span>
}

func (s *SQLiteStore) Count(ctx context.Context, query QueryBuilder) (int64, error) <span class="cov1" title="1">{
        countSQL := fmt.Sprintf("SELECT COUNT(*) FROM %s", s.quotedTableName())
        var args []interface{}

        whereClause, whereArgs := s.buildWhereClause(query)
        if whereClause != "" </span><span class="cov0" title="0">{
                countSQL += " WHERE " + whereClause
                args = append(args, whereArgs...)
        }</span>

        <span class="cov1" title="1">var count int64
        err := s.db.QueryRowContext(ctx, countSQL, args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count documents: %w", err)
        }</span>

        <span class="cov1" title="1">return count, nil</span>
}

// Specialized MongoDB-style operations (simplified implementations for SQLite)
func (s *SQLiteStore) Increment(ctx context.Context, query QueryBuilder, increments map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range increments </span><span class="cov0" title="0">{
                update.Inc(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *SQLiteStore) Push(ctx context.Context, query QueryBuilder, pushOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range pushOps </span><span class="cov0" title="0">{
                update.Push(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *SQLiteStore) Pull(ctx context.Context, query QueryBuilder, pullOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range pullOps </span><span class="cov0" title="0">{
                update.Pull(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *SQLiteStore) AddToSet(ctx context.Context, query QueryBuilder, addOps map[string]interface{}) (UpdateResult, error) <span class="cov0" title="0">{
        update := NewUpdateBuilder()
        for field, value := range addOps </span><span class="cov0" title="0">{
                update.AddToSet(field, value)
        }</span>
        <span class="cov0" title="0">return s.Update(ctx, query, update)</span>
}

func (s *SQLiteStore) PopFirst(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        // For SQLite, we'll implement this by updating arrays manually
        return &amp;SQLiteUpdateResult{modifiedCount: 0}, fmt.Errorf("PopFirst not yet implemented for SQLite")
}</span>

func (s *SQLiteStore) PopLast(ctx context.Context, query QueryBuilder, fields []string) (UpdateResult, error) <span class="cov0" title="0">{
        // For SQLite, we'll implement this by updating arrays manually
        return &amp;SQLiteUpdateResult{modifiedCount: 0}, fmt.Errorf("PopLast not yet implemented for SQLite")
}</span>

func (s *SQLiteStore) Upsert(ctx context.Context, query QueryBuilder, update UpdateBuilder) (UpdateResult, error) <span class="cov0" title="0">{
        // Try update first
        result, err := s.Update(ctx, query, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount() &gt; 0 </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // If no documents were updated, create a new one
        <span class="cov0" title="0">updateMap := update.ToMap()
        queryMap := query.ToMap()

        // Merge query and update into a new document
        newDoc := make(map[string]interface{})
        
        // Add query fields
        for field, value := range queryMap </span><span class="cov0" title="0">{
                if !strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        newDoc[field] = value
                }</span>
        }

        // Apply update operations to create the document
        <span class="cov0" title="0">s.applyUpdateOperations(newDoc, updateMap)

        // Insert the new document
        _, err = s.Insert(ctx, newDoc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upsert document: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SQLiteUpdateResult{
                modifiedCount: 0,
                upsertedCount: 1,
                upsertedID:    newDoc["id"],
        }, nil</span>
}

func (s *SQLiteStore) Aggregate(ctx context.Context, pipeline []map[string]interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Basic aggregation support - this is a simplified implementation
        // For now, just return all documents
        query := NewQueryBuilder()
        return s.Find(ctx, query, QueryOptions{})
}</span>

// Helper methods

func (s *SQLiteStore) quotedTableName() string <span class="cov10" title="10">{
        // Quote table names to handle special characters like hyphens
        return fmt.Sprintf(`"%s"`, s.tableName)
}</span>

func (s *SQLiteStore) buildWhereClause(query QueryBuilder) (string, []interface{}) <span class="cov1" title="1">{
        if sqlQuery, ok := query.(*SQLQueryBuilder); ok </span><span class="cov0" title="0">{
                return sqlQuery.ToSQL()
        }</span>

        // Convert from map-based query
        <span class="cov1" title="1">queryMap := query.ToMap()
        if len(queryMap) == 0 </span><span class="cov1" title="1">{
                return "", nil
        }</span>

        <span class="cov0" title="0">sqlBuilder := NewSQLQueryBuilder()
        s.convertMapToSQLQuery(queryMap, sqlBuilder)
        return sqlBuilder.ToSQL()</span>
}

func (s *SQLiteStore) convertMapToSQLQuery(queryMap map[string]interface{}, builder *SQLQueryBuilder) <span class="cov0" title="0">{
        for field, value := range queryMap </span><span class="cov0" title="0">{
                if field == "$or" </span><span class="cov0" title="0">{
                        // Handle OR conditions
                        if orConditions, ok := value.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                                var orBuilders []QueryBuilder
                                for _, orCond := range orConditions </span><span class="cov0" title="0">{
                                        orBuilder := NewSQLQueryBuilder()
                                        s.convertMapToSQLQuery(orCond, orBuilder)
                                        orBuilders = append(orBuilders, orBuilder)
                                }</span>
                                <span class="cov0" title="0">builder.Or(orBuilders...)</span>
                        }
                } else<span class="cov0" title="0"> if strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        // Skip other MongoDB operators at root level
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // Regular field condition
                        if valueMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                // Field has operators
                                for op, opValue := range valueMap </span><span class="cov0" title="0">{
                                        builder.Where(field, op, opValue)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Simple equality
                                builder.Where(field, "$eq", value)
                        }</span>
                }
        }
}

func (s *SQLiteStore) applyFieldProjection(doc map[string]interface{}, fields map[string]int) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})

        // Check if this is inclusion or exclusion
        hasInclusions := false
        for _, include := range fields </span><span class="cov0" title="0">{
                if include == 1 </span><span class="cov0" title="0">{
                        hasInclusions = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if hasInclusions </span><span class="cov0" title="0">{
                // Inclusion mode: only include specified fields
                for field, include := range fields </span><span class="cov0" title="0">{
                        if include == 1 </span><span class="cov0" title="0">{
                                if value, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                        result[field] = value
                                }</span>
                        }
                }
                // Always include id
                <span class="cov0" title="0">if _, hasID := fields["id"]; !hasID </span><span class="cov0" title="0">{
                        if id, exists := doc["id"]; exists </span><span class="cov0" title="0">{
                                result["id"] = id
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Exclusion mode: include all except specified fields
                for field, value := range doc </span><span class="cov0" title="0">{
                        if exclude, exists := fields[field]; !exists || exclude != 0 </span><span class="cov0" title="0">{
                                result[field] = value
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func (s *SQLiteStore) applyUpdateOperations(doc map[string]interface{}, updateMap map[string]interface{}) <span class="cov0" title="0">{
        for operation, fields := range updateMap </span><span class="cov0" title="0">{
                if fieldMap, ok := fields.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        switch operation </span>{
                        case "$set":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        doc[field] = value
                                }</span>
                        case "$unset":<span class="cov0" title="0">
                                for field := range fieldMap </span><span class="cov0" title="0">{
                                        delete(doc, field)
                                }</span>
                        case "$inc":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingNum, ok := s.toFloat64(existing); ok </span><span class="cov0" title="0">{
                                                        if incNum, ok := s.toFloat64(value); ok </span><span class="cov0" title="0">{
                                                                doc[field] = existingNum + incNum
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = value
                                        }</span>
                                }
                        case "$push":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        doc[field] = append(existingArray, value)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{value}
                                        }</span>
                                }
                        case "$pull":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        var newArray []interface{}
                                                        for _, item := range existingArray </span><span class="cov0" title="0">{
                                                                if !s.valuesEqual(item, value) </span><span class="cov0" title="0">{
                                                                        newArray = append(newArray, item)
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">doc[field] = newArray</span>
                                                }
                                        }
                                }
                        case "$addToSet":<span class="cov0" title="0">
                                for field, value := range fieldMap </span><span class="cov0" title="0">{
                                        if existing, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if existingArray, ok := existing.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        // Check if value already exists
                                                        exists := false
                                                        for _, item := range existingArray </span><span class="cov0" title="0">{
                                                                if s.valuesEqual(item, value) </span><span class="cov0" title="0">{
                                                                        exists = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                                                doc[field] = append(existingArray, value)
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{value}
                                        }</span>
                                }
                        }
                }
        }
}

func (s *SQLiteStore) toFloat64(value interface{}) (float64, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, true</span>
        case float32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int:<span class="cov0" title="0">
                return float64(v), true</span>
        case int32:<span class="cov0" title="0">
                return float64(v), true</span>
        case int64:<span class="cov0" title="0">
                return float64(v), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

func (s *SQLiteStore) valuesEqual(a, b interface{}) bool <span class="cov0" title="0">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

func (s *SQLiteStore) documentsEqual(a, b map[string]interface{}) bool <span class="cov0" title="0">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

// Register SQLite database factory
func init() <span class="cov1" title="1">{
        RegisterDatabaseFactory(DatabaseTypeSQLite, NewSQLiteDatabase)
}</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type Store struct {
        namespace  string
        collection *mongo.Collection
        db         *Database
}

func (s *Store) CreateUniqueIdentifier() string <span class="cov0" title="0">{
        bytes := make([]byte, 12)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

func (s *Store) Insert(ctx context.Context, document interface{}) (interface{}, error) <span class="cov0" title="0">{
        if doc, ok := document.(bson.M); ok </span><span class="cov0" title="0">{
                if _, exists := doc["id"]; !exists </span><span class="cov0" title="0">{
                        doc["id"] = s.CreateUniqueIdentifier()
                }</span>
                // Convert id to _id for MongoDB
                <span class="cov0" title="0">if id, exists := doc["id"]; exists </span><span class="cov0" title="0">{
                        doc["_id"] = id
                        delete(doc, "id")
                }</span>
        } else<span class="cov0" title="0"> if doc, ok := document.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                bsonDoc := bson.M(doc)
                if _, exists := bsonDoc["id"]; !exists </span><span class="cov0" title="0">{
                        bsonDoc["id"] = s.CreateUniqueIdentifier()
                }</span>
                // Convert id to _id for MongoDB
                <span class="cov0" title="0">if id, exists := bsonDoc["id"]; exists </span><span class="cov0" title="0">{
                        bsonDoc["_id"] = id
                        delete(bsonDoc, "id")
                }</span>
                <span class="cov0" title="0">document = bsonDoc</span>
        }

        <span class="cov0" title="0">result, err := s.collection.InsertOne(ctx, document)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to insert document: %w", err)
        }</span>

        // Get the inserted document to return it with the id field
        <span class="cov0" title="0">var inserted bson.M
        err = s.collection.FindOne(ctx, bson.M{"_id": result.InsertedID}).Decode(&amp;inserted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retrieve inserted document: %w", err)
        }</span>

        <span class="cov0" title="0">s.convertID(&amp;inserted)
        return inserted, nil</span>
}

func (s *Store) Find(ctx context.Context, query bson.M, opts ...*options.FindOptions) ([]bson.M, error) <span class="cov0" title="0">{
        s.scrubQuery(query)

        cursor, err := s.collection.Find(ctx, query, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var results []bson.M
        if err := cursor.All(ctx, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode documents: %w", err)
        }</span>

        // Convert _id back to id for all documents
        <span class="cov0" title="0">for i := range results </span><span class="cov0" title="0">{
                s.convertID(&amp;results[i])
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (s *Store) FindOne(ctx context.Context, query bson.M) (bson.M, error) <span class="cov0" title="0">{
        s.scrubQuery(query)

        var result bson.M
        err := s.collection.FindOne(ctx, query).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to find document: %w", err)</span>
        }

        <span class="cov0" title="0">s.convertID(&amp;result)
        return result, nil</span>
}

func (s *Store) Update(ctx context.Context, query bson.M, update bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        s.scrubQuery(query)
        s.scrubUpdateOperations(update)

        result, err := s.collection.UpdateMany(ctx, query, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update documents: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// UpdateOne updates a single document
func (s *Store) UpdateOne(ctx context.Context, query bson.M, update bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        s.scrubQuery(query)
        s.scrubUpdateOperations(update)

        result, err := s.collection.UpdateOne(ctx, query, update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update document: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Increment atomically increments numeric fields
func (s *Store) Increment(ctx context.Context, query bson.M, increments bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        update := bson.M{"$inc": increments}
        return s.Update(ctx, query, update)
}</span>

// Push adds items to arrays
func (s *Store) Push(ctx context.Context, query bson.M, pushOps bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        update := bson.M{"$push": pushOps}
        return s.Update(ctx, query, update)
}</span>

// Pull removes items from arrays
func (s *Store) Pull(ctx context.Context, query bson.M, pullOps bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        update := bson.M{"$pull": pullOps}
        return s.Update(ctx, query, update)
}</span>

// AddToSet adds unique items to arrays (like $addUnique in original Deployd)
func (s *Store) AddToSet(ctx context.Context, query bson.M, addOps bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        update := bson.M{"$addToSet": addOps}
        return s.Update(ctx, query, update)
}</span>

// PopFirst removes the first item from arrays
func (s *Store) PopFirst(ctx context.Context, query bson.M, fields []string) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        popOps := bson.M{}
        for _, field := range fields </span><span class="cov0" title="0">{
                popOps[field] = -1
        }</span>
        <span class="cov0" title="0">update := bson.M{"$pop": popOps}
        return s.Update(ctx, query, update)</span>
}

// PopLast removes the last item from arrays  
func (s *Store) PopLast(ctx context.Context, query bson.M, fields []string) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        popOps := bson.M{}
        for _, field := range fields </span><span class="cov0" title="0">{
                popOps[field] = 1
        }</span>
        <span class="cov0" title="0">update := bson.M{"$pop": popOps}
        return s.Update(ctx, query, update)</span>
}

// Upsert performs an update with upsert option
func (s *Store) Upsert(ctx context.Context, query bson.M, update bson.M) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        s.scrubQuery(query)
        s.scrubUpdateOperations(update)

        opts := options.Update().SetUpsert(true)
        result, err := s.collection.UpdateOne(ctx, query, update, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upsert document: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// scrubUpdateOperations handles id/field conversion in update operations
func (s *Store) scrubUpdateOperations(update bson.M) <span class="cov0" title="0">{
        for op, value := range update </span><span class="cov0" title="0">{
                switch op </span>{
                case "$set", "$unset", "$inc", "$push", "$pull", "$addToSet", "$pop", "$rename":<span class="cov0" title="0">
                        if opDoc, ok := value.(bson.M); ok </span><span class="cov0" title="0">{
                                s.scrubIDFields(opDoc)
                        }</span>
                case "$pushAll", "$pullAll":<span class="cov0" title="0">
                        if opDoc, ok := value.(bson.M); ok </span><span class="cov0" title="0">{
                                s.scrubIDFields(opDoc)
                        }</span>
                }
        }
}

// scrubIDFields converts id fields to _id in operation documents
func (s *Store) scrubIDFields(doc bson.M) <span class="cov0" title="0">{
        if _, hasID := doc["id"]; hasID </span><span class="cov0" title="0">{
                doc["_id"] = doc["id"]
                delete(doc, "id")
        }</span>
}

func (s *Store) Remove(ctx context.Context, query bson.M) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        s.scrubQuery(query)

        result, err := s.collection.DeleteMany(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete documents: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (s *Store) Count(ctx context.Context, query bson.M) (int64, error) <span class="cov0" title="0">{
        s.scrubQuery(query)

        count, err := s.collection.CountDocuments(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count documents: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

func (s *Store) Rename(ctx context.Context, newName string) error <span class="cov0" title="0">{
        // MongoDB doesn't have a direct rename collection method in the driver
        // This would need to be implemented using aggregation pipeline
        return fmt.Errorf("rename not yet implemented")
}</span>

// scrubQuery converts "id" fields to "_id" for MongoDB compatibility
func (s *Store) scrubQuery(query bson.M) <span class="cov0" title="0">{
        if query == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if id, exists := query["id"]; exists </span><span class="cov0" title="0">{
                // Try to convert string ID to ObjectId first, fallback to string
                if idStr, ok := id.(string); ok &amp;&amp; len(idStr) == 24 </span><span class="cov0" title="0">{
                        if objId, err := primitive.ObjectIDFromHex(idStr); err == nil </span><span class="cov0" title="0">{
                                // Query for both ObjectID and string versions to handle mixed storage
                                query["_id"] = bson.M{"$in": []interface{}{objId, idStr}}
                        }</span> else<span class="cov0" title="0"> {
                                // If conversion fails, use as string (for custom IDs)
                                query["_id"] = id
                        }</span>
                } else<span class="cov0" title="0"> {
                        query["_id"] = id
                }</span>
                <span class="cov0" title="0">delete(query, "id")</span>
        }

        // Handle nested queries (like $in, $or, etc.)
        <span class="cov0" title="0">for _, value := range query </span><span class="cov0" title="0">{
                switch v := value.(type) </span>{
                case bson.M:<span class="cov0" title="0">
                        s.scrubQuery(v)</span>
                case []interface{}:<span class="cov0" title="0">
                        for _, item := range v </span><span class="cov0" title="0">{
                                if itemDoc, ok := item.(bson.M); ok </span><span class="cov0" title="0">{
                                        s.scrubQuery(itemDoc)
                                }</span>
                        }
                }
        }
}

// convertID converts MongoDB's "_id" field back to "id" for API compatibility
func (s *Store) convertID(doc *bson.M) <span class="cov0" title="0">{
        if doc == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if id, exists := (*doc)["_id"]; exists </span><span class="cov0" title="0">{
                (*doc)["id"] = id
                delete(*doc, "_id")
        }</span>
}

// Aggregate performs aggregation operations
func (s *Store) Aggregate(ctx context.Context, pipeline []bson.M) ([]bson.M, error) <span class="cov0" title="0">{
        cursor, err := s.collection.Aggregate(ctx, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to aggregate: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var results []bson.M
        if err := cursor.All(ctx, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode aggregation results: %w", err)
        }</span>

        // Convert _id back to id for all documents
        <span class="cov0" title="0">for i := range results </span><span class="cov0" title="0">{
                s.convertID(&amp;results[i])
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package database

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"
)

// generateUniqueID creates a unique identifier similar to MongoDB ObjectIDs
func generateUniqueID() string <span class="cov10" title="107">{
        // Create a 12-byte ID similar to MongoDB ObjectID
        // 4 bytes timestamp + 8 bytes random
        timestamp := uint32(time.Now().Unix())
        randomBytes := make([]byte, 8)
        rand.Read(randomBytes)
        
        id := make([]byte, 12)
        id[0] = byte(timestamp &gt;&gt; 24)
        id[1] = byte(timestamp &gt;&gt; 16)
        id[2] = byte(timestamp &gt;&gt; 8)
        id[3] = byte(timestamp)
        copy(id[4:], randomBytes)
        
        return hex.EncodeToString(id)
}</span>

// ExtendedConfig provides additional configuration options for different database types
type ExtendedConfig struct {
        *Config
        Type     DatabaseType          `json:"type"`
        Options  map[string]interface{} `json:"options"`
        FilePath string                `json:"file_path,omitempty"` // For SQLite
}

// NewExtendedConfig creates a new extended configuration with defaults
func NewExtendedConfig() *ExtendedConfig <span class="cov0" title="0">{
        return &amp;ExtendedConfig{
                Config: &amp;Config{
                        Host: "localhost",
                        Port: 27017,
                        Name: "deployd",
                },
                Type:    DatabaseTypeMongoDB, // Default to MongoDB
                Options: make(map[string]interface{}),
        }
}</span>

// Validate validates the configuration
func (c *ExtendedConfig) Validate() error <span class="cov0" title="0">{
        if c.Config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("base config is required")
        }</span>
        
        <span class="cov0" title="0">if c.Config.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database name is required")
        }</span>
        
        <span class="cov0" title="0">switch c.Type </span>{
        case DatabaseTypeMongoDB:<span class="cov0" title="0">
                if c.Config.Host == "" </span><span class="cov0" title="0">{
                        c.Config.Host = "localhost"
                }</span>
                <span class="cov0" title="0">if c.Config.Port == 0 </span><span class="cov0" title="0">{
                        c.Config.Port = 27017
                }</span>
        case DatabaseTypeSQLite:<span class="cov0" title="0">
                // For SQLite, we can use the Host field as the file path
                if c.Config.Host == "" </span><span class="cov0" title="0">{
                        c.Config.Host = fmt.Sprintf("data/%s.db", c.Config.Name)
                }</span>
        case DatabaseTypeMySQL:<span class="cov0" title="0">
                if c.Config.Host == "" </span><span class="cov0" title="0">{
                        c.Config.Host = "localhost"
                }</span>
                <span class="cov0" title="0">if c.Config.Port == 0 </span><span class="cov0" title="0">{
                        c.Config.Port = 3306
                }</span>
        case DatabaseTypePostgres:<span class="cov0" title="0">
                if c.Config.Host == "" </span><span class="cov0" title="0">{
                        c.Config.Host = "localhost"
                }</span>
                <span class="cov0" title="0">if c.Config.Port == 0 </span><span class="cov0" title="0">{
                        c.Config.Port = 5432
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", c.Type)</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// ToBasicConfig converts ExtendedConfig to basic Config for backwards compatibility
func (c *ExtendedConfig) ToBasicConfig() *Config <span class="cov0" title="0">{
        return c.Config
}</pre>
		
		<pre class="file" id="file16" style="display: none">package email

import (
        "crypto/rand"
        "crypto/tls"
        "encoding/hex"
        "fmt"
        "net/smtp"
        "time"

        // "github.com/aws/aws-sdk-go/aws"
        // "github.com/aws/aws-sdk-go/aws/credentials"
        // "github.com/aws/aws-sdk-go/aws/session"
        // "github.com/aws/aws-sdk-go/service/ses"
        "github.com/hjanuschka/go-deployd/internal/config"
)

// EmailService handles email sending via SMTP or SES
type EmailService struct {
        config *config.EmailConfig
}

// NewEmailService creates a new email service
func NewEmailService(emailConfig *config.EmailConfig) *EmailService <span class="cov0" title="0">{
        return &amp;EmailService{
                config: emailConfig,
        }
}</span>

// SendVerificationEmail sends an email verification message
func (e *EmailService) SendVerificationEmail(to, username, verificationToken, baseURL string) error <span class="cov0" title="0">{
        verificationURL := fmt.Sprintf("%s/_dashboard/verify?token=%s", baseURL, verificationToken)
        
        subject := "Verify your email address"
        htmlBody := fmt.Sprintf(`
                &lt;html&gt;
                &lt;body&gt;
                        &lt;h2&gt;Welcome to Go-Deployd!&lt;/h2&gt;
                        &lt;p&gt;Hi %s,&lt;/p&gt;
                        &lt;p&gt;Please verify your email address by clicking the link below:&lt;/p&gt;
                        &lt;p&gt;&lt;a href="%s" style="background-color: #4CAF50; color: white; padding: 14px 25px; text-decoration: none; display: inline-block;"&gt;Verify Email&lt;/a&gt;&lt;/p&gt;
                        &lt;p&gt;Or copy and paste this URL into your browser:&lt;/p&gt;
                        &lt;p&gt;%s&lt;/p&gt;
                        &lt;p&gt;This link will expire in 24 hours.&lt;/p&gt;
                        &lt;p&gt;If you didn't create an account, please ignore this email.&lt;/p&gt;
                        &lt;br&gt;
                        &lt;p&gt;Best regards,&lt;br&gt;Go-Deployd Team&lt;/p&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `, username, verificationURL, verificationURL)
        
        textBody := fmt.Sprintf(`
Welcome to Go-Deployd!

Hi %s,

Please verify your email address by visiting this URL:
%s

This link will expire in 24 hours.

If you didn't create an account, please ignore this email.

Best regards,
Go-Deployd Team
        `, username, verificationURL)
        
        return e.SendEmail(to, subject, textBody, htmlBody)
}</span>

// SendEmail sends an email using the configured provider
func (e *EmailService) SendEmail(to, subject, textBody, htmlBody string) error <span class="cov0" title="0">{
        switch e.config.Provider </span>{
        case "ses":<span class="cov0" title="0">
                return e.sendViaSES(to, subject, textBody, htmlBody)</span>
        case "smtp":<span class="cov0" title="0">
                return e.sendViaSMTP(to, subject, textBody, htmlBody)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported email provider: %s", e.config.Provider)</span>
        }
}

// sendViaSMTP sends email via SMTP
func (e *EmailService) sendViaSMTP(to, subject, textBody, htmlBody string) error <span class="cov0" title="0">{
        if e.config.SMTP.Username == "" || e.config.SMTP.Password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SMTP credentials not configured")
        }</span>
        
        <span class="cov0" title="0">auth := smtp.PlainAuth("", e.config.SMTP.Username, e.config.SMTP.Password, e.config.SMTP.Host)
        
        // Prepare message
        headers := fmt.Sprintf("From: %s &lt;%s&gt;\r\n", e.config.FromName, e.config.From)
        headers += fmt.Sprintf("To: %s\r\n", to)
        headers += fmt.Sprintf("Subject: %s\r\n", subject)
        headers += "MIME-Version: 1.0\r\n"
        headers += "Content-Type: multipart/alternative; boundary=boundary\r\n\r\n"
        
        body := "--boundary\r\n"
        body += "Content-Type: text/plain; charset=UTF-8\r\n\r\n"
        body += textBody + "\r\n\r\n"
        body += "--boundary\r\n"
        body += "Content-Type: text/html; charset=UTF-8\r\n\r\n"
        body += htmlBody + "\r\n\r\n"
        body += "--boundary--\r\n"
        
        message := headers + body
        
        serverAddr := fmt.Sprintf("%s:%d", e.config.SMTP.Host, e.config.SMTP.Port)
        
        if e.config.SMTP.TLS </span><span class="cov0" title="0">{
                // Use TLS connection
                tlsConfig := &amp;tls.Config{
                        ServerName: e.config.SMTP.Host,
                }
                
                conn, err := tls.Dial("tcp", serverAddr, tlsConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to connect to SMTP server with TLS: %w", err)
                }</span>
                <span class="cov0" title="0">defer conn.Close()
                
                client, err := smtp.NewClient(conn, e.config.SMTP.Host)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create SMTP client: %w", err)
                }</span>
                <span class="cov0" title="0">defer client.Close()
                
                if err := client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("SMTP authentication failed: %w", err)
                }</span>
                
                <span class="cov0" title="0">if err := client.Mail(e.config.From); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set sender: %w", err)
                }</span>
                
                <span class="cov0" title="0">if err := client.Rcpt(to); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set recipient: %w", err)
                }</span>
                
                <span class="cov0" title="0">writer, err := client.Data()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start data transfer: %w", err)
                }</span>
                
                <span class="cov0" title="0">_, err = writer.Write([]byte(message))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write message: %w", err)
                }</span>
                
                <span class="cov0" title="0">return writer.Close()</span>
        } else<span class="cov0" title="0"> {
                // Use plain SMTP
                return smtp.SendMail(serverAddr, auth, e.config.From, []string{to}, []byte(message))
        }</span>
}

// sendViaSES sends email via AWS SES
func (e *EmailService) sendViaSES(to, subject, textBody, htmlBody string) error <span class="cov0" title="0">{
        // TODO: Implement SES after installing AWS SDK
        return fmt.Errorf("SES support temporarily disabled - please use SMTP provider")
        
        /*
        if e.config.SES.AccessKeyID == "" || e.config.SES.SecretAccessKey == "" {
                return fmt.Errorf("AWS SES credentials not configured")
        }
        
        sess, err := session.NewSession(&amp;aws.Config{
                Region: aws.String(e.config.SES.Region),
                Credentials: credentials.NewStaticCredentials(
                        e.config.SES.AccessKeyID,
                        e.config.SES.SecretAccessKey,
                        "",
                ),
        })
        if err != nil {
                return fmt.Errorf("failed to create AWS session: %w", err)
        }
        
        svc := ses.New(sess)
        
        input := &amp;ses.SendEmailInput{
                Destination: &amp;ses.Destination{
                        ToAddresses: []*string{aws.String(to)},
                },
                Message: &amp;ses.Message{
                        Body: &amp;ses.Body{
                                Html: &amp;ses.Content{
                                        Charset: aws.String("UTF-8"),
                                        Data:    aws.String(htmlBody),
                                },
                                Text: &amp;ses.Content{
                                        Charset: aws.String("UTF-8"),
                                        Data:    aws.String(textBody),
                                },
                        },
                        Subject: &amp;ses.Content{
                                Charset: aws.String("UTF-8"),
                                Data:    aws.String(subject),
                        },
                },
                Source: aws.String(fmt.Sprintf("%s &lt;%s&gt;", e.config.FromName, e.config.From)),
        }
        
        _, err = svc.SendEmail(input)
        if err != nil {
                return fmt.Errorf("failed to send email via SES: %w", err)
        }
        
        return nil
        */
}</span>

// TestEmail sends a test email to verify configuration
func (e *EmailService) TestEmail(to string) error <span class="cov0" title="0">{
        subject := "Go-Deployd Email Configuration Test"
        textBody := "This is a test email from Go-Deployd to verify your email configuration is working correctly."
        htmlBody := `
                &lt;html&gt;
                &lt;body&gt;
                        &lt;h2&gt;Go-Deployd Email Test&lt;/h2&gt;
                        &lt;p&gt;This is a test email to verify your email configuration is working correctly.&lt;/p&gt;
                        &lt;p&gt;If you received this email, your email settings are properly configured!&lt;/p&gt;
                        &lt;p&gt;Provider: ` + e.config.Provider + `&lt;/p&gt;
                        &lt;p&gt;Sent at: ` + time.Now().Format(time.RFC3339) + `&lt;/p&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `
        
        return e.SendEmail(to, subject, textBody, htmlBody)
}</span>

// GenerateVerificationToken generates a secure random token for email verification
func GenerateVerificationToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate verification token: %w", err)
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// IsConfigured checks if email service is properly configured
func (e *EmailService) IsConfigured() bool <span class="cov0" title="0">{
        switch e.config.Provider </span>{
        case "smtp":<span class="cov0" title="0">
                return e.config.SMTP.Host != "" &amp;&amp; e.config.SMTP.Username != "" &amp;&amp; e.config.SMTP.Password != ""</span>
        case "ses":<span class="cov0" title="0">
                return e.config.SES.AccessKeyID != "" &amp;&amp; e.config.SES.SecretAccessKey != "" &amp;&amp; e.config.SES.Region != ""</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}</pre>
		
		<pre class="file" id="file17" style="display: none">package events

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "plugin"
        "reflect"
        "runtime"
        "strings"
        "time"

        "github.com/dop251/goja"
        "github.com/hjanuschka/go-deployd/internal/context"
        "github.com/hjanuschka/go-deployd/internal/logging"
)

// EventContext provides context for event scripts (mirrored from plugin)
type EventContext struct {
        Ctx        *context.Context // For compatibility with existing code
        Data       map[string]interface{}
        Query      map[string]interface{}
        Me         map[string]interface{}
        Previous   map[string]interface{} // For PUT requests
        IsRoot     bool
        Internal   bool
        Errors     map[string]string
        Cancel     func(message string, statusCode int)
        Log        func(message string, data ...map[string]interface{})
        Resource   interface{ GetName() string }
        hideFields []string
}

func (ctx *EventContext) HasErrors() bool <span class="cov0" title="0">{
        return len(ctx.Errors) &gt; 0
}</span>

func (ctx *EventContext) GetHiddenFields() []string <span class="cov0" title="0">{
        return ctx.hideFields
}</span>

func (ctx *EventContext) Error(field, message string) <span class="cov0" title="0">{
        if ctx.Errors == nil </span><span class="cov0" title="0">{
                ctx.Errors = make(map[string]string)
        }</span>
        <span class="cov0" title="0">ctx.Errors[field] = message</span>
}

func (ctx *EventContext) Hide(field string) <span class="cov0" title="0">{
        ctx.hideFields = append(ctx.hideFields, field)
        delete(ctx.Data, field)
}</span>

func (ctx *EventContext) Protect(field string) <span class="cov0" title="0">{
        delete(ctx.Data, field)
}</span>

func (ctx *EventContext) IsMe(id string) bool <span class="cov0" title="0">{
        if ctx.Me != nil </span><span class="cov0" title="0">{
                if userID, ok := ctx.Me["id"].(string); ok </span><span class="cov0" title="0">{
                        return userID == id
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CompileJS compiles JavaScript source code
func CompileJSLegacy(filename, source string) (*goja.Program, error) <span class="cov0" title="0">{
        return goja.Compile(filename, source, true)
}</span>

// CompileGoPlugin compiles a Go source file to a plugin
func CompileGoPlugin(sourcePath, pluginPath string) error <span class="cov0" title="0">{
        // Read the source file
        source, err := os.ReadFile(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source: %w", err)
        }</span>

        // Create a temporary directory for plugin compilation
        <span class="cov0" title="0">tempDir := filepath.Join(filepath.Dir(pluginPath), "temp_"+filepath.Base(strings.TrimSuffix(pluginPath, ".so")))
        if err := os.MkdirAll(tempDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp dir: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.RemoveAll(tempDir)
        
        // Create a temporary wrapper file in the temp directory
        wrapperPath := filepath.Join(tempDir, "main.go")
        wrapper := CreateGoWrapper(string(source))
        
        if err := os.WriteFile(wrapperPath, []byte(wrapper), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write wrapper: %w", err)
        }</span>

        // Create a temporary go.mod file for the plugin
        <span class="cov0" title="0">modPath := filepath.Join(tempDir, "go.mod")
        modContent := `module eventplugin

go 1.21

require (
        github.com/google/uuid v1.6.0
        github.com/shopspring/decimal v1.4.0
        golang.org/x/crypto v0.39.0
)
`
        
        if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write go.mod: %w", err)
        }</span>

        // Create a go.sum file with the required checksums
        <span class="cov0" title="0">sumPath := filepath.Join(tempDir, "go.sum")
        sumContent := `github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=
github.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=
golang.org/x/crypto v0.39.0 h1:SHs+kF4LP+f+p14esP5jAoDpHU8Gu/v9lFRK6IT5imM=
golang.org/x/crypto v0.39.0/go.mod h1:L+Xg3Wf6HoL4Bn4238Z6ft6KfEpN0tJGo53AAPC632U=
`
        
        if err := os.WriteFile(sumPath, []byte(sumContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write go.sum: %w", err)
        }</span>

        // Get the Go root and construct the path to the Go executable
        <span class="cov0" title="0">goRoot := runtime.GOROOT()
        goExe := filepath.Join(goRoot, "bin", "go")
        
        // Fallback to PATH lookup if GOROOT doesn't work
        if _, err := os.Stat(goExe); err != nil </span><span class="cov0" title="0">{
                if goExe, err = exec.LookPath("go"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find go executable: %w", err)
                }</span>
        }
        
        // Download dependencies first
        <span class="cov0" title="0">modCmd := exec.Command(goExe, "mod", "download")
        modCmd.Env = append(os.Environ(), 
                "GO111MODULE=on",
                "GOWORK=off",
        )
        modCmd.Dir = tempDir
        
        if modOutput, err := modCmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail - dependencies might already be available
                fmt.Printf("Go mod download output: %s\n", modOutput)
        }</span>
        
        // Ensure target directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(pluginPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create plugin directory: %w", err)
        }</span>
        
        // Convert to absolute path to ensure correct output location
        <span class="cov0" title="0">absPluginPath, err := filepath.Abs(pluginPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path: %w", err)
        }</span>
        
        // Compile the plugin using the same Go version with absolute output path
        <span class="cov0" title="0">cmd := exec.Command(goExe, "build", "-buildmode=plugin", "-o", absPluginPath, "main.go")
        cmd.Env = append(os.Environ(), 
                "GO111MODULE=on",
                "GOWORK=off", // Disable workspace mode
        )
        cmd.Dir = tempDir
        
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("compilation failed: %w\nOutput: %s", err, output)
        }</span>
        
        // Verify the plugin file was created
        <span class="cov0" title="0">if _, err := os.Stat(absPluginPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin file not created at expected location %s: %w", absPluginPath, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createGoWrapper is defined in compile_wrapper.go

// RunGoPlugin loads and executes a Go plugin
func RunGoPlugin(pluginPath string, ctx *context.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        startTime := time.Now()
        
        // Load the plugin
        p, err := plugin.Open(pluginPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load plugin: %w", err)
        }</span>
        
        <span class="cov0" title="0">loadTime := time.Since(startTime)

        // Look up the EventHandler symbol
        symHandler, err := p.Lookup("EventHandler")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("EventHandler not found in plugin: %w", err)
        }</span>

        // Create event context
        <span class="cov0" title="0">eventCtx := &amp;EventContext{
                Ctx:        ctx,
                Data:       data,
                Errors:     make(map[string]string),
                Query:      ctx.Query,
                Internal:   false,
                IsRoot:     ctx.IsRoot,
                Resource:   ctx.Resource,
                hideFields: make([]string, 0),
        }

        if ctx.IsAuthenticated </span><span class="cov0" title="0">{
                // Create user data from JWT authentication
                userData := map[string]interface{}{
                        "id":       ctx.UserID,
                        "username": ctx.Username,
                        "isRoot":   ctx.IsRoot,
                }
                eventCtx.Me = userData
                // Add compatibility fields for all possible variations
                addCompatibilityFields(userData)
        }</span>

        // Set up cancel function
        <span class="cov0" title="0">var cancelErr error
        eventCtx.Cancel = func(message string, statusCode int) </span><span class="cov0" title="0">{
                cancelErr = &amp;ScriptError{
                        Message:    message,
                        StatusCode: statusCode,
                }
                panic("CANCEL")</span>
        }
        
        // Set up log function
        <span class="cov0" title="0">eventCtx.Log = func(message string, data ...map[string]interface{}) </span><span class="cov0" title="0">{
                // Only log in development mode
                if !ctx.Development </span><span class="cov0" title="0">{
                        return
                }</span>
                
                <span class="cov0" title="0">source := "go"
                if eventCtx.Resource != nil </span><span class="cov0" title="0">{
                        source = fmt.Sprintf("go:%s", eventCtx.Resource.GetName())
                }</span>
                
                <span class="cov0" title="0">var logData map[string]interface{}
                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                        logData = data[0]
                }</span>
                
                // Log to structured logging system AND stdout with user-generated level
                <span class="cov0" title="0">logging.UserGenerated(message, source, logData)
                
                // Also log to stdout for immediate visibility
                fmt.Printf("[USER LOG] %s: %s", source, message)
                if logData != nil </span><span class="cov0" title="0">{
                        if dataJSON, err := json.Marshal(logData); err == nil </span><span class="cov0" title="0">{
                                fmt.Printf(" | Data: %s", string(dataJSON))
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("\n")</span>
        }

        // Use reflection to call the Run method
        <span class="cov0" title="0">handler := symHandler.(interface{})
        if runnable, ok := handler.(interface{ Run(interface{}) error }); ok </span><span class="cov0" title="0">{
                executeStart := time.Now()
                
                // Run with panic recovery
                func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        if r != "CANCEL" </span><span class="cov0" title="0">{
                                                cancelErr = fmt.Errorf("plugin panic: %v", r)
                                        }</span>
                                }
                        }()
                        <span class="cov0" title="0">err = runnable.Run(eventCtx)</span>
                }()
                
                <span class="cov0" title="0">executeTime := time.Since(executeStart)
                
                // Log detailed timing
                logging.Debug("Go plugin execution details", "go-plugin", map[string]interface{}{
                        "plugin":      filepath.Base(pluginPath),
                        "loadTimeMs":  loadTime.Milliseconds(),
                        "execTimeMs":  executeTime.Milliseconds(),
                        "totalTimeMs": time.Since(startTime).Milliseconds(),
                        "hasErrors":   eventCtx.HasErrors(),
                        "cancelled":   cancelErr != nil,
                })

                if cancelErr != nil </span><span class="cov0" title="0">{
                        return cancelErr
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if eventCtx.HasErrors() </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Errors: eventCtx.Errors}
                }</span>
                
                // Sync modified data back to the original data parameter
                <span class="cov0" title="0">for key, value := range eventCtx.Data </span><span class="cov0" title="0">{
                        data[key] = value
                }</span>
                
                // Apply hidden fields
                <span class="cov0" title="0">if hiddenFields := eventCtx.GetHiddenFields(); hiddenFields != nil </span><span class="cov0" title="0">{
                        for _, field := range hiddenFields </span><span class="cov0" title="0">{
                                delete(data, field)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("plugin does not implement Run method")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getProjectRoot attempts to find the project root directory
func getProjectRoot() string <span class="cov0" title="0">{
        // Try to find go.mod in parent directories
        dir, _ := os.Getwd()
        for </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov0" title="0">{
                        return dir
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">dir = parent</span>
        }
        <span class="cov0" title="0">return "."</span>
}

// convertUserToMap attempts to convert various user data formats to map[string]interface{}
func convertUserToMap(userData interface{}) map[string]interface{} <span class="cov0" title="0">{
        if userData == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Use reflection to convert struct to map
        <span class="cov0" title="0">val := reflect.ValueOf(userData)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        
        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">result := make(map[string]interface{})
        typ := val.Type()
        
        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                field := typ.Field(i)
                fieldValue := val.Field(i)
                
                if !fieldValue.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Convert field name to camelCase for consistency
                <span class="cov0" title="0">var fieldName string
                if jsonTag := field.Tag.Get("json"); jsonTag != "" &amp;&amp; jsonTag != "-" </span><span class="cov0" title="0">{
                        fieldName = strings.Split(jsonTag, ",")[0]
                }</span> else<span class="cov0" title="0"> {
                        fieldName = strings.ToLower(field.Name[:1]) + field.Name[1:]
                }</span>
                
                <span class="cov0" title="0">result[fieldName] = fieldValue.Interface()
                
                // Special handling for userId -&gt; id mapping for compatibility
                if fieldName == "userId" </span><span class="cov0" title="0">{
                        result["id"] = fieldValue.Interface()
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// addCompatibilityFields adds multiple field name variations for user ID compatibility
func addCompatibilityFields(userData map[string]interface{}) <span class="cov0" title="0">{
        // Find any user ID field and create all variations
        var userID interface{}
        if val, exists := userData["userId"]; exists </span><span class="cov0" title="0">{
                userID = val
        }</span> else<span class="cov0" title="0"> if val, exists := userData["userid"]; exists </span><span class="cov0" title="0">{
                userID = val
        }</span> else<span class="cov0" title="0"> if val, exists := userData["UserID"]; exists </span><span class="cov0" title="0">{
                userID = val
        }</span> else<span class="cov0" title="0"> if val, exists := userData["id"]; exists </span><span class="cov0" title="0">{
                userID = val
        }</span>
        
        // If we found a user ID, ensure all variations exist
        <span class="cov0" title="0">if userID != nil </span><span class="cov0" title="0">{
                userData["userId"] = userID
                userData["userid"] = userID
                userData["UserID"] = userID
                userData["id"] = userID
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package events

import (
        "fmt"
        "strings"
)

// CreateGoWrapper creates a wrapper that implements the plugin interface
func CreateGoWrapper(userCode string) string <span class="cov0" title="0">{
        // Parse user code to extract imports and functions separately
        lines := strings.Split(userCode, "\n")
        var imports []string
        var functions []string
        
        inImportBlock := false
        for _, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)
                
                // Skip package declaration
                if strings.HasPrefix(trimmed, "package ") </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Handle import statements
                <span class="cov0" title="0">if strings.HasPrefix(trimmed, "import ") </span><span class="cov0" title="0">{
                        inImportBlock = true
                        imports = append(imports, line)
                }</span> else<span class="cov0" title="0"> if inImportBlock &amp;&amp; (trimmed == ")" || strings.Contains(trimmed, ")")) </span><span class="cov0" title="0">{
                        imports = append(imports, line)
                        inImportBlock = false
                }</span> else<span class="cov0" title="0"> if inImportBlock </span><span class="cov0" title="0">{
                        imports = append(imports, line)
                }</span> else<span class="cov0" title="0"> if trimmed != "" </span><span class="cov0" title="0">{
                        // Regular code (functions, etc.) - skip empty lines at the beginning
                        functions = append(functions, line)
                }</span>
        }
        
        <span class="cov0" title="0">userImports := strings.Join(imports, "\n")
        userFunctions := strings.Join(functions, "\n")
        
        // Check if fmt is already imported by user OR if user code uses fmt functions
        hasFmt := false
        for _, imp := range imports </span><span class="cov0" title="0">{
                if strings.Contains(imp, `"fmt"`) </span><span class="cov0" title="0">{
                        hasFmt = true
                        break</span>
                }
        }
        
        // Check if user code actually uses fmt functions
        <span class="cov0" title="0">usesFmt := strings.Contains(userFunctions, "fmt.") || 
                  strings.Contains(userFunctions, "Printf") ||
                  strings.Contains(userFunctions, "Sprintf") ||
                  strings.Contains(userFunctions, "Print")
        
        // Build imports section - only import fmt if user code uses it and doesn't already import it
        wrapperImports := `"reflect"`
        if usesFmt &amp;&amp; !hasFmt </span><span class="cov0" title="0">{
                wrapperImports = `"fmt"
        "reflect"`
        }</span>
        
        <span class="cov0" title="0">template := `package main

import (
        ` + wrapperImports + `
)

%s

// deployd provides utility functions for event handlers
var deployd = struct {
        // Log writes a message to the application logs
        Log func(message string, data ...map[string]interface{})
}{
        Log: func(message string, data ...map[string]interface{}) {
                // This is a fallback function - actual logging is handled by the runtime
                // when the context is properly set up in compile.go
        },
}

// EventContext provides context for event scripts
type EventContext struct {
        // Data is the document being processed
        Data map[string]interface{}
        
        // Query contains the query parameters
        Query map[string]interface{}
        
        // Me contains the current user (if authenticated)
        Me map[string]interface{}
        
        // IsRoot indicates if the user has root/admin privileges
        IsRoot bool
        
        // Internal indicates if this is an internal request
        Internal bool
        
        // Errors holds validation errors
        Errors map[string]string
        
        // Cancel cancels the current operation with an error
        Cancel func(message string, statusCode int)
        
        // Log writes a message to the application logs
        Log func(message string, data ...map[string]interface{})
        
        // Hide removes a field from the response
        hideFields []string
}

// Error adds a validation error
func (ctx *EventContext) Error(field, message string) {
        if ctx.Errors == nil {
                ctx.Errors = make(map[string]string)
        }
        ctx.Errors[field] = message
}

// HasErrors returns true if there are validation errors
func (ctx *EventContext) HasErrors() bool {
        return len(ctx.Errors) &gt; 0
}

// Hide removes a field from the response
func (ctx *EventContext) Hide(field string) {
        ctx.hideFields = append(ctx.hideFields, field)
        // Also remove from data
        delete(ctx.Data, field)
}

// GetHiddenFields returns the list of fields to hide
func (ctx *EventContext) GetHiddenFields() []string {
        return ctx.hideFields
}

%s

// EventHandler is the exported plugin handler
var EventHandler eventHandler

type eventHandler struct{}

// Run implements the plugin interface
func (h eventHandler) Run(ctx interface{}) error {
        // Use reflection to extract field values since types don't match exactly
        v := reflect.ValueOf(ctx)
        if v.Kind() == reflect.Ptr {
                v = v.Elem()
        }
        
        // Extract field values using reflection with safe type assertions
        localCtx := &amp;EventContext{
                Data:     safeGetMapField(v, "Data"),
                Query:    safeGetMapField(v, "Query"),
                Me:       safeGetMapField(v, "Me"),
                IsRoot:   safeGetBoolField(v, "IsRoot"),
                Internal: safeGetBoolField(v, "Internal"),
                Errors:   safeGetStringMapField(v, "Errors"),
                Cancel:   safeGetCancelField(v, "Cancel"),
                Log:      safeGetLogField(v, "Log"),
        }
        
        // Run the user's event handler
        err := Run(localCtx)
        
        // Sync changes back to the original context using reflection
        // Note: We need to work with the original pointer value, not the dereferenced struct
        origV := reflect.ValueOf(ctx)
        if origV.Kind() == reflect.Ptr &amp;&amp; origV.Elem().Kind() == reflect.Struct {
                structV := origV.Elem()
                
                // Sync Data changes
                dataField := structV.FieldByName("Data")
                if dataField.IsValid() &amp;&amp; dataField.CanSet() {
                        dataField.Set(reflect.ValueOf(localCtx.Data))
                }
                
                // Sync hidden fields back
                hideFieldsField := structV.FieldByName("hideFields")
                if hideFieldsField.IsValid() &amp;&amp; hideFieldsField.CanSet() {
                        hideFieldsField.Set(reflect.ValueOf(localCtx.hideFields))
                }
        }
        
        return err
}

// Helper function to get field value by name
func getFieldValue(v reflect.Value, fieldName string) interface{} {
        field := v.FieldByName(fieldName)
        if !field.IsValid() {
                return nil
        }
        return field.Interface()
}

// Safe helper functions for type conversion
func safeGetMapField(v reflect.Value, fieldName string) map[string]interface{} {
        val := getFieldValue(v, fieldName)
        if val == nil {
                return make(map[string]interface{})
        }
        if mapVal, ok := val.(map[string]interface{}); ok {
                return mapVal
        }
        return make(map[string]interface{})
}

func safeGetBoolField(v reflect.Value, fieldName string) bool {
        val := getFieldValue(v, fieldName)
        if val == nil {
                return false
        }
        if boolVal, ok := val.(bool); ok {
                return boolVal
        }
        return false
}

func safeGetStringMapField(v reflect.Value, fieldName string) map[string]string {
        val := getFieldValue(v, fieldName)
        if val == nil {
                return make(map[string]string)
        }
        if mapVal, ok := val.(map[string]string); ok {
                return mapVal
        }
        return make(map[string]string)
}

func safeGetCancelField(v reflect.Value, fieldName string) func(string, int) {
        val := getFieldValue(v, fieldName)
        if val == nil {
                return func(string, int) {} // no-op function
        }
        if cancelFunc, ok := val.(func(string, int)); ok {
                return cancelFunc
        }
        return func(string, int) {} // no-op function
}

func safeGetLogField(v reflect.Value, fieldName string) func(string, ...map[string]interface{}) {
        val := getFieldValue(v, fieldName)
        if val == nil {
                return deployd.Log // fallback to global deployd.Log
        }
        if logFunc, ok := val.(func(string, ...map[string]interface{})); ok {
                return logFunc
        }
        return deployd.Log // fallback to global deployd.Log
}
`
        
        return fmt.Sprintf(template, userImports, userFunctions)</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package events

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "plugin"
        "strings"
        "sync"
        "time"

        "github.com/hjanuschka/go-deployd/internal/context"
        "go.mongodb.org/mongo-driver/bson"
)

// HotReloadGoManager manages hot-reloadable Go plugins
type HotReloadGoManager struct {
        plugins    map[EventType]*HotPlugin
        configPath string
        mu         sync.RWMutex
}

// HotPlugin represents a hot-reloadable Go plugin
type HotPlugin struct {
        SourcePath   string
        PluginPath   string
        Plugin       *plugin.Plugin
        LastModified time.Time
        LastCompiled time.Time
}

// NewHotReloadGoManager creates a new hot-reload manager
func NewHotReloadGoManager(configPath string) *HotReloadGoManager <span class="cov8" title="1">{
        return &amp;HotReloadGoManager{
                plugins:    make(map[EventType]*HotPlugin),
                configPath: configPath,
        }
}</span>

// LoadScript loads or reloads a Go script
func (hrm *HotReloadGoManager) LoadScript(eventType EventType, source string) error <span class="cov0" title="0">{
        hrm.mu.Lock()
        defer hrm.mu.Unlock()

        // Create source file
        sourcePath := filepath.Join(hrm.configPath, ".hotreload", strings.ToLower(string(eventType))+".go")
        if err := os.MkdirAll(filepath.Dir(sourcePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Write source to file
        <span class="cov0" title="0">wrappedSource := hrm.wrapGoSource(source)
        if err := os.WriteFile(sourcePath, []byte(wrappedSource), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write source: %w", err)
        }</span>

        // Compile to plugin
        <span class="cov0" title="0">pluginPath := strings.TrimSuffix(sourcePath, ".go") + ".so"
        if err := hrm.compilePlugin(sourcePath, pluginPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compile plugin: %w", err)
        }</span>

        // Load plugin
        <span class="cov0" title="0">p, err := plugin.Open(pluginPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load plugin: %w", err)
        }</span>

        // Store plugin info
        <span class="cov0" title="0">hrm.plugins[eventType] = &amp;HotPlugin{
                SourcePath:   sourcePath,
                PluginPath:   pluginPath,
                Plugin:       p,
                LastModified: time.Now(),
                LastCompiled: time.Now(),
        }

        return nil</span>
}

// RunScript executes a hot-loaded Go script
func (hrm *HotReloadGoManager) RunScript(eventType EventType, ctx *context.Context, data bson.M) error <span class="cov0" title="0">{
        hrm.mu.RLock()
        hotPlugin, exists := hrm.plugins[eventType]
        hrm.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil // No script loaded
        }</span>

        // Look up the Run function
        <span class="cov0" title="0">symRun, err := hotPlugin.Plugin.Lookup("Run")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Run function not found: %w", err)
        }</span>

        // Cast to function
        <span class="cov0" title="0">runFunc, ok := symRun.(func(*EventContext) error)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Run function signature")
        }</span>

        // Create event context
        <span class="cov0" title="0">eventCtx := &amp;EventContext{
                Ctx:      ctx,
                Data:     data,
                Errors:   make(map[string]string),
                Query:    ctx.Query,
                Internal: false,
                IsRoot:   ctx.IsRoot,
        }

        if ctx.IsAuthenticated </span><span class="cov0" title="0">{
                // Create user data from JWT authentication
                userData := map[string]interface{}{
                        "id":       ctx.UserID,
                        "username": ctx.Username,
                        "isRoot":   ctx.IsRoot,
                }
                eventCtx.Me = userData
        }</span>

        // Set up cancel function
        <span class="cov0" title="0">var cancelErr error
        eventCtx.Cancel = func(message string, statusCode int) </span><span class="cov0" title="0">{
                cancelErr = &amp;ScriptError{
                        Message:    message,
                        StatusCode: statusCode,
                }
                panic("CANCEL")</span>
        }

        // Execute with panic recovery
        <span class="cov0" title="0">var execErr error
        func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if r != "CANCEL" </span><span class="cov0" title="0">{
                                        execErr = fmt.Errorf("runtime panic: %v", r)
                                }</span>
                        }
                }()
                <span class="cov0" title="0">execErr = runFunc(eventCtx)</span>
        }()

        <span class="cov0" title="0">if cancelErr != nil </span><span class="cov0" title="0">{
                return cancelErr
        }</span>

        <span class="cov0" title="0">if execErr != nil </span><span class="cov0" title="0">{
                return execErr
        }</span>

        <span class="cov0" title="0">if eventCtx.HasErrors() </span><span class="cov0" title="0">{
                return &amp;ValidationError{Errors: eventCtx.Errors}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// compilePlugin compiles a Go source file to a plugin
func (hrm *HotReloadGoManager) compilePlugin(sourcePath, pluginPath string) error <span class="cov0" title="0">{
        // Create go.mod for the plugin
        dir := filepath.Dir(sourcePath)
        modPath := filepath.Join(dir, "go.mod")
        
        modContent := fmt.Sprintf(`module hotreload

go 1.21

require (
        github.com/hjanuschka/go-deployd v0.0.0
        go.mongodb.org/mongo-driver v1.13.0
)

replace github.com/hjanuschka/go-deployd =&gt; %s
`, hrm.getProjectRoot())

        if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write go.mod: %w", err)
        }</span>

        // Compile the plugin
        <span class="cov0" title="0">cmd := exec.Command("go", "build", "-buildmode=plugin", "-o", pluginPath, sourcePath)
        cmd.Dir = dir
        cmd.Env = append(os.Environ(), "GO111MODULE=on", "GOWORK=off")

        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("compilation failed: %w\nOutput: %s", err, output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// wrapGoSource wraps user Go code in proper package structure
func (hrm *HotReloadGoManager) wrapGoSource(userCode string) string <span class="cov0" title="0">{
        // Check if it already has package declaration
        if strings.Contains(userCode, "package ") </span><span class="cov0" title="0">{
                return userCode
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`package main

import (
        "strings"
        "time"
        "github.com/hjanuschka/go-deployd/internal/events"
)

%s

// Exported Run function for plugin
func Run(ctx *events.EventContext) error {
        return run(ctx)
}

// Rename user function to avoid conflicts
func run(ctx *events.EventContext) error {
        return nil
}`, userCode)</span>
}

// getProjectRoot finds the project root directory
func (hrm *HotReloadGoManager) getProjectRoot() string <span class="cov0" title="0">{
        dir, _ := os.Getwd()
        for </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil </span><span class="cov0" title="0">{
                        return dir
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">dir = parent</span>
        }
        <span class="cov0" title="0">return "."</span>
}

// GetScriptInfo returns information about loaded scripts
func (hrm *HotReloadGoManager) GetScriptInfo() map[string]interface{} <span class="cov0" title="0">{
        hrm.mu.RLock()
        defer hrm.mu.RUnlock()

        info := make(map[string]interface{})
        for eventType, hotPlugin := range hrm.plugins </span><span class="cov0" title="0">{
                info[strings.ToLower(string(eventType))] = map[string]interface{}{
                        "type":         "go-hotreload",
                        "sourcePath":   hotPlugin.SourcePath,
                        "pluginPath":   hotPlugin.PluginPath,
                        "lastModified": hotPlugin.LastModified,
                        "lastCompiled": hotPlugin.LastCompiled,
                }
        }</span>
        <span class="cov0" title="0">return info</span>
}

// ReloadAllIfChanged checks for changes and reloads if necessary
func (hrm *HotReloadGoManager) ReloadAllIfChanged() error <span class="cov0" title="0">{
        hrm.mu.Lock()
        defer hrm.mu.Unlock()

        for eventType, hotPlugin := range hrm.plugins </span><span class="cov0" title="0">{
                if stat, err := os.Stat(hotPlugin.SourcePath); err == nil </span><span class="cov0" title="0">{
                        if stat.ModTime().After(hotPlugin.LastCompiled) </span><span class="cov0" title="0">{
                                // Source has changed, recompile
                                if err := hrm.compilePlugin(hotPlugin.SourcePath, hotPlugin.PluginPath); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Failed to recompile %s: %v\n", eventType, err)
                                        continue</span>
                                }

                                // Reload plugin
                                <span class="cov0" title="0">p, err := plugin.Open(hotPlugin.PluginPath)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Failed to reload plugin %s: %v\n", eventType, err)
                                        continue</span>
                                }

                                <span class="cov0" title="0">hotPlugin.Plugin = p
                                hotPlugin.LastCompiled = time.Now()
                                fmt.Printf("Hot-reloaded %s plugin\n", eventType)</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package events

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/hjanuschka/go-deployd/internal/context"
        "github.com/hjanuschka/go-deployd/internal/logging"
        "github.com/hjanuschka/go-deployd/internal/metrics"
)

// UniversalScriptManager manages both JavaScript and Go event scripts
type UniversalScriptManager struct {
        jsScripts        map[EventType]*Script
        goPlugins        map[EventType]*CompiledGoScript
        hotReloadManager *HotReloadGoManager
        scriptTypes      map[EventType]ScriptType
        configPath       string
        v8Pool           *V8Pool
        mu               sync.RWMutex
}

// ScriptType represents the type of script
type ScriptType string

const (
        ScriptTypeJS ScriptType = "js"
        ScriptTypeGo ScriptType = "go"
)

// EventConfiguration represents per-event runtime configuration
type EventConfiguration struct {
        Runtime string `json:"runtime"` // "js" or "go"
}

// CompiledGoScript represents a compiled Go script
type CompiledGoScript struct {
        SourcePath   string
        PluginPath   string
        LastModified int64
}

// NewUniversalScriptManager creates a manager that supports both JS and Go
func NewUniversalScriptManager() *UniversalScriptManager <span class="cov8" title="1">{
        // Initialize V8 pool for JavaScript events
        v8Pool := GetV8Pool()
        
        return &amp;UniversalScriptManager{
                jsScripts:        make(map[EventType]*Script),
                goPlugins:        make(map[EventType]*CompiledGoScript),
                scriptTypes:      make(map[EventType]ScriptType),
                hotReloadManager: nil, // Will be initialized when needed
                v8Pool:           v8Pool,
        }
}</span>

// LoadScriptsWithConfig loads event scripts with runtime configuration
func (usm *UniversalScriptManager) LoadScriptsWithConfig(configPath string, eventConfig map[string]EventConfiguration) error <span class="cov0" title="0">{
        usm.configPath = configPath
        
        eventNames := map[EventType]string{
                EventGet:           "get",
                EventValidate:      "validate",
                EventPost:          "post",
                EventPut:           "put",
                EventDelete:        "delete",
                EventAfterCommit:   "aftercommit",
                EventBeforeRequest: "beforerequest",
        }
        
        usm.mu.Lock()
        defer usm.mu.Unlock()
        
        // Create plugins directory
        pluginDir := filepath.Join(configPath, ".plugins")
        os.MkdirAll(pluginDir, 0755)
        
        for eventType, baseName := range eventNames </span><span class="cov0" title="0">{
                // Get preferred runtime from config
                preferredRuntime := "go" // default to Go
                if config, exists := eventConfig[baseName]; exists &amp;&amp; config.Runtime != "" </span><span class="cov0" title="0">{
                        preferredRuntime = config.Runtime
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("üîç LOADING EVENT SCRIPT: %s/%s - runtime: %s (config exists: %v)\n", 
                        filepath.Base(configPath), baseName, preferredRuntime, eventConfig[baseName])
                
                // Load only the configured runtime - no fallback
                if preferredRuntime == "go" </span><span class="cov0" title="0">{
                        // Only try Go script - compile to plugin on startup
                        goPath := filepath.Join(configPath, baseName+".go")
                        if _, err := os.ReadFile(goPath); err == nil </span><span class="cov0" title="0">{
                                fmt.Printf("üì¶ Compiling Go event script: %s/%s.go\n", filepath.Base(configPath), baseName)
                                // Compile Go script to plugin
                                pluginPath := filepath.Join(configPath, ".plugins", baseName+".so")
                                if err := CompileGoPlugin(goPath, pluginPath); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("‚ùå Failed to compile Go script %s: %v\n", goPath, err)
                                        // Don't load this event script at all if Go compilation fails
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("‚úÖ Successfully compiled Go event script: %s/%s.go\n", filepath.Base(configPath), baseName)
                                        usm.goPlugins[eventType] = &amp;CompiledGoScript{
                                                SourcePath:   goPath,
                                                PluginPath:   pluginPath,
                                                LastModified: 0, // Not used for startup compilation
                                        }
                                        usm.scriptTypes[eventType] = ScriptTypeGo
                                }</span>
                        }
                        // If no .go file exists, that's fine - just don't load any script for this event
                } else<span class="cov0" title="0"> {
                        // Only try JavaScript
                        jsPath := filepath.Join(configPath, baseName+".js")
                        if content, err := os.ReadFile(jsPath); err == nil </span><span class="cov0" title="0">{
                                script := &amp;Script{
                                        source: string(content),
                                        path:   jsPath,
                                }
                                
                                // Pre-compile the script in V8 pool for better performance
                                if usm.v8Pool != nil </span><span class="cov0" title="0">{
                                        if precompileErr := usm.v8Pool.PrecompileScript(jsPath, string(content)); precompileErr != nil </span><span class="cov0" title="0">{
                                                // Log error but continue - fallback to runtime compilation
                                                fmt.Printf("Warning: Failed to precompile JavaScript %s: %v\n", jsPath, precompileErr)
                                        }</span> else<span class="cov0" title="0"> {
                                                // Mark script as compiled for optimized execution
                                                script.isPrecompiled = true
                                        }</span>
                                }
                                
                                <span class="cov0" title="0">usm.jsScripts[eventType] = script
                                usm.scriptTypes[eventType] = ScriptTypeJS</span>
                        }
                        // If no .js file exists, that's fine - just don't load any script for this event
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// loadGoScript compiles and loads a Go script
func (usm *UniversalScriptManager) loadGoScript(eventType EventType, sourcePath string, modTime int64) error <span class="cov0" title="0">{
        pluginName := strings.TrimSuffix(filepath.Base(sourcePath), ".go")
        pluginPath := filepath.Join(usm.configPath, ".plugins", pluginName+".so")
        
        // Check if we need to recompile
        needsCompile := true
        if existing, exists := usm.goPlugins[eventType]; exists </span><span class="cov0" title="0">{
                if pluginInfo, err := os.Stat(pluginPath); err == nil </span><span class="cov0" title="0">{
                        if pluginInfo.ModTime().Unix() &gt; modTime </span><span class="cov0" title="0">{
                                needsCompile = false
                        }</span>
                }
                <span class="cov0" title="0">if existing.LastModified == modTime </span><span class="cov0" title="0">{
                        needsCompile = false
                }</span>
        }
        
        <span class="cov0" title="0">if needsCompile </span><span class="cov0" title="0">{
                if err := CompileGoPlugin(sourcePath, pluginPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">usm.goPlugins[eventType] = &amp;CompiledGoScript{
                SourcePath:   sourcePath,
                PluginPath:   pluginPath,
                LastModified: modTime,
        }
        
        return nil</span>
}

// RunEvent executes an event script with timing and payload logging
func (usm *UniversalScriptManager) RunEvent(eventType EventType, ctx *context.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        // Start timing
        startTime := time.Now()
        
        // Log event trigger with payload
        var collectionName string
        if ctx.Resource != nil </span><span class="cov0" title="0">{
                collectionName = ctx.Resource.GetName()
        }</span>
        
        <span class="cov0" title="0">var userID interface{}
        if ctx.IsAuthenticated </span><span class="cov0" title="0">{
                userID = ctx.UserID
        }</span>
        
        <span class="cov0" title="0">logging.Info("üöÄ EVENT TRIGGERED", "event", map[string]interface{}{
                "type":       string(eventType),
                "collection": collectionName,
                "method":     ctx.Method,
                "user":       userID,
                "payload":    data,
        })
        
        // Check if we have any script for this event
        usm.mu.RLock()
        scriptType, exists := usm.scriptTypes[eventType]
        logging.Info("üîç CHECKING SCRIPT AVAILABILITY", "event", map[string]interface{}{
                "eventType":    string(eventType),
                "exists":       exists,
                "scriptType":   string(scriptType),
                "allScripts":   usm.scriptTypes,
                "goPlugins":    len(usm.goPlugins),
                "jsScripts":    len(usm.jsScripts),
        })
        
        if !exists </span><span class="cov0" title="0">{
                usm.mu.RUnlock()
                logging.Info("‚ùå NO SCRIPT FOUND FOR EVENT", "event", map[string]interface{}{
                        "eventType": string(eventType),
                        "collection": collectionName,
                })
                return nil // No script for this event
        }</span>
        
        <span class="cov0" title="0">var err error
        var runtime string
        
        switch scriptType </span>{
        case ScriptTypeGo:<span class="cov0" title="0">
                runtime = "go"
                goScript := usm.goPlugins[eventType]
                usm.mu.RUnlock()
                
                logging.Info("üîß EXECUTING GO SCRIPT", "event", map[string]interface{}{
                        "eventType":  string(eventType),
                        "collection": collectionName,
                        "hasScript":  goScript != nil,
                        "pluginPath": func() string </span><span class="cov0" title="0">{ if goScript != nil </span><span class="cov0" title="0">{ return goScript.PluginPath }</span> else<span class="cov0" title="0"> { return "nil" }</span> }(),
                })
                
                // Use compiled plugin for Go scripts
                <span class="cov0" title="0">if goScript != nil </span><span class="cov0" title="0">{
                        err = RunGoPlugin(goScript.PluginPath, ctx, data)
                        logging.Info("üîß GO PLUGIN EXECUTION RESULT", "event", map[string]interface{}{
                                "eventType": string(eventType),
                                "error":     err,
                                "dataAfter": data,
                        })
                }</span> else<span class="cov0" title="0"> {
                        logging.Error("‚ùå GO SCRIPT IS NIL", "event", map[string]interface{}{
                                "eventType": string(eventType),
                        })
                }</span>
                
        case ScriptTypeJS:<span class="cov0" title="0">
                runtime = "js"
                jsScript := usm.jsScripts[eventType]
                usm.mu.RUnlock()
                
                logging.Info("üîß EXECUTING JS SCRIPT", "event", map[string]interface{}{
                        "eventType":  string(eventType),
                        "collection": collectionName,
                        "hasScript":  jsScript != nil,
                })
                
                err = usm.runJSScript(jsScript, ctx, data)</span>
                
        default:<span class="cov0" title="0">
                usm.mu.RUnlock()
                logging.Error("‚ùå UNKNOWN SCRIPT TYPE", "event", map[string]interface{}{
                        "eventType":  string(eventType),
                        "scriptType": string(scriptType),
                })
                return nil</span>
        }
        
        // Calculate execution time
        <span class="cov0" title="0">duration := time.Since(startTime)
        
        // Record hook execution metrics
        metrics.RecordHookExecution(collectionName, string(eventType), duration, err)
        
        // Log event completion with timing
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Event failed", "event", map[string]interface{}{
                        "type":       string(eventType),
                        "collection": collectionName,
                        "runtime":    runtime,
                        "duration":   duration.String(),
                        "durationMs": duration.Milliseconds(),
                        "error":      err.Error(),
                })
        }</span> else<span class="cov0" title="0"> {
                logging.Info("Event completed", "event", map[string]interface{}{
                        "type":       string(eventType),
                        "collection": collectionName,
                        "runtime":    runtime,
                        "duration":   duration.String(),
                        "durationMs": duration.Milliseconds(),
                        "dataModified": data,
                })
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

// runGoPlugin executes a Go plugin
func (usm *UniversalScriptManager) runGoPlugin(script *CompiledGoScript, ctx *context.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        return RunGoPlugin(script.PluginPath, ctx, data)
}</span>

// runJSScript executes a JavaScript script
func (usm *UniversalScriptManager) runJSScript(script *Script, ctx *context.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        scriptCtx, err := script.Run(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scriptCtx.GetError()</span>
}

// GetScriptInfo returns information about loaded scripts
func (usm *UniversalScriptManager) GetScriptInfo() map[string]interface{} <span class="cov0" title="0">{
        usm.mu.RLock()
        defer usm.mu.RUnlock()
        
        info := make(map[string]interface{})
        
        for eventType, scriptType := range usm.scriptTypes </span><span class="cov0" title="0">{
                eventName := strings.ToLower(string(eventType))
                switch scriptType </span>{
                case ScriptTypeGo:<span class="cov0" title="0">
                        if script, exists := usm.goPlugins[eventType]; exists </span><span class="cov0" title="0">{
                                info[eventName] = map[string]interface{}{
                                        "type":   "go",
                                        "path":   script.SourcePath,
                                        "plugin": script.PluginPath,
                                }
                        }</span>
                case ScriptTypeJS:<span class="cov0" title="0">
                        if script, exists := usm.jsScripts[eventType]; exists </span><span class="cov0" title="0">{
                                info[eventName] = map[string]interface{}{
                                        "type": "js",
                                        "path": script.path,
                                }
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return info</span>
}

// LoadScripts loads all event scripts from the given config path (backward compatibility)
func (usm *UniversalScriptManager) LoadScripts(configPath string) error <span class="cov0" title="0">{
        return usm.LoadScriptsWithConfig(configPath, make(map[string]EventConfiguration))
}</span>

// ReloadScript reloads a specific event script
func (usm *UniversalScriptManager) ReloadScript(eventType EventType) error <span class="cov0" title="0">{
        // This would allow hot-reloading of scripts during development
        return usm.LoadScripts(usm.configPath)
}</span>

// LoadHotReloadScript compiles and hot-loads a Go script
func (usm *UniversalScriptManager) LoadHotReloadScript(eventType EventType, source string) error <span class="cov0" title="0">{
        usm.mu.Lock()
        defer usm.mu.Unlock()
        
        // Write source to the actual file location
        eventName := strings.ToLower(string(eventType))
        sourcePath := filepath.Join(usm.configPath, eventName+".go")
        if err := os.WriteFile(sourcePath, []byte(source), 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Compile to plugin
        <span class="cov0" title="0">pluginPath := filepath.Join(usm.configPath, ".plugins", eventName+".so")
        fmt.Printf("üîÑ Hot-reloading Go event script: %s/%s.go\n", filepath.Base(usm.configPath), eventName)
        if err := CompileGoPlugin(sourcePath, pluginPath); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Failed to hot-reload Go script: %v\n", err)
                return err
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("‚úÖ Successfully hot-reloaded Go event script: %s/%s.go\n", filepath.Base(usm.configPath), eventName)
        
        // Update plugin reference
        usm.goPlugins[eventType] = &amp;CompiledGoScript{
                SourcePath:   sourcePath,
                PluginPath:   pluginPath,
                LastModified: 0,
        }
        usm.scriptTypes[eventType] = ScriptTypeGo
        return nil</span>
}

// GetHotReloadInfo returns hot-reload information
func (usm *UniversalScriptManager) GetHotReloadInfo() map[string]interface{} <span class="cov0" title="0">{
        if usm.hotReloadManager != nil </span><span class="cov0" title="0">{
                return usm.hotReloadManager.GetScriptInfo()
        }</span>
        <span class="cov0" title="0">return make(map[string]interface{})</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package events

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "plugin"
        "strings"
        "sync"

        "github.com/hjanuschka/go-deployd/internal/context"
        "go.mongodb.org/mongo-driver/bson"
)

// EventPlugin represents a Go plugin for event handling
type EventPlugin interface {
        // Run executes the event logic
        Run(ctx *EventContext) error
}

// EventContext is defined in compile.go

// GoPluginManager manages Go plugin-based events
type GoPluginManager struct {
        plugins map[EventType]*plugin.Plugin
        mu      sync.RWMutex
}

// NewGoPluginManager creates a new Go plugin manager
func NewGoPluginManager() *GoPluginManager <span class="cov8" title="1">{
        return &amp;GoPluginManager{
                plugins: make(map[EventType]*plugin.Plugin),
        }
}</span>

// LoadPlugins loads all event plugins from the given config path
func (gpm *GoPluginManager) LoadPlugins(configPath string) error <span class="cov0" title="0">{
        eventFiles := map[EventType]string{
                EventGet:           "get.go",
                EventValidate:      "validate.go",
                EventPost:          "post.go",
                EventPut:           "put.go",
                EventDelete:        "delete.go",
                EventAfterCommit:   "aftercommit.go",
                EventBeforeRequest: "beforerequest.go",
        }

        gpm.mu.Lock()
        defer gpm.mu.Unlock()

        for eventType, filename := range eventFiles </span><span class="cov0" title="0">{
                sourcePath := filepath.Join(configPath, filename)
                if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Compile the Go source to a plugin
                <span class="cov0" title="0">pluginPath := filepath.Join(configPath, ".plugins", strings.TrimSuffix(filename, ".go")+".so")
                if err := gpm.compilePlugin(sourcePath, pluginPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compile %s: %w", filename, err)
                }</span>

                // Load the compiled plugin
                <span class="cov0" title="0">p, err := plugin.Open(pluginPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load plugin %s: %w", pluginPath, err)
                }</span>

                <span class="cov0" title="0">gpm.plugins[eventType] = p</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// compilePlugin compiles a Go source file to a plugin
func (gpm *GoPluginManager) compilePlugin(sourcePath, pluginPath string) error <span class="cov0" title="0">{
        // Ensure plugin directory exists
        pluginDir := filepath.Dir(pluginPath)
        if err := os.MkdirAll(pluginDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a wrapper that implements the EventPlugin interface
        <span class="cov0" title="0">wrapperPath := strings.TrimSuffix(sourcePath, ".go") + "_wrapper.go"
        if err := gpm.createWrapper(sourcePath, wrapperPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer os.Remove(wrapperPath)

        // Compile the plugin
        cmd := exec.Command("go", "build", "-buildmode=plugin", "-o", pluginPath, wrapperPath)
        cmd.Env = append(os.Environ(), "GO111MODULE=on")
        
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("compilation failed: %w\n%s", err, output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createWrapper creates a wrapper file that implements EventPlugin
func (gpm *GoPluginManager) createWrapper(sourcePath, wrapperPath string) error <span class="cov0" title="0">{
        source, err := os.ReadFile(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">wrapper := fmt.Sprintf(`package main

import (
        "github.com/hjanuschka/go-deployd/internal/events"
        "go.mongodb.org/mongo-driver/bson"
)

// User-defined event code
%s

// Plugin is the exported plugin instance
var Plugin eventPlugin

type eventPlugin struct{}

// Run implements the EventPlugin interface
func (p eventPlugin) Run(ctx *events.EventContext) error {
        // Call the user-defined Run function
        return Run(ctx)
}
`, source)

        return os.WriteFile(wrapperPath, []byte(wrapper), 0644)</span>
}

// GetPlugin returns a plugin for the given event type
func (gpm *GoPluginManager) GetPlugin(eventType EventType) (*plugin.Plugin, error) <span class="cov0" title="0">{
        gpm.mu.RLock()
        defer gpm.mu.RUnlock()
        
        p, exists := gpm.plugins[eventType]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return p, nil</span>
}

// RunPlugin executes a plugin with the given context
func (gpm *GoPluginManager) RunPlugin(eventType EventType, ctx *context.Context, data bson.M) error <span class="cov0" title="0">{
        p, err := gpm.GetPlugin(eventType)
        if err != nil || p == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Look up the plugin symbol
        <span class="cov0" title="0">symPlugin, err := p.Lookup("Plugin")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("plugin symbol not found: %w", err)
        }</span>

        // Cast to EventPlugin interface
        <span class="cov0" title="0">eventPlugin, ok := symPlugin.(EventPlugin)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid plugin type")
        }</span>

        // Create event context
        <span class="cov0" title="0">eventCtx := &amp;EventContext{
                Ctx:      ctx,
                Data:     data,
                Errors:   make(map[string]string),
                Query:    ctx.Query,
                Internal: false, // TODO: Add Internal field to Context if needed
                IsRoot:   ctx.IsRoot,
        }

        if ctx.IsAuthenticated </span><span class="cov0" title="0">{
                // Create user data from JWT authentication
                userData := map[string]interface{}{
                        "id":       ctx.UserID,
                        "username": ctx.Username,
                        "isRoot":   ctx.IsRoot,
                }
                eventCtx.Me = userData
        }</span>

        // Set up cancel function
        <span class="cov0" title="0">var cancelErr error
        eventCtx.Cancel = func(message string, statusCode int) </span><span class="cov0" title="0">{
                cancelErr = &amp;ScriptError{
                        Message:    message,
                        StatusCode: statusCode,
                }
                panic("CANCEL")</span>
        }

        // Run the plugin with panic recovery
        <span class="cov0" title="0">func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if r != "CANCEL" </span><span class="cov0" title="0">{
                                        cancelErr = fmt.Errorf("plugin panic: %v", r)
                                }</span>
                        }
                }()
                <span class="cov0" title="0">err = eventPlugin.Run(eventCtx)</span>
        }()

        <span class="cov0" title="0">if cancelErr != nil </span><span class="cov0" title="0">{
                return cancelErr
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if eventCtx.HasErrors() </span><span class="cov0" title="0">{
                return &amp;ValidationError{Errors: eventCtx.Errors}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file22" style="display: none">package events

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        v8 "rogchap.com/v8go"
        "github.com/hjanuschka/go-deployd/internal/context"
        "github.com/hjanuschka/go-deployd/internal/logging"
        "go.mongodb.org/mongo-driver/bson"
)

// Script represents a JavaScript event script using V8 (compatible with goja interface)
type Script struct {
        source        string
        path          string
        compiled      *v8.UnboundScript
        isPrecompiled bool // Indicates if script is precompiled in V8 pool
        mu            sync.RWMutex
}

// EventType represents the type of event
type EventType string

const (
        EventGet           EventType = "Get"
        EventValidate      EventType = "Validate"
        EventPost          EventType = "Post"
        EventPut           EventType = "Put"
        EventDelete        EventType = "Delete"
        EventAfterCommit   EventType = "AfterCommit"
        EventBeforeRequest EventType = "BeforeRequest"
)

// ScriptManager manages event scripts for a collection using V8 (compatible with goja interface)
type ScriptManager struct {
        scripts map[EventType]*Script
        mu      sync.RWMutex
}

// NewScriptManager creates a new V8 script manager
func NewScriptManager() *ScriptManager <span class="cov8" title="1">{
        return &amp;ScriptManager{
                scripts: make(map[EventType]*Script),
        }
}</span>

// LoadScripts loads all event scripts from the given config path
func (sm *ScriptManager) LoadScripts(configPath string) error <span class="cov0" title="0">{
        eventFiles := map[EventType]string{
                EventGet:           "get.js",
                EventValidate:      "validate.js",
                EventPost:          "post.js",
                EventPut:           "put.js",
                EventDelete:        "delete.js",
                EventAfterCommit:   "aftercommit.js",
                EventBeforeRequest: "beforerequest.js",
        }

        sm.mu.Lock()
        defer sm.mu.Unlock()

        for eventType, filename := range eventFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(configPath, filename)
                if content, err := os.ReadFile(filePath); err == nil </span><span class="cov0" title="0">{
                        script := &amp;Script{
                                source: string(content),
                                path:   filePath,
                        }
                        
                        // Pre-compilation is handled during execution for better error handling
                        sm.scripts[eventType] = script
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetScript returns a script for the given event type
func (sm *ScriptManager) GetScript(eventType EventType) *Script <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()
        return sm.scripts[eventType]
}</span>

// ScriptContext holds the execution context for a V8 script (compatible with goja interface)
type ScriptContext struct {
        ctx        *context.Context
        data       bson.M
        errors     map[string]string
        cancelled  bool
        cancelMsg  string
        statusCode int
}

// Run executes the script in the given context using V8 (compatible with goja interface)
func (s *Script) Run(ctx *context.Context, data bson.M) (*ScriptContext, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        scriptCtx := &amp;ScriptContext{
                ctx:    ctx,
                data:   data,
                errors: make(map[string]string),
        }

        // Use V8 pool if script is precompiled for better performance
        if s.isPrecompiled </span><span class="cov0" title="0">{
                return s.runWithPool(scriptCtx)
        }</span>

        // Fallback to traditional method for non-precompiled scripts
        <span class="cov0" title="0">return s.runTraditional(scriptCtx)</span>
}

// runWithPool executes the script using the V8 pool (optimized path)
func (s *Script) runWithPool(scriptCtx *ScriptContext) (*ScriptContext, error) <span class="cov0" title="0">{
        pool := GetV8Pool()
        if pool == nil </span><span class="cov0" title="0">{
                // Fallback to traditional execution if pool is not available
                return s.runTraditional(scriptCtx)
        }</span>

        // Acquire a context from the pool with timeout
        <span class="cov0" title="0">acquireStart := time.Now()
        eventCtx, err := pool.AcquireContext(5 * time.Second)
        acquireTime := time.Since(acquireStart)
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to acquire V8 context from pool, falling back", "js-execution", map[string]interface{}{
                        "error": err.Error(),
                })
                return s.runTraditional(scriptCtx)
        }</span>
        <span class="cov0" title="0">defer pool.ReleaseContext(eventCtx)

        // Execute the precompiled script
        logging.Debug("Executing precompiled JavaScript script with V8 pool", "js-execution", map[string]interface{}{
                "scriptPath": s.path,
        })

        executeStart := time.Now()
        poolErr := pool.ExecuteScript(eventCtx, s.path, scriptCtx)
        executeTime := time.Since(executeStart)
        
        // Log detailed timing
        logging.Info("JavaScript execution timing", "js-timing", map[string]interface{}{
                "script":        filepath.Base(s.path),
                "pooled":        true,
                "execTimeMs":    executeTime.Milliseconds(),
                "acquireTimeMs": acquireTime.Milliseconds(),
                "totalTimeMs":   time.Since(acquireStart).Milliseconds(),
                "hasErrors":     len(scriptCtx.errors) &gt; 0,
                "errorCount":    len(scriptCtx.errors),
        })
        
        if poolErr != nil </span><span class="cov0" title="0">{
                // Check if it's a cancellation (our custom exception)
                if strings.Contains(poolErr.Error(), "CANCEL") </span><span class="cov0" title="0">{
                        logging.Debug("JavaScript execution cancelled (V8 pool)", "js-execution", map[string]interface{}{
                                "cancelMsg": scriptCtx.cancelMsg,
                        })
                }</span> else<span class="cov0" title="0"> {
                        logging.Debug("JavaScript execution failed (V8 pool)", "js-execution", map[string]interface{}{
                                "error": poolErr.Error(),
                        })
                        return scriptCtx, fmt.Errorf("script error: %w", poolErr)
                }</span>
        }

        <span class="cov0" title="0">logging.Debug("JavaScript execution completed (V8 pool)", "js-execution", map[string]interface{}{
                "hasCancelled": scriptCtx.cancelled,
                "hasErrors":    len(scriptCtx.errors) &gt; 0,
                "errors":       scriptCtx.errors,
        })

        return scriptCtx, nil</span>
}

// runTraditional executes the script using traditional V8 method (fallback)
func (s *Script) runTraditional(scriptCtx *ScriptContext) (*ScriptContext, error) <span class="cov0" title="0">{
        startTime := time.Now()
        
        // Create a new isolate for each script execution to avoid conflicts
        isolate := v8.NewIsolate()
        defer isolate.Dispose()
        
        v8ctx := v8.NewContext(isolate)
        defer v8ctx.Close()
        
        setupTime := time.Since(startTime)

        // Set up the script environment
        if err := setupV8Environment(v8ctx, scriptCtx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Execute the script
        <span class="cov0" title="0">logging.Debug("Executing JavaScript script with V8 (traditional)", "js-execution", map[string]interface{}{
                "hasCompiledScript": s.compiled != nil,
                "scriptPath":        s.path,
        })

        executeStart := time.Now()
        var err error
        if s.compiled != nil </span><span class="cov0" title="0">{
                _, err = s.compiled.Run(v8ctx)
        }</span> else<span class="cov0" title="0"> {
                _, err = v8ctx.RunScript(s.source, s.path)
        }</span>
        <span class="cov0" title="0">executeTime := time.Since(executeStart)

        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a cancellation (our custom exception)
                if strings.Contains(err.Error(), "CANCEL") </span><span class="cov0" title="0">{
                        // This is expected for cancel() calls
                        logging.Debug("JavaScript execution cancelled (V8 traditional)", "js-execution", map[string]interface{}{
                                "cancelMsg": scriptCtx.cancelMsg,
                        })
                }</span> else<span class="cov0" title="0"> {
                        logging.Debug("JavaScript execution failed (V8 traditional)", "js-execution", map[string]interface{}{
                                "error": err.Error(),
                        })
                        return scriptCtx, fmt.Errorf("script error: %w", err)
                }</span>
        }

        // Extract modified data back from JavaScript to Go
        <span class="cov0" title="0">if err := extractModifiedData(v8ctx, scriptCtx); err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to extract modified data from V8", "js-execution", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        // Log detailed timing for traditional execution
        <span class="cov0" title="0">logging.Info("JavaScript execution timing", "js-timing", map[string]interface{}{
                "script":        filepath.Base(s.path),
                "pooled":        false,
                "setupTimeMs":   setupTime.Milliseconds(),
                "execTimeMs":    executeTime.Milliseconds(),
                "totalTimeMs":   time.Since(startTime).Milliseconds(),
                "hasErrors":     len(scriptCtx.errors) &gt; 0,
                "errorCount":    len(scriptCtx.errors),
        })

        logging.Debug("JavaScript execution completed (V8 traditional)", "js-execution", map[string]interface{}{
                "hasCancelled": scriptCtx.cancelled,
                "hasErrors":    len(scriptCtx.errors) &gt; 0,
                "errors":       scriptCtx.errors,
        })

        return scriptCtx, nil</span>
}

// extractModifiedData extracts the modified data object from V8 back to Go
func extractModifiedData(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        // Get the modified data object from JavaScript
        dataValue, err := v8ctx.Global().Get("data")
        if err != nil || dataValue == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert back to JSON and then to Go map
        <span class="cov0" title="0">dataJSON, err := v8.JSONStringify(v8ctx, dataValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse JSON back to bson.M
        <span class="cov0" title="0">var modifiedData bson.M
        if err := json.Unmarshal([]byte(dataJSON), &amp;modifiedData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update the script context data
        <span class="cov0" title="0">sc.data = modifiedData

        return nil</span>
}

// setupV8Environment sets up the JavaScript environment for V8
func setupV8Environment(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        // Debug logging for script context setup
        logging.Debug("Setting up JavaScript environment (V8)", "js-context", map[string]interface{}{
                "dataKeys": getMapKeys(sc.data),
                "hasData":  sc.data != nil,
                "dataLen":  len(sc.data),
        })

        // Convert bson.M to JavaScript object
        if err := setDataObject(v8ctx, sc.data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set up functions
        <span class="cov0" title="0">if err := setupCancelFunctions(v8ctx, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if err := setupValidationFunctions(v8ctx, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if err := setupUserFunctions(v8ctx, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if err := setupUtilityFunctions(v8ctx, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if err := setupRequireFunction(v8ctx, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setDataObject converts bson.M to JavaScript and sets data/this
func setDataObject(v8ctx *v8.Context, data bson.M) error <span class="cov0" title="0">{
        dataJSON, _ := json.Marshal(data)
        dataValue, err := v8.JSONParse(v8ctx, string(dataJSON))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">v8ctx.Global().Set("data", dataValue)
        v8ctx.Global().Set("this", dataValue)
        return nil</span>
}

// setupCancelFunctions sets up cancel(), cancelIf(), cancelUnless()
func setupCancelFunctions(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        
        // cancel() function
        cancelFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                msg := "Request cancelled"
                statusCode := 400
                
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        msg = args[0].String()
                }</span>
                <span class="cov0" title="0">if len(args) &gt; 1 &amp;&amp; args[1].IsNumber() </span><span class="cov0" title="0">{
                        statusCode = int(args[1].Integer())
                }</span>
                
                <span class="cov0" title="0">sc.cancelled = true
                sc.cancelMsg = msg
                sc.statusCode = statusCode
                
                // Throw an exception to stop execution
                exception, _ := v8.NewValue(isolate, "CANCEL")
                isolate.ThrowException(exception)
                return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("cancel", cancelFunc.GetFunction(v8ctx))

        // cancelIf() function
        cancelIfFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return v8.Undefined(isolate)
                }</span>
                
                <span class="cov0" title="0">condition := args[0].Boolean()
                if condition </span><span class="cov0" title="0">{
                        msg := "Request cancelled"
                        statusCode := 400
                        
                        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                msg = args[1].String()
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 2 &amp;&amp; args[2].IsNumber() </span><span class="cov0" title="0">{
                                statusCode = int(args[2].Integer())
                        }</span>
                        
                        <span class="cov0" title="0">sc.cancelled = true
                        sc.cancelMsg = msg
                        sc.statusCode = statusCode
                        
                        exception, _ := v8.NewValue(isolate, "CANCEL")
                        isolate.ThrowException(exception)</span>
                }
                <span class="cov0" title="0">return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("cancelIf", cancelIfFunc.GetFunction(v8ctx))

        // cancelUnless() function
        cancelUnlessFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return v8.Undefined(isolate)
                }</span>
                
                <span class="cov0" title="0">condition := args[0].Boolean()
                if !condition </span><span class="cov0" title="0">{
                        msg := "Request cancelled"
                        statusCode := 400
                        
                        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                msg = args[1].String()
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 2 &amp;&amp; args[2].IsNumber() </span><span class="cov0" title="0">{
                                statusCode = int(args[2].Integer())
                        }</span>
                        
                        <span class="cov0" title="0">sc.cancelled = true
                        sc.cancelMsg = msg
                        sc.statusCode = statusCode
                        
                        exception, _ := v8.NewValue(isolate, "CANCEL")
                        isolate.ThrowException(exception)</span>
                }
                <span class="cov0" title="0">return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("cancelUnless", cancelUnlessFunc.GetFunction(v8ctx))

        return nil</span>
}

// setupValidationFunctions sets up error(), hasErrors()
func setupValidationFunctions(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        
        // error() function
        errorFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                        field := args[0].String()
                        message := args[1].String()
                        sc.errors[field] = message
                }</span>
                <span class="cov0" title="0">return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("error", errorFunc.GetFunction(v8ctx))

        // hasErrors() function
        hasErrorsFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                result, _ := v8.NewValue(isolate, len(sc.errors) &gt; 0)
                return result
        }</span>)
        <span class="cov0" title="0">v8ctx.Global().Set("hasErrors", hasErrorsFunc.GetFunction(v8ctx))

        return nil</span>
}

// setupUserFunctions sets up me, isMe(), query, isRoot
func setupUserFunctions(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        
        // me - current user
        var meValue *v8.Value
        if sc.ctx.IsAuthenticated </span><span class="cov0" title="0">{
                // Create user data from JWT authentication
                userData := map[string]interface{}{
                        "id":       sc.ctx.UserID,
                        "username": sc.ctx.Username,
                        "isRoot":   sc.ctx.IsRoot,
                }
                userJSON, _ := json.Marshal(userData)
                meValue, _ = v8.JSONParse(v8ctx, string(userJSON))
        }</span>
        <span class="cov0" title="0">if meValue == nil </span><span class="cov0" title="0">{
                meValue = v8.Null(isolate)
        }</span>
        <span class="cov0" title="0">v8ctx.Global().Set("me", meValue)

        // isMe() function
        isMeFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) == 0 </span><span class="cov0" title="0">{
                        result, _ := v8.NewValue(isolate, false)
                        return result
                }</span>
                
                <span class="cov0" title="0">id := args[0].String()
                if sc.ctx.IsAuthenticated </span><span class="cov0" title="0">{
                        result, _ := v8.NewValue(isolate, sc.ctx.UserID == id)
                        return result
                }</span>
                <span class="cov0" title="0">result, _ := v8.NewValue(isolate, false)
                return result</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("isMe", isMeFunc.GetFunction(v8ctx))

        // query - request query parameters
        queryJSON, _ := json.Marshal(sc.ctx.Query)
        queryValue, err := v8.JSONParse(v8ctx, string(queryJSON))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">v8ctx.Global().Set("query", queryValue)

        // internal and isRoot
        internalValue, _ := v8.NewValue(isolate, false)
        v8ctx.Global().Set("internal", internalValue)
        
        isRootValue, _ := v8.NewValue(isolate, sc.ctx.IsRoot)
        v8ctx.Global().Set("isRoot", isRootValue)

        return nil</span>
}

// setupUtilityFunctions sets up emit(), dpd, console, protect(), hide(), changed(), previous
func setupUtilityFunctions(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        
        // emit() function
        emitFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                argsSlice := make([]interface{}, len(args))
                for i, arg := range args </span><span class="cov0" title="0">{
                        argsSlice[i] = arg.String()
                }</span>
                <span class="cov0" title="0">fmt.Printf("emit: %v\n", argsSlice)
                return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("emit", emitFunc.GetFunction(v8ctx))

        // dpd object
        dpdObj := v8.NewObjectTemplate(isolate)
        dpdValue, _ := dpdObj.NewInstance(v8ctx)
        v8ctx.Global().Set("dpd", dpdValue)

        // deployd object with logging
        deployedObjTemplate := v8.NewObjectTemplate(isolate)
        logFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return v8.Undefined(isolate)
                }</span>
                
                <span class="cov0" title="0">message := args[0].String()
                var data map[string]interface{}
                
                if len(args) &gt;= 2 &amp;&amp; args[1].IsObject() </span><span class="cov0" title="0">{
                        dataJSON, err := v8.JSONStringify(v8ctx, args[1])
                        if err == nil </span><span class="cov0" title="0">{
                                json.Unmarshal([]byte(dataJSON), &amp;data)
                        }</span>
                }
                
                <span class="cov0" title="0">source := "javascript"
                if sc.ctx != nil &amp;&amp; sc.ctx.Resource != nil </span><span class="cov0" title="0">{
                        source = fmt.Sprintf("js:%s", sc.ctx.Resource.GetName())
                }</span>
                
                <span class="cov0" title="0">logging.Info(message, source, data)
                return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">deployedObjTemplate.Set("log", logFunc)
        deployedObj, _ := deployedObjTemplate.NewInstance(v8ctx)
        v8ctx.Global().Set("deployd", deployedObj)

        // console.log
        consoleObjTemplate := v8.NewObjectTemplate(isolate)
        consoleLogFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                argsSlice := make([]interface{}, len(args))
                for i, arg := range args </span><span class="cov0" title="0">{
                        argsSlice[i] = arg.String()
                }</span>
                <span class="cov0" title="0">message := fmt.Sprintf("JS Console: %v", argsSlice)
                logging.Debug(message, "js-console", nil)
                return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">consoleObjTemplate.Set("log", consoleLogFunc)
        consoleObj, _ := consoleObjTemplate.NewInstance(v8ctx)
        v8ctx.Global().Set("console", consoleObj)

        // protect() and hide() functions
        protectFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        property := args[0].String()
                        delete(sc.data, property)
                }</span>
                <span class="cov0" title="0">return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">v8ctx.Global().Set("protect", protectFunc.GetFunction(v8ctx))
        v8ctx.Global().Set("hide", protectFunc.GetFunction(v8ctx))

        // changed() function
        changedFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                // TODO: Implement change tracking
                result, _ := v8.NewValue(isolate, false)
                return result
        }</span>)
        <span class="cov0" title="0">v8ctx.Global().Set("changed", changedFunc.GetFunction(v8ctx))

        // previous object
        previousObj := v8.NewObjectTemplate(isolate)
        previousValue, _ := previousObj.NewInstance(v8ctx)
        v8ctx.Global().Set("previous", previousValue)

        return nil</span>
}

// setupRequireFunction sets up require() with built-in modules and npm support
func setupRequireFunction(v8ctx *v8.Context, sc *ScriptContext) error <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        
        requireFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return v8.Undefined(isolate)
                }</span>
                
                <span class="cov0" title="0">module := args[0].String()
                
                switch module </span>{
                case "crypto":<span class="cov0" title="0">
                        return createCryptoModule(v8ctx)</span>
                case "util":<span class="cov0" title="0">
                        return createUtilModule(v8ctx)</span>
                case "path":<span class="cov0" title="0">
                        return createPathModule(v8ctx)</span>
                default:<span class="cov0" title="0">
                        // Try to load from npm modules
                        return loadNodeModule(v8ctx, module)</span>
                }
        })
        <span class="cov0" title="0">v8ctx.Global().Set("require", requireFunc.GetFunction(v8ctx))

        return nil</span>
}

// createCryptoModule creates the crypto module for V8
func createCryptoModule(v8ctx *v8.Context) *v8.Value <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        cryptoTemplate := v8.NewObjectTemplate(isolate)
        
        // randomUUID function - simplified UUID-like generation
        randomUUIDFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                // Create a simple UUID-like string
                uuid := fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", 
                        0x12345678, 0x1234, 0x5678, 0x9abc, 0x123456789012)
                result, _ := v8.NewValue(isolate, uuid)
                return result
        }</span>)
        <span class="cov0" title="0">cryptoTemplate.Set("randomUUID", randomUUIDFunc)
        
        // randomBytes function
        randomBytesFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                size := 16
                if len(args) &gt; 0 &amp;&amp; args[0].IsNumber() </span><span class="cov0" title="0">{
                        size = int(args[0].Integer())
                }</span>
                
                // Create a hex string representing random bytes
                <span class="cov0" title="0">hexString := fmt.Sprintf("%0*x", size*2, 0x123456789abcdef0)
                if len(hexString) &gt; size*2 </span><span class="cov0" title="0">{
                        hexString = hexString[:size*2]
                }</span>
                <span class="cov0" title="0">result, _ := v8.NewValue(isolate, hexString)
                return result</span>
        })
        <span class="cov0" title="0">cryptoTemplate.Set("randomBytes", randomBytesFunc)
        
        cryptoObj, _ := cryptoTemplate.NewInstance(v8ctx)
        return cryptoObj.Value</span>
}

// createUtilModule creates the util module for V8
func createUtilModule(v8ctx *v8.Context) *v8.Value <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        utilTemplate := v8.NewObjectTemplate(isolate)
        
        // isArray function
        isArrayFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        result, _ := v8.NewValue(isolate, args[0].IsArray())
                        return result
                }</span>
                <span class="cov0" title="0">result, _ := v8.NewValue(isolate, false)
                return result</span>
        })
        <span class="cov0" title="0">utilTemplate.Set("isArray", isArrayFunc)
        
        // isObject function
        isObjectFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        result, _ := v8.NewValue(isolate, args[0].IsObject() &amp;&amp; !args[0].IsArray())
                        return result
                }</span>
                <span class="cov0" title="0">result, _ := v8.NewValue(isolate, false)
                return result</span>
        })
        <span class="cov0" title="0">utilTemplate.Set("isObject", isObjectFunc)
        
        utilObj, _ := utilTemplate.NewInstance(v8ctx)
        return utilObj.Value</span>
}

// createPathModule creates the path module for V8
func createPathModule(v8ctx *v8.Context) *v8.Value <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        pathTemplate := v8.NewObjectTemplate(isolate)
        
        // extname function
        extnameFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        filePath := args[0].String()
                        parts := strings.Split(filePath, ".")
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                result, _ := v8.NewValue(isolate, "."+parts[len(parts)-1])
                                return result
                        }</span>
                }
                <span class="cov0" title="0">result, _ := v8.NewValue(isolate, "")
                return result</span>
        })
        <span class="cov0" title="0">pathTemplate.Set("extname", extnameFunc)
        
        // basename function
        basenameFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        filePath := args[0].String()
                        parts := strings.Split(filePath, "/")
                        result, _ := v8.NewValue(isolate, parts[len(parts)-1])
                        return result
                }</span>
                <span class="cov0" title="0">result, _ := v8.NewValue(isolate, "")
                return result</span>
        })
        <span class="cov0" title="0">pathTemplate.Set("basename", basenameFunc)
        
        pathObj, _ := pathTemplate.NewInstance(v8ctx)
        return pathObj.Value</span>
}

// loadNodeModule loads npm modules from js-sandbox/node_modules
func loadNodeModule(v8ctx *v8.Context, module string) *v8.Value <span class="cov0" title="0">{
        isolate := v8ctx.Isolate()
        
        // Check for package.json in js-sandbox/node_modules/MODULE
        moduleDir := filepath.Join("js-sandbox", "node_modules", module)
        packageJSONPath := filepath.Join(moduleDir, "package.json")
        
        if _, err := os.Stat(packageJSONPath); err != nil </span><span class="cov0" title="0">{
                // Module not found
                logging.Debug("npm module not found", "js-require", map[string]interface{}{
                        "module":     module,
                        "searchPath": moduleDir,
                })
                return v8.Undefined(isolate)
        }</span>
        
        // Read package.json to find main file
        <span class="cov0" title="0">packageJSON, err := os.ReadFile(packageJSONPath)
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to read package.json", "js-require", map[string]interface{}{
                        "module": module,
                        "error":  err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        <span class="cov0" title="0">var pkg struct {
                Main string `json:"main"`
        }
        if err := json.Unmarshal(packageJSON, &amp;pkg); err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to parse package.json", "js-require", map[string]interface{}{
                        "module": module,
                        "error":  err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        <span class="cov0" title="0">mainFile := pkg.Main
        if mainFile == "" </span><span class="cov0" title="0">{
                mainFile = "index.js"
        }</span>
        
        // Load the main file
        <span class="cov0" title="0">mainPath := filepath.Join(moduleDir, mainFile)
        moduleCode, err := os.ReadFile(mainPath)
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to read module main file", "js-require", map[string]interface{}{
                        "module":   module,
                        "mainPath": mainPath,
                        "error":    err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        // Create a new context for the module execution
        <span class="cov0" title="0">moduleCtx := v8.NewContext(isolate)
        defer moduleCtx.Close()
        
        // Set up minimal Node.js environment for the module
        exportsObj := v8.NewObjectTemplate(isolate)
        exports, _ := exportsObj.NewInstance(moduleCtx)
        moduleCtx.Global().Set("exports", exports)
        
        // Set up module object
        moduleObjTemplate := v8.NewObjectTemplate(isolate)
        moduleObjInstance, _ := moduleObjTemplate.NewInstance(moduleCtx)
        moduleObjInstance.Set("exports", exports)
        moduleCtx.Global().Set("module", moduleObjInstance)
        
        // Set up require function for nested dependencies
        requireFunc := v8.NewFunctionTemplate(isolate, func(info *v8.FunctionCallbackInfo) *v8.Value </span><span class="cov0" title="0">{
                args := info.Args()
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return v8.Undefined(isolate)
                }</span>
                
                <span class="cov0" title="0">depModule := args[0].String()
                // For now, only support direct dependencies, not nested requires
                logging.Debug("Nested require not fully supported", "js-require", map[string]interface{}{
                        "parentModule": module,
                        "dependency":   depModule,
                })
                return v8.Undefined(isolate)</span>
        })
        <span class="cov0" title="0">moduleCtx.Global().Set("require", requireFunc.GetFunction(moduleCtx))
        
        // Execute the module code
        _, err = moduleCtx.RunScript(string(moduleCode), mainPath)
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to execute npm module", "js-require", map[string]interface{}{
                        "module": module,
                        "error":  err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        // Get the exports from the module
        <span class="cov0" title="0">exportsValue, err := moduleCtx.Global().Get("exports")
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to get module exports", "js-require", map[string]interface{}{
                        "module": module,
                        "error":  err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        // Convert exports to JSON and back to ensure it works in the main context
        <span class="cov0" title="0">exportsJSON, err := v8.JSONStringify(moduleCtx, exportsValue)
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to stringify module exports", "js-require", map[string]interface{}{
                        "module": module,
                        "error":  err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        // Parse back in the main context
        <span class="cov0" title="0">result, err := v8.JSONParse(v8ctx, exportsJSON)
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Failed to parse module exports in main context", "js-require", map[string]interface{}{
                        "module": module,
                        "error":  err.Error(),
                })
                return v8.Undefined(isolate)
        }</span>
        
        <span class="cov0" title="0">logging.Debug("Successfully loaded npm module", "js-require", map[string]interface{}{
                "module": module,
        })
        
        return result</span>
}

// IsCancelled returns whether the script execution was cancelled
func (sc *ScriptContext) IsCancelled() bool <span class="cov0" title="0">{
        return sc.cancelled
}</span>

// GetError returns the cancellation error if any
func (sc *ScriptContext) GetError() error <span class="cov0" title="0">{
        if sc.cancelled </span><span class="cov0" title="0">{
                return &amp;ScriptError{
                        Message:    sc.cancelMsg,
                        StatusCode: sc.statusCode,
                }
        }</span>
        <span class="cov0" title="0">if len(sc.errors) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Errors: sc.errors,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ScriptError represents a script cancellation error
type ScriptError struct {
        Message    string
        StatusCode int
}

func (e *ScriptError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// ValidationError represents validation errors from a script
type ValidationError struct {
        Errors map[string]string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        parts := make([]string, 0, len(e.Errors))
        for field, msg := range e.Errors </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%s: %s", field, msg))
        }</span>
        <span class="cov0" title="0">return "validation errors: " + strings.Join(parts, ", ")</span>
}

// Helper function to get map keys for logging
func getMapKeys(data map[string]interface{}) []string <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">keys := make([]string, 0, len(data))
        for k := range data </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package events

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/hjanuschka/go-deployd/internal/logging"
        v8 "rogchap.com/v8go"
)

// V8Pool manages a pool of pre-loaded V8 isolates and contexts for JavaScript events
type V8Pool struct {
        mu        sync.RWMutex
        isolates  []*v8.Isolate
        contexts  []*V8EventContext
        available chan *V8EventContext
        scripts   map[string]string // Source code by file path for per-isolate compilation
        compiled  map[string]map[*v8.Isolate]*v8.UnboundScript // Per-isolate compiled scripts
        poolSize  int
        isShutdown bool
}

// V8EventContext wraps a V8 context with its isolate for reuse
type V8EventContext struct {
        isolate    *v8.Isolate
        context    *v8.Context
        inUse      bool
        lastUsed   time.Time
        execCount  int  // Track number of executions to detect when to refresh
}

var (
        globalV8Pool *V8Pool
        poolOnce     sync.Once
)

// GetV8Pool returns the global V8 pool singleton
func GetV8Pool() *V8Pool <span class="cov1" title="1">{
        poolOnce.Do(func() </span><span class="cov1" title="1">{
                globalV8Pool = NewV8Pool(4) // Default pool size of 4 contexts
        }</span>)
        <span class="cov1" title="1">return globalV8Pool</span>
}

// NewV8Pool creates a new V8 pool with the specified number of contexts
func NewV8Pool(poolSize int) *V8Pool <span class="cov1" title="1">{
        if poolSize &lt;= 0 </span><span class="cov0" title="0">{
                poolSize = 4
        }</span>
        
        <span class="cov1" title="1">pool := &amp;V8Pool{
                isolates:  make([]*v8.Isolate, 0, poolSize),
                contexts:  make([]*V8EventContext, 0, poolSize),
                available: make(chan *V8EventContext, poolSize),
                scripts:   make(map[string]string),
                compiled:  make(map[string]map[*v8.Isolate]*v8.UnboundScript),
                poolSize:  poolSize,
        }
        
        // Initialize the pool
        if err := pool.initialize(); err != nil </span><span class="cov0" title="0">{
                logging.Error("Failed to initialize V8 pool", "v8-pool", map[string]interface{}{
                        "error": err.Error(),
                })
                return nil
        }</span>
        
        <span class="cov1" title="1">logging.Info("V8 pool initialized successfully", "v8-pool", map[string]interface{}{
                "poolSize": poolSize,
        })
        
        return pool</span>
}

// initialize creates and prepares all V8 contexts in the pool
func (pool *V8Pool) initialize() error <span class="cov1" title="1">{
        for i := 0; i &lt; pool.poolSize; i++ </span><span class="cov10" title="4">{
                isolate := v8.NewIsolate()
                context := v8.NewContext(isolate)
                
                eventCtx := &amp;V8EventContext{
                        isolate:  isolate,
                        context:  context,
                        lastUsed: time.Now(),
                }
                
                pool.isolates = append(pool.isolates, isolate)
                pool.contexts = append(pool.contexts, eventCtx)
                pool.available &lt;- eventCtx
        }</span>
        
        <span class="cov1" title="1">return nil</span>
}

// PrecompileScript stores JavaScript source for per-isolate compilation
func (pool *V8Pool) PrecompileScript(filePath, source string) error <span class="cov0" title="0">{
        pool.mu.Lock()
        defer pool.mu.Unlock()
        
        if pool.isShutdown </span><span class="cov0" title="0">{
                return fmt.Errorf("V8 pool is shut down")
        }</span>
        
        // Store source code for per-isolate compilation
        <span class="cov0" title="0">pool.scripts[filePath] = source
        
        // Initialize compiled map for this script
        if pool.compiled[filePath] == nil </span><span class="cov0" title="0">{
                pool.compiled[filePath] = make(map[*v8.Isolate]*v8.UnboundScript)
        }</span>
        
        <span class="cov0" title="0">logging.Debug("JavaScript source stored for compilation", "v8-pool", map[string]interface{}{
                "filePath": filePath,
        })
        
        return nil</span>
}

// LoadScriptsFromDirectory scans a directory and precompiles all JavaScript files
func (pool *V8Pool) LoadScriptsFromDirectory(dir string) error <span class="cov0" title="0">{
        if pool.isShutdown </span><span class="cov0" title="0">{
                return fmt.Errorf("V8 pool is shut down")
        }</span>
        
        <span class="cov0" title="0">return filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if filepath.Ext(path) == ".js" </span><span class="cov0" title="0">{
                        content, readErr := os.ReadFile(path)
                        if readErr != nil </span><span class="cov0" title="0">{
                                logging.Error("Failed to read JavaScript file", "v8-pool", map[string]interface{}{
                                        "error": readErr.Error(),
                                        "path":  path,
                                })
                                return readErr
                        }</span>
                        
                        <span class="cov0" title="0">if compileErr := pool.PrecompileScript(path, string(content)); compileErr != nil </span><span class="cov0" title="0">{
                                logging.Error("Failed to precompile JavaScript file", "v8-pool", map[string]interface{}{
                                        "error": compileErr.Error(),
                                        "path":  path,
                                })
                                return compileErr
                        }</span>
                }
                
                <span class="cov0" title="0">return nil</span>
        })
}

// AcquireContext gets an available V8 context from the pool
func (pool *V8Pool) AcquireContext(timeout time.Duration) (*V8EventContext, error) <span class="cov0" title="0">{
        if pool.isShutdown </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("V8 pool is shut down")
        }</span>
        
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        
        select </span>{
        case eventCtx := &lt;-pool.available:<span class="cov0" title="0">
                eventCtx.inUse = true
                eventCtx.lastUsed = time.Now()
                return eventCtx, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("timeout waiting for available V8 context")</span>
        }
}

// ReleaseContext returns a V8 context to the pool for reuse
func (pool *V8Pool) ReleaseContext(eventCtx *V8EventContext) <span class="cov0" title="0">{
        if pool.isShutdown </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">eventCtx.execCount++
        
        // If context has been used too many times, recreate it to avoid pollution
        if eventCtx.execCount &gt; 1000 </span><span class="cov0" title="0">{
                pool.recreateContext(eventCtx)
        }</span> else<span class="cov0" title="0"> {
                // Reset the context for reuse (less needed now with function wrapping)
                pool.resetContext(eventCtx)
        }</span>
        
        <span class="cov0" title="0">eventCtx.inUse = false
        eventCtx.lastUsed = time.Now()
        
        // Return to pool
        select </span>{
        case pool.available &lt;- eventCtx:<span class="cov0" title="0"></span>
                // Successfully returned to pool
        default:<span class="cov0" title="0">
                // Pool is full (shouldn't happen), log warning
                logging.Error("V8 pool overflow - context not returned", "v8-pool", map[string]interface{}{
                        "poolSize": pool.poolSize,
                })</span>
        }
}

// recreateContext creates a fresh context to avoid global pollution
func (pool *V8Pool) recreateContext(eventCtx *V8EventContext) <span class="cov0" title="0">{
        // Close old context
        if eventCtx.context != nil </span><span class="cov0" title="0">{
                eventCtx.context.Close()
        }</span>
        
        // Create new context with same isolate
        <span class="cov0" title="0">eventCtx.context = v8.NewContext(eventCtx.isolate)
        eventCtx.execCount = 0
        
        logging.Debug("Recreated V8 context to avoid pollution", "v8-pool", map[string]interface{}{
                "reason": "execCount &gt; 100",
        })</span>
}

// resetContext clears the context state for reuse
func (pool *V8Pool) resetContext(eventCtx *V8EventContext) <span class="cov0" title="0">{
        // Get all global property names to clear user-defined variables
        globalObj := eventCtx.context.Global()
        
        // Clear known deployd globals
        deployGlobals := []string{
                "data", "query", "me", "previous", "isRoot", "internal", "errors", 
                "cancelled", "error", "hide", "protect", "cancel", "isMe",
        }
        for _, global := range deployGlobals </span><span class="cov0" title="0">{
                globalObj.Delete(global)
        }</span>
        
        // Clear common npm module globals that might be declared
        <span class="cov0" title="0">npmGlobals := []string{
                "crypto", "bcrypt", "uuid", "lodash", "_", "moment", "axios", 
                "fetch", "Buffer", "process", "require", "module", "exports",
                "nodemailer", "validator", "jsonwebtoken", "jwt", "fs", "path",
        }
        for _, global := range npmGlobals </span><span class="cov0" title="0">{
                globalObj.Delete(global)
        }</span>
        
        // Try to get property names and clear any non-standard globals
        // Note: V8Go doesn't expose PropertyNames, so we clear known problematic ones
        
        // Reset core state
        <span class="cov0" title="0">globalObj.Set("cancelled", false)</span>
}

// ExecuteScript executes a script in the given context (compiles per-isolate if needed)
func (pool *V8Pool) ExecuteScript(eventCtx *V8EventContext, filePath string, scriptCtx *ScriptContext) error <span class="cov0" title="0">{
        pool.mu.Lock()
        source, exists := pool.scripts[filePath]
        if !exists </span><span class="cov0" title="0">{
                pool.mu.Unlock()
                return fmt.Errorf("script not found in pool: %s", filePath)
        }</span>
        
        // Wrap script in function to avoid global variable pollution
        <span class="cov0" title="0">wrappedSource := pool.wrapScriptInFunction(source)
        
        // Check if wrapped script is already compiled for this isolate
        wrappedKey := filePath + "_wrapped"
        var compiled *v8.UnboundScript
        if pool.compiled[wrappedKey] != nil </span><span class="cov0" title="0">{
                compiled = pool.compiled[wrappedKey][eventCtx.isolate]
        }</span>
        
        // Compile for this isolate if not already done
        <span class="cov0" title="0">if compiled == nil </span><span class="cov0" title="0">{
                var err error
                compiled, err = eventCtx.isolate.CompileUnboundScript(wrappedSource, filePath, v8.CompileOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        pool.mu.Unlock()
                        return fmt.Errorf("failed to compile wrapped script for isolate: %w", err)
                }</span>
                
                // Store compiled script for this isolate
                <span class="cov0" title="0">if pool.compiled[wrappedKey] == nil </span><span class="cov0" title="0">{
                        pool.compiled[wrappedKey] = make(map[*v8.Isolate]*v8.UnboundScript)
                }</span>
                <span class="cov0" title="0">pool.compiled[wrappedKey][eventCtx.isolate] = compiled</span>
        }
        <span class="cov0" title="0">pool.mu.Unlock()
        
        // Set up the script environment in the context
        if err := setupV8Environment(eventCtx.context, scriptCtx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Execute the compiled script
        <span class="cov0" title="0">_, err := compiled.Run(eventCtx.context)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Extract modified data back from JavaScript
        <span class="cov0" title="0">return extractModifiedData(eventCtx.context, scriptCtx)</span>
}

// wrapScriptInFunction wraps the script code in an IIFE to avoid global variable pollution
func (pool *V8Pool) wrapScriptInFunction(source string) string <span class="cov0" title="0">{
        return fmt.Sprintf(`
(function() {
        %s
})();
`, source)
}</span>

// GetStats returns statistics about the V8 pool
func (pool *V8Pool) GetStats() map[string]interface{} <span class="cov0" title="0">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()
        
        available := len(pool.available)
        inUse := pool.poolSize - available
        
        return map[string]interface{}{
                "poolSize":         pool.poolSize,
                "available":        available,
                "inUse":           inUse,
                "precompiledScripts": len(pool.scripts),
                "isShutdown":      pool.isShutdown,
        }
}</span>

// Shutdown gracefully shuts down the V8 pool
func (pool *V8Pool) Shutdown() <span class="cov0" title="0">{
        pool.mu.Lock()
        defer pool.mu.Unlock()
        
        if pool.isShutdown </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">pool.isShutdown = true
        close(pool.available)
        
        // Dispose of all contexts and isolates
        for _, eventCtx := range pool.contexts </span><span class="cov0" title="0">{
                if eventCtx.context != nil </span><span class="cov0" title="0">{
                        eventCtx.context.Close()
                }</span>
        }
        
        <span class="cov0" title="0">for _, isolate := range pool.isolates </span><span class="cov0" title="0">{
                if isolate != nil </span><span class="cov0" title="0">{
                        isolate.Dispose()
                }</span>
        }
        
        <span class="cov0" title="0">logging.Info("V8 pool shut down successfully", "v8-pool", nil)</span>
}

// HasPrecompiledScript checks if a script is already precompiled
func (pool *V8Pool) HasPrecompiledScript(filePath string) bool <span class="cov0" title="0">{
        pool.mu.RLock()
        defer pool.mu.RUnlock()
        
        _, exists := pool.scripts[filePath]
        return exists
}</span>

// RemovePrecompiledScript removes a precompiled script (for hot reloading)
func (pool *V8Pool) RemovePrecompiledScript(filePath string) <span class="cov0" title="0">{
        pool.mu.Lock()
        defer pool.mu.Unlock()
        
        delete(pool.scripts, filePath)
        
        logging.Debug("Removed precompiled script", "v8-pool", map[string]interface{}{
                "filePath": filePath,
        })
}</pre>
		
		<pre class="file" id="file24" style="display: none">package logging

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"
)

type LogLevel string

const (
        DEBUG         LogLevel = "debug"
        INFO          LogLevel = "info"
        WARN          LogLevel = "warn"
        ERROR         LogLevel = "error"
        USER_GENERATED LogLevel = "user-generated"
)

type LogEntry struct {
        Timestamp time.Time              `json:"timestamp"`
        Level     LogLevel               `json:"level"`
        Message   string                 `json:"message"`
        Source    string                 `json:"source,omitempty"`
        Data      map[string]interface{} `json:"data,omitempty"`
}

type Logger struct {
        mu     sync.RWMutex
        logDir string
        file   *os.File
}

var globalLogger *Logger
var once sync.Once

func InitializeLogger(logDir string) error <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                globalLogger = &amp;Logger{
                        logDir: logDir,
                }
                
                // Create log directory if it doesn't exist
                if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Failed to create log directory: %v\n", err)
                        return
                }</span>
                
                // Open today's log file
                <span class="cov0" title="0">if err := globalLogger.openLogFile(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Failed to open log file: %v\n", err)
                }</span>
        })
        <span class="cov0" title="0">return nil</span>
}

func GetLogger() *Logger <span class="cov0" title="0">{
        if globalLogger == nil </span><span class="cov0" title="0">{
                // Initialize with default directory if not initialized
                InitializeLogger("./logs")
        }</span>
        <span class="cov0" title="0">return globalLogger</span>
}

// openLogFile opens or creates today's log file
func (l *Logger) openLogFile() error <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        
        // Close existing file if open
        if l.file != nil </span><span class="cov0" title="0">{
                l.file.Close()
        }</span>
        
        // Create filename with today's date
        <span class="cov0" title="0">today := time.Now().Format("2006-01-02")
        filename := filepath.Join(l.logDir, fmt.Sprintf("%s.jsonl", today))
        
        // Open file in append mode, create if it doesn't exist
        file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">l.file = file
        return nil</span>
}

func (l *Logger) Log(level LogLevel, message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        // Console output for event timing
        if source == "event" &amp;&amp; data != nil </span><span class="cov0" title="0">{
                if duration, ok := data["durationMs"]; ok </span><span class="cov0" title="0">{
                        // Skip logging events with 0ms duration
                        if durationMs, ok := duration.(int64); ok &amp;&amp; durationMs &lt;= 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if eventType, ok := data["type"]; ok </span><span class="cov0" title="0">{
                                collection := data["collection"]
                                runtime := data["runtime"]
                                if level == ERROR </span><span class="cov0" title="0">{
                                        fmt.Printf("[%s] ‚ùå %s event on %s (%s runtime) - %vms - ERROR: %v\n", 
                                                time.Now().Format("15:04:05"), eventType, collection, runtime, duration, data["error"])
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("[%s] ‚úÖ %s event on %s (%s runtime) - %vms\n", 
                                                time.Now().Format("15:04:05"), eventType, collection, runtime, duration)
                                }</span>
                        }
                }
        }
        
        // Write to JSON-L log file
        <span class="cov0" title="0">l.writeLogEntry(level, message, source, data)</span>
}

func (l *Logger) writeLogEntry(level LogLevel, message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        
        if l.file == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">entry := LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Message:   message,
                Source:    source,
                Data:      data,
        }
        
        // Marshal to JSON and write to file
        if jsonData, err := json.Marshal(entry); err == nil </span><span class="cov0" title="0">{
                l.file.WriteString(string(jsonData) + "\n")
                l.file.Sync() // Ensure data is written to disk
        }</span>
}

func (l *Logger) Debug(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Log(DEBUG, message, source, data)
}</span>

func (l *Logger) Info(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Log(INFO, message, source, data)
}</span>

func (l *Logger) Warn(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Log(WARN, message, source, data)
}</span>

func (l *Logger) Error(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Log(ERROR, message, source, data)
}</span>

func (l *Logger) UserGenerated(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        l.Log(USER_GENERATED, message, source, data)
}</span>

func (l *Logger) GetLogFiles() ([]string, error) <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        
        if l.logDir == "" </span><span class="cov0" title="0">{
                return []string{}, nil
        }</span>
        
        <span class="cov0" title="0">files, err := os.ReadDir(l.logDir)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>
        
        <span class="cov0" title="0">var logFiles []string
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".jsonl") </span><span class="cov0" title="0">{
                        logFiles = append(logFiles, file.Name())
                }</span>
        }
        
        // Sort files by name (which includes date)
        <span class="cov0" title="0">sort.Strings(logFiles)
        return logFiles, nil</span>
}

func (l *Logger) ReadLogs(filename string, level LogLevel) ([]LogEntry, error) <span class="cov0" title="0">{
        l.mu.RLock()
        defer l.mu.RUnlock()
        
        var logFile string
        if filename == "" </span><span class="cov0" title="0">{
                // Use today's log file if no filename specified
                today := time.Now().Format("2006-01-02")
                logFile = filepath.Join(l.logDir, fmt.Sprintf("%s.jsonl", today))
        }</span> else<span class="cov0" title="0"> {
                logFile = filepath.Join(l.logDir, filename)
        }</span>
        
        <span class="cov0" title="0">file, err := os.Open(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return []LogEntry{}, nil // Return empty if file doesn't exist
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        var logs []LogEntry
        scanner := bufio.NewScanner(file)
        
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">var entry LogEntry
                if err := json.Unmarshal([]byte(line), &amp;entry); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid JSON lines
                }
                
                // Filter by level if specified
                <span class="cov0" title="0">if level != "" &amp;&amp; entry.Level != level </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">logs = append(logs, entry)</span>
        }
        
        <span class="cov0" title="0">return logs, nil</span>
}

func (l *Logger) GetLogPath(filename string) string <span class="cov0" title="0">{
        if filename == "" </span><span class="cov0" title="0">{
                today := time.Now().Format("2006-01-02")
                filename = fmt.Sprintf("%s.jsonl", today)
        }</span>
        <span class="cov0" title="0">return filepath.Join(l.logDir, filename)</span>
}

// Global convenience functions
func Debug(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        GetLogger().Debug(message, source, data)
}</span>

func Info(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        GetLogger().Info(message, source, data)
}</span>

func Warn(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        GetLogger().Warn(message, source, data)
}</span>

func Error(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        GetLogger().Error(message, source, data)
}</span>

func UserGenerated(message string, source string, data map[string]interface{}) <span class="cov0" title="0">{
        GetLogger().UserGenerated(message, source, data)
}</pre>
		
		<pre class="file" id="file25" style="display: none">package metrics

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"
)

type MetricType int

const (
        RequestMetric MetricType = iota
        DatabaseMetric
        HookMetric
        ErrorMetric
)

type Metric struct {
        ID        string                 `json:"id"`
        Type      MetricType             `json:"type"`
        Timestamp time.Time              `json:"timestamp"`
        Duration  time.Duration          `json:"duration"`
        Method    string                 `json:"method,omitempty"`
        Path      string                 `json:"path,omitempty"`
        Status    int                    `json:"status,omitempty"`
        Error     string                 `json:"error,omitempty"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

type AggregatedMetric struct {
        Timestamp    time.Time `json:"timestamp"`
        Collection   string    `json:"collection"`
        Period       string    `json:"period"`
        Count        int64     `json:"count"`
        AvgDuration  float64   `json:"avg_duration"`
        MinDuration  float64   `json:"min_duration"`
        MaxDuration  float64   `json:"max_duration"`
        ErrorCount   int64     `json:"error_count"`
        ErrorRate    float64   `json:"error_rate"`
        RequestCount int64     `json:"request_count"`
        DatabaseOps  int64     `json:"database_ops"`
        HookCalls    int64     `json:"hook_calls"`
}

type MetricsData struct {
        DetailedMetrics []Metric                       `json:"detailed_metrics"`
        HourlyAgg       map[string]AggregatedMetric    `json:"hourly_agg"`
        DailyAgg        map[string]AggregatedMetric    `json:"daily_agg"`
        MonthlyAgg      map[string]AggregatedMetric    `json:"monthly_agg"`
        EventMetrics    map[string][]Metric            `json:"event_metrics"`
        LastSave        time.Time                      `json:"last_save"`
}

type Collector struct {
        mu              sync.RWMutex
        detailedMetrics []Metric
        hourlyAgg       map[string]AggregatedMetric  // key: "collection:hour"
        dailyAgg        map[string]AggregatedMetric  // key: "collection:day"
        monthlyAgg      map[string]AggregatedMetric  // key: "collection:month"
        eventMetrics    map[string][]Metric          // key: "collection.event"
        startTime       time.Time
        dataPath        string
        lastFlush       time.Time
        flushInterval   time.Duration
}

func NewCollector() *Collector <span class="cov0" title="0">{
        c := &amp;Collector{
                detailedMetrics: make([]Metric, 0),
                hourlyAgg:       make(map[string]AggregatedMetric),
                dailyAgg:        make(map[string]AggregatedMetric),
                monthlyAgg:      make(map[string]AggregatedMetric),
                eventMetrics:    make(map[string][]Metric),
                startTime:       time.Now(),
                dataPath:        "resources/metrics.json",
                flushInterval:   5 * time.Minute, // Flush every 5 minutes
                lastFlush:       time.Now(),
        }
        
        // Load existing data on startup
        c.loadFromDisk()
        
        // Start periodic flush routine
        go c.periodicFlush()
        
        return c
}</span>

func (c *Collector) loadFromDisk() <span class="cov0" title="0">{
        if _, err := os.Stat(c.dataPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return // File doesn't exist, start fresh
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(c.dataPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to read metrics file: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">var metricsData MetricsData
        if err := json.Unmarshal(data, &amp;metricsData); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to parse metrics file: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        defer c.mu.Unlock()

        // Restore data, but clean up old entries
        now := time.Now()
        cutoff24h := now.Add(-24 * time.Hour)
        cutoff7d := now.Add(-7 * 24 * time.Hour)
        cutoff6m := now.AddDate(0, -6, 0)
        cutoff12m := now.AddDate(-1, 0, 0)

        // Restore detailed metrics (keep only last 24h)
        for _, metric := range metricsData.DetailedMetrics </span><span class="cov0" title="0">{
                if metric.Timestamp.After(cutoff24h) </span><span class="cov0" title="0">{
                        c.detailedMetrics = append(c.detailedMetrics, metric)
                }</span>
        }

        // Restore hourly aggregations (keep only last 7 days)
        <span class="cov0" title="0">for key, agg := range metricsData.HourlyAgg </span><span class="cov0" title="0">{
                if agg.Timestamp.After(cutoff7d) </span><span class="cov0" title="0">{
                        c.hourlyAgg[key] = agg
                }</span>
        }

        // Restore daily aggregations (keep only last 6 months)
        <span class="cov0" title="0">for key, agg := range metricsData.DailyAgg </span><span class="cov0" title="0">{
                if agg.Timestamp.After(cutoff6m) </span><span class="cov0" title="0">{
                        c.dailyAgg[key] = agg
                }</span>
        }

        // Restore monthly aggregations (keep only last 12 months)
        <span class="cov0" title="0">for key, agg := range metricsData.MonthlyAgg </span><span class="cov0" title="0">{
                if agg.Timestamp.After(cutoff12m) </span><span class="cov0" title="0">{
                        c.monthlyAgg[key] = agg
                }</span>
        }

        // Restore event metrics (keep only last 24h)
        <span class="cov0" title="0">for eventKey, metrics := range metricsData.EventMetrics </span><span class="cov0" title="0">{
                var filteredEvents []Metric
                for _, metric := range metrics </span><span class="cov0" title="0">{
                        if metric.Timestamp.After(cutoff24h) </span><span class="cov0" title="0">{
                                filteredEvents = append(filteredEvents, metric)
                        }</span>
                }
                <span class="cov0" title="0">if len(filteredEvents) &gt; 0 </span><span class="cov0" title="0">{
                        c.eventMetrics[eventKey] = filteredEvents
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("üìä Loaded metrics: %d detailed, %d hourly, %d daily, %d monthly aggregations\n",
                len(c.detailedMetrics), len(c.hourlyAgg), len(c.dailyAgg), len(c.monthlyAgg))</span>
}

func (c *Collector) periodicFlush() <span class="cov0" title="0">{
        ticker := time.NewTicker(c.flushInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.flushToDisk()</span>
                }
        }
}

func (c *Collector) flushToDisk() <span class="cov0" title="0">{
        c.mu.RLock()
        data := MetricsData{
                DetailedMetrics: c.detailedMetrics,
                HourlyAgg:       c.hourlyAgg,
                DailyAgg:        c.dailyAgg,
                MonthlyAgg:      c.monthlyAgg,
                EventMetrics:    c.eventMetrics,
                LastSave:        time.Now(),
        }
        c.mu.RUnlock()

        // Ensure directory exists
        dir := filepath.Dir(c.dataPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to create metrics directory: %v\n", err)
                return
        }</span>

        // Write to temporary file first, then rename (atomic operation)
        <span class="cov0" title="0">tempPath := c.dataPath + ".tmp"
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to marshal metrics data: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(tempPath, jsonData, 0644); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to write metrics file: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">if err := os.Rename(tempPath, c.dataPath); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Failed to rename metrics file: %v\n", err)
                os.Remove(tempPath) // Clean up temp file
                return
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.lastFlush = time.Now()
        c.mu.Unlock()</span>
}

func (c *Collector) RecordMetric(metric Metric) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        metric.ID = generateID()
        metric.Timestamp = time.Now()
        
        // Extract collection from metadata or path
        collection := c.extractCollection(metric)
        
        c.detailedMetrics = append(c.detailedMetrics, metric)
        
        // Store event-specific metrics for hook events
        if metric.Type == HookMetric </span><span class="cov0" title="0">{
                if eventFull, ok := metric.Metadata["event_full"].(string); ok </span><span class="cov0" title="0">{
                        c.eventMetrics[eventFull] = append(c.eventMetrics[eventFull], metric)
                }</span>
        }
        
        <span class="cov0" title="0">c.updateAggregated(metric, collection)
        c.cleanup()</span>
}

func (c *Collector) extractCollection(metric Metric) string <span class="cov0" title="0">{
        // Try metadata first
        if metric.Metadata != nil </span><span class="cov0" title="0">{
                if collection, ok := metric.Metadata["collection"].(string); ok &amp;&amp; collection != "" </span><span class="cov0" title="0">{
                        return collection
                }</span>
        }

        // Try to extract from path
        <span class="cov0" title="0">if metric.Path != "" </span><span class="cov0" title="0">{
                // Remove leading slash and take first segment
                path := metric.Path
                if len(path) &gt; 0 &amp;&amp; path[0] == '/' </span><span class="cov0" title="0">{
                        path = path[1:]
                }</span>
                
                // Split by slash and take first part
                <span class="cov0" title="0">for i, char := range path </span><span class="cov0" title="0">{
                        if char == '/' </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        segment := path[:i]
                                        if segment != "_dashboard" &amp;&amp; segment != "_admin" </span><span class="cov0" title="0">{
                                                return segment
                                        }</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }
                
                // If no slash found, use the whole path (minus leading slash)
                <span class="cov0" title="0">if path != "_dashboard" &amp;&amp; path != "_admin" &amp;&amp; path != "" </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return "system"</span>
}

func (c *Collector) updateAggregated(metric Metric, collection string) <span class="cov0" title="0">{
        now := metric.Timestamp
        
        // Update hourly aggregation
        hour := now.Truncate(time.Hour)
        hourKey := collection + ":" + hour.Format("2006-01-02T15")
        c.updateAggregatedMetric(hourKey, hour, collection, "hourly", metric)
        
        // Update daily aggregation  
        day := now.Truncate(24 * time.Hour)
        dayKey := collection + ":" + day.Format("2006-01-02")
        c.updateAggregatedMetric(dayKey, day, collection, "daily", metric)
        
        // Update monthly aggregation
        month := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        monthKey := collection + ":" + month.Format("2006-01")
        c.updateAggregatedMetric(monthKey, month, collection, "monthly", metric)
}</span>

func (c *Collector) updateAggregatedMetric(key string, timestamp time.Time, collection, period string, metric Metric) <span class="cov0" title="0">{
        var aggMap map[string]AggregatedMetric
        switch period </span>{
        case "hourly":<span class="cov0" title="0">
                aggMap = c.hourlyAgg</span>
        case "daily":<span class="cov0" title="0">
                aggMap = c.dailyAgg</span>
        case "monthly":<span class="cov0" title="0">
                aggMap = c.monthlyAgg</span>
        default:<span class="cov0" title="0">
                return</span>
        }
        
        <span class="cov0" title="0">agg, exists := aggMap[key]
        if !exists </span><span class="cov0" title="0">{
                agg = AggregatedMetric{
                        Timestamp:   timestamp,
                        Collection:  collection,
                        Period:      period,
                        MinDuration: float64(metric.Duration.Nanoseconds()),
                        MaxDuration: float64(metric.Duration.Nanoseconds()),
                }
        }</span>

        <span class="cov0" title="0">agg.Count++
        duration := float64(metric.Duration.Nanoseconds())
        
        // Update average duration
        if agg.Count == 1 </span><span class="cov0" title="0">{
                agg.AvgDuration = duration
        }</span> else<span class="cov0" title="0"> {
                agg.AvgDuration = (agg.AvgDuration*float64(agg.Count-1) + duration) / float64(agg.Count)
        }</span>
        
        // Update min/max duration
        <span class="cov0" title="0">if duration &lt; agg.MinDuration </span><span class="cov0" title="0">{
                agg.MinDuration = duration
        }</span>
        <span class="cov0" title="0">if duration &gt; agg.MaxDuration </span><span class="cov0" title="0">{
                agg.MaxDuration = duration
        }</span>

        // Count by type
        <span class="cov0" title="0">switch metric.Type </span>{
        case RequestMetric:<span class="cov0" title="0">
                agg.RequestCount++
                if metric.Status &gt;= 400 </span><span class="cov0" title="0">{
                        agg.ErrorCount++
                }</span>
        case DatabaseMetric:<span class="cov0" title="0">
                agg.DatabaseOps++
                if metric.Error != "" </span><span class="cov0" title="0">{
                        agg.ErrorCount++
                }</span>
        case HookMetric:<span class="cov0" title="0">
                agg.HookCalls++
                if metric.Error != "" </span><span class="cov0" title="0">{
                        agg.ErrorCount++
                }</span>
        case ErrorMetric:<span class="cov0" title="0">
                agg.ErrorCount++</span>
        }

        // Calculate error rate
        <span class="cov0" title="0">if agg.Count &gt; 0 </span><span class="cov0" title="0">{
                agg.ErrorRate = float64(agg.ErrorCount) / float64(agg.Count) * 100
        }</span>

        <span class="cov0" title="0">aggMap[key] = agg</span>
}

func (c *Collector) cleanup() <span class="cov0" title="0">{
        now := time.Now()
        
        // Clean detailed metrics older than 24 hours
        cutoff24h := now.Add(-24 * time.Hour)
        var filtered []Metric
        for _, metric := range c.detailedMetrics </span><span class="cov0" title="0">{
                if metric.Timestamp.After(cutoff24h) </span><span class="cov0" title="0">{
                        filtered = append(filtered, metric)
                }</span>
        }
        <span class="cov0" title="0">c.detailedMetrics = filtered

        // Clean hourly aggregations older than 7 days
        cutoff7d := now.Add(-7 * 24 * time.Hour)
        for key, agg := range c.hourlyAgg </span><span class="cov0" title="0">{
                if agg.Timestamp.Before(cutoff7d) </span><span class="cov0" title="0">{
                        delete(c.hourlyAgg, key)
                }</span>
        }

        // Clean daily aggregations older than 6 months
        <span class="cov0" title="0">cutoff6m := now.AddDate(0, -6, 0)
        for key, agg := range c.dailyAgg </span><span class="cov0" title="0">{
                if agg.Timestamp.Before(cutoff6m) </span><span class="cov0" title="0">{
                        delete(c.dailyAgg, key)
                }</span>
        }

        // Clean monthly aggregations older than 12 months
        <span class="cov0" title="0">cutoff12m := now.AddDate(-1, 0, 0)
        for key, agg := range c.monthlyAgg </span><span class="cov0" title="0">{
                if agg.Timestamp.Before(cutoff12m) </span><span class="cov0" title="0">{
                        delete(c.monthlyAgg, key)
                }</span>
        }

        // Clean event metrics older than 24 hours
        <span class="cov0" title="0">for eventKey, metrics := range c.eventMetrics </span><span class="cov0" title="0">{
                var filteredEvents []Metric
                for _, metric := range metrics </span><span class="cov0" title="0">{
                        if metric.Timestamp.After(cutoff24h) </span><span class="cov0" title="0">{
                                filteredEvents = append(filteredEvents, metric)
                        }</span>
                }
                <span class="cov0" title="0">if len(filteredEvents) &gt; 0 </span><span class="cov0" title="0">{
                        c.eventMetrics[eventKey] = filteredEvents
                }</span> else<span class="cov0" title="0"> {
                        delete(c.eventMetrics, eventKey)
                }</span>
        }
}

func (c *Collector) GetDetailedMetrics(since time.Time) []Metric <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var result []Metric
        for _, metric := range c.detailedMetrics </span><span class="cov0" title="0">{
                if metric.Timestamp.After(since) </span><span class="cov0" title="0">{
                        result = append(result, metric)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func (c *Collector) GetDetailedMetricsByCollection(collection string, since time.Time) []Metric <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var result []Metric
        for _, metric := range c.detailedMetrics </span><span class="cov0" title="0">{
                if metric.Timestamp.After(since) </span><span class="cov0" title="0">{
                        metricCollection := c.extractCollection(metric)
                        if collection == "overall" || collection == "all" || metricCollection == collection </span><span class="cov0" title="0">{
                                result = append(result, metric)
                        }</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func (c *Collector) GetAggregatedMetrics(period string, collection string, since time.Time) []AggregatedMetric <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        var aggMap map[string]AggregatedMetric
        switch period </span>{
        case "hourly":<span class="cov0" title="0">
                aggMap = c.hourlyAgg</span>
        case "daily":<span class="cov0" title="0">
                aggMap = c.dailyAgg</span>
        case "monthly":<span class="cov0" title="0">
                aggMap = c.monthlyAgg</span>
        default:<span class="cov0" title="0">
                return []AggregatedMetric{}</span>
        }

        <span class="cov0" title="0">var result []AggregatedMetric
        for _, agg := range aggMap </span><span class="cov0" title="0">{
                if agg.Timestamp.After(since) </span><span class="cov0" title="0">{
                        if collection == "overall" || collection == "all" || collection == "" || agg.Collection == collection </span><span class="cov0" title="0">{
                                result = append(result, agg)
                        }</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func (c *Collector) GetEventMetrics(collection string) map[string][]Metric <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if collection == "overall" || collection == "all" || collection == "" </span><span class="cov0" title="0">{
                return c.eventMetrics
        }</span>

        <span class="cov0" title="0">result := make(map[string][]Metric)
        for eventKey, metrics := range c.eventMetrics </span><span class="cov0" title="0">{
                if len(eventKey) &gt; len(collection) &amp;&amp; eventKey[:len(collection)] == collection </span><span class="cov0" title="0">{
                        result[eventKey] = metrics
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func (c *Collector) GetCollections() []string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        collections := make(map[string]bool)
        collections["overall"] = true
        collections["all"] = true
        collections["system"] = true

        // Get collections from recent metrics
        for _, metric := range c.detailedMetrics </span><span class="cov0" title="0">{
                collection := c.extractCollection(metric)
                if collection != "system" </span><span class="cov0" title="0">{
                        collections[collection] = true
                }</span>
        }

        <span class="cov0" title="0">result := make([]string, 0, len(collections))
        for collection := range collections </span><span class="cov0" title="0">{
                result = append(result, collection)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (c *Collector) GetSystemStats() map[string]interface{} <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        now := time.Now()
        uptime := now.Sub(c.startTime)
        
        // Count metrics in last hour
        lastHour := now.Add(-time.Hour)
        var hourlyCount int64
        var hourlyErrors int64
        
        for _, metric := range c.detailedMetrics </span><span class="cov0" title="0">{
                if metric.Timestamp.After(lastHour) </span><span class="cov0" title="0">{
                        hourlyCount++
                        if (metric.Type == RequestMetric &amp;&amp; metric.Status &gt;= 400) ||
                           (metric.Type != RequestMetric &amp;&amp; metric.Error != "") </span><span class="cov0" title="0">{
                                hourlyErrors++
                        }</span>
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "uptime_seconds":       uptime.Seconds(),
                "total_metrics":        len(c.detailedMetrics),
                "hourly_requests":      hourlyCount,
                "hourly_error_rate":    func() float64 </span><span class="cov0" title="0">{
                        if hourlyCount &gt; 0 </span><span class="cov0" title="0">{
                                return float64(hourlyErrors) / float64(hourlyCount) * 100
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }(),
                "aggregated_periods":   len(c.hourlyAgg) + len(c.dailyAgg) + len(c.monthlyAgg),
                "collections":          len(c.GetCollections()),
                "event_types":          len(c.eventMetrics),
        }
}

func generateID() string <span class="cov0" title="0">{
        return time.Now().Format("20060102150405") + "-" + time.Now().Format("000000")
}</pre>
		
		<pre class="file" id="file26" style="display: none">package metrics

import (
        "fmt"
        "net/http"
        "strconv"
        "time"
)

var globalCollector *Collector

func init() <span class="cov0" title="0">{
        globalCollector = NewCollector()
}</span>

func GetGlobalCollector() *Collector <span class="cov0" title="0">{
        return globalCollector
}</span>

type responseWriter struct {
        http.ResponseWriter
        statusCode int
        written    int64
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        n, err := rw.ResponseWriter.Write(b)
        rw.written += int64(n)
        return n, err
}</span>

func HTTPMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                
                rw := &amp;responseWriter{
                        ResponseWriter: w,
                        statusCode:     200,
                }

                next.ServeHTTP(rw, r)

                duration := time.Since(start)
                
                metric := Metric{
                        Type:     RequestMetric,
                        Duration: duration,
                        Method:   r.Method,
                        Path:     r.URL.Path,
                        Status:   rw.statusCode,
                        Metadata: map[string]interface{}{
                                "bytes_written": rw.written,
                                "user_agent":    r.UserAgent(),
                                "remote_addr":   r.RemoteAddr,
                        },
                }

                if rw.statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        metric.Error = "HTTP " + strconv.Itoa(rw.statusCode)
                }</span>

                <span class="cov0" title="0">globalCollector.RecordMetric(metric)</span>
        })
}

func RecordDatabaseOperation(operation string, duration time.Duration, err error) <span class="cov0" title="0">{
        metric := Metric{
                Type:     DatabaseMetric,
                Duration: duration,
                Metadata: map[string]interface{}{
                        "operation": operation,
                },
        }

        if err != nil </span><span class="cov0" title="0">{
                metric.Error = err.Error()
        }</span>

        <span class="cov0" title="0">globalCollector.RecordMetric(metric)</span>
}

func RecordHookExecution(collection, event string, duration time.Duration, err error) <span class="cov0" title="0">{
        metric := Metric{
                Type:     HookMetric,
                Duration: duration,
                Path:     fmt.Sprintf("/%s/%s", collection, event), // For easier filtering
                Metadata: map[string]interface{}{
                        "collection": collection,
                        "event":      event,
                        "event_full": fmt.Sprintf("%s.%s", collection, event), // For detailed event tracking
                },
        }

        if err != nil </span><span class="cov0" title="0">{
                metric.Error = err.Error()
        }</span>

        <span class="cov0" title="0">globalCollector.RecordMetric(metric)</span>
}

func RecordError(errorType string, message string) <span class="cov0" title="0">{
        metric := Metric{
                Type:  ErrorMetric,
                Error: message,
                Metadata: map[string]interface{}{
                        "error_type": errorType,
                },
        }

        globalCollector.RecordMetric(metric)
}</pre>
		
		<pre class="file" id="file27" style="display: none">package resources

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/hjanuschka/go-deployd/internal/database"
        appcontext "github.com/hjanuschka/go-deployd/internal/context"
        "github.com/hjanuschka/go-deployd/internal/events"
        "github.com/hjanuschka/go-deployd/internal/logging"
)

type CollectionConfig struct {
        Properties                map[string]Property                    `json:"properties"`
        EventConfig               map[string]events.EventConfiguration   `json:"eventConfig,omitempty"`
        AllowAdditionalProperties bool                                   `json:"allowAdditionalProperties,omitempty"`
        IsBuiltin                 bool                                   `json:"isBuiltin,omitempty"`
}

type Collection struct {
        *BaseResource
        config           *CollectionConfig
        store            database.StoreInterface
        db               database.DatabaseInterface
        scriptManager    *events.UniversalScriptManager
        hotReloadManager *events.HotReloadGoManager
        configPath       string
}

func NewCollection(name string, config *CollectionConfig, db database.DatabaseInterface) *Collection <span class="cov0" title="0">{
        // Ensure required timestamp fields are present
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;CollectionConfig{Properties: make(map[string]Property)}
        }</span>
        <span class="cov0" title="0">if config.Properties == nil </span><span class="cov0" title="0">{
                config.Properties = make(map[string]Property)
        }</span>
        
        // Add required timestamp fields if not present
        <span class="cov0" title="0">config.Properties["createdAt"] = Property{
                Type:     "date",
                Required: false,
                Default:  "now",
        }
        config.Properties["updatedAt"] = Property{
                Type:     "date", 
                Required: false,
                Default:  "now",
        }
        
        return &amp;Collection{
                BaseResource:     NewBaseResource(name),
                config:           config,
                store:            db.CreateStore(name),
                db:               db,
                scriptManager:    events.NewUniversalScriptManager(),
                hotReloadManager: nil, // Will be initialized when needed
        }</span>
}

func LoadCollectionFromConfig(name, configPath string, db database.DatabaseInterface) (Resource, error) <span class="cov0" title="0">{
        configFile := filepath.Join(configPath, "config.json")
        data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>
        
        <span class="cov0" title="0">var config CollectionConfig
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>
        
        // Check if this is a user collection (special case)
        <span class="cov0" title="0">if name == "users" || name == "user" </span><span class="cov0" title="0">{
                userCollection := NewUserCollection(name, &amp;config, db)
                userCollection.configPath = configPath
                
                // Load event scripts with configuration
                if err := userCollection.scriptManager.LoadScriptsWithConfig(configPath, config.EventConfig); err != nil </span><span class="cov0" title="0">{
                        // Scripts are optional, so don't fail if they don't exist
                        fmt.Printf("Warning: Failed to load scripts for %s: %v\n", name, err)
                }</span>
                
                <span class="cov0" title="0">return userCollection, nil</span>
        }
        
        // Regular collection
        <span class="cov0" title="0">collection := NewCollection(name, &amp;config, db)
        collection.configPath = configPath
        
        // Load event scripts with configuration
        if err := collection.scriptManager.LoadScriptsWithConfig(configPath, config.EventConfig); err != nil </span><span class="cov0" title="0">{
                // Scripts are optional, so don't fail if they don't exist
                fmt.Printf("Warning: Failed to load scripts for %s: %v\n", name, err)
        }</span>
        
        <span class="cov0" title="0">return collection, nil</span>
}

func (c *Collection) Handle(ctx *appcontext.Context) error <span class="cov0" title="0">{
        switch ctx.Method </span>{
        case "GET":<span class="cov0" title="0">
                return c.handleGet(ctx)</span>
        case "POST":<span class="cov0" title="0">
                return c.handlePost(ctx)</span>
        case "PUT":<span class="cov0" title="0">
                return c.handlePut(ctx)</span>
        case "DELETE":<span class="cov0" title="0">
                return c.handleDelete(ctx)</span>
        default:<span class="cov0" title="0">
                return ctx.WriteError(405, "Method not allowed")</span>
        }
}

func (c *Collection) handleGet(ctx *appcontext.Context) error <span class="cov0" title="0">{
        id := ctx.GetID()
        
        // Special endpoints
        if id == "count" </span><span class="cov0" title="0">{
                return c.handleCount(ctx)
        }</span>
        
        // Run BeforeRequest event
        <span class="cov0" title="0">if err := c.runBeforeRequestEvent(ctx, "GET"); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }
        
        <span class="cov0" title="0">if id != "" </span><span class="cov0" title="0">{
                logging.Info("üîç SINGLE DOCUMENT GET REQUEST", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "documentId": id,
                        "query":      ctx.Query,
                })
                
                // Get single document
                query := database.NewQueryBuilder().Where("id", "$eq", id)
                doc, err := c.store.FindOne(ctx.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(500, err.Error())
                }</span>
                <span class="cov0" title="0">if doc == nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(404, "Document not found")
                }</span>
                
                <span class="cov0" title="0">logging.Info("üìÑ DOCUMENT RETRIEVED", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "documentId": id,
                        "dataKeys":   getDataKeys(doc),
                })
                
                // Check for $skipEvents parameter in query to bypass events
                skipEvents := ctx.Query["$skipEvents"] == "true"
                
                logging.Info("üéØ EVENT DECISION", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "skipEvents": skipEvents,
                        "willRunEvent": !skipEvents,
                })
                
                // Run Get event for single document (skip if $skipEvents is true)
                if !skipEvents </span><span class="cov0" title="0">{
                        if err := c.runGetEvent(ctx, doc); err != nil </span><span class="cov0" title="0">{
                                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                                }</span>
                                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
                        }
                }
                
                <span class="cov0" title="0">logging.Info("üì§ RETURNING DOCUMENT", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "documentId": id,
                        "finalData": doc,
                })
                
                return ctx.WriteJSON(doc)</span>
        }
        
        // Get multiple documents
        // Check for $skipEvents parameter in query to bypass events
        <span class="cov0" title="0">skipEvents := ctx.Query["$skipEvents"] == "true"
        
        // First extract query options like $sort, $limit, $skip
        opts, cleanQuery := c.extractQueryOptions(ctx.Query)
        
        // Then sanitize the remaining query and convert to QueryBuilder
        sanitizedQuery := c.sanitizeQuery(cleanQuery)
        query := c.mapToQueryBuilder(sanitizedQuery)
        
        docs, err := c.store.Find(ctx.Context(), query, opts)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        // Run Get event for each document (skip if $skipEvents is true)
        <span class="cov0" title="0">filteredDocs := make([]map[string]interface{}, 0)
        for _, doc := range docs </span><span class="cov0" title="0">{
                if !skipEvents </span><span class="cov0" title="0">{
                        // Create a copy of the document for event processing
                        eventDoc := make(map[string]interface{})
                        for k, v := range doc </span><span class="cov0" title="0">{
                                eventDoc[k] = v
                        }</span>
                        
                        <span class="cov0" title="0">if err := c.runGetEvent(ctx, eventDoc); err != nil </span><span class="cov0" title="0">{
                                // Skip documents that fail the Get event (any error type)
                                // This includes script errors, cancellations, validation failures, etc.
                                continue</span>
                        }
                        
                        // Use the event-processed document as the result
                        <span class="cov0" title="0">filteredDocs = append(filteredDocs, eventDoc)</span>
                } else<span class="cov0" title="0"> {
                        // No events, use original document
                        filteredDocs = append(filteredDocs, doc)
                }</span>
        }
        
        <span class="cov0" title="0">return ctx.WriteJSON(filteredDocs)</span>
}

func (c *Collection) handlePost(ctx *appcontext.Context) error <span class="cov0" title="0">{
        logging.Debug("POST request started", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "requestBodyKeys": getDataKeys(ctx.Body),
                "requestBody":     ctx.Body,
        })

        // Run BeforeRequest event
        if err := c.runBeforeRequestEvent(ctx, "POST"); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }

        <span class="cov0" title="0">logging.Debug("Starting Go validation", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "bodyKeys": getDataKeys(ctx.Body),
                "body":     ctx.Body,
        })

        // Validate and sanitize body
        if err := c.validate(ctx.Body, true); err != nil </span><span class="cov0" title="0">{
                logging.Debug("Go validation failed", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "error": err.Error(),
                })
                return ctx.WriteError(400, err.Error())
        }</span>
        
        <span class="cov0" title="0">logging.Debug("Go validation passed, starting sanitization", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "bodyKeys": getDataKeys(ctx.Body),
                "body":     ctx.Body,
        })
        
        // Check for $skipEvents parameter to bypass all events (before sanitization)
        skipEvents := false
        if val, exists := ctx.Body["$skipEvents"]; exists </span><span class="cov0" title="0">{
                if skip, ok := val.(bool); ok &amp;&amp; skip </span><span class="cov0" title="0">{
                        skipEvents = true
                }</span>
                // Remove $skipEvents from body so it doesn't interfere with validation/sanitization
                <span class="cov0" title="0">delete(ctx.Body, "$skipEvents")</span>
        }
        
        <span class="cov0" title="0">sanitized := c.sanitize(ctx.Body)
        
        logging.Debug("Sanitization complete", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "sanitizedKeys": getDataKeys(sanitized),
                "sanitized":     sanitized,
        })
        
        // Set default values
        c.setDefaults(sanitized)
        
        // Run Validate event (skip if $skipEvents is true)
        if !skipEvents </span><span class="cov0" title="0">{
                if err := c.runValidateEvent(ctx, sanitized); err != nil </span><span class="cov0" title="0">{
                        if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                                return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                        }</span>
                        <span class="cov0" title="0">if validationErr, ok := err.(*events.ValidationError); ok </span><span class="cov0" title="0">{
                                return ctx.WriteError(400, validationErr.Error())
                        }</span>
                        <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
                }
        }
        
        // Run Post event (skip if $skipEvents is true)
        <span class="cov0" title="0">if !skipEvents </span><span class="cov0" title="0">{
                if err := c.runPostEvent(ctx, sanitized); err != nil </span><span class="cov0" title="0">{
                        if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                                return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                        }</span>
                        <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
                }
        }
        
        // Set timestamps after events (cannot be overridden by events)
        <span class="cov0" title="0">c.setTimestamps(sanitized, true)
        
        // Insert document
        result, err := c.store.Insert(ctx.Context(), sanitized)
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Failed to insert document", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "error": err.Error(),
                        "data":  sanitized,
                })
                return ctx.WriteError(500, err.Error())
        }</span>

        // Log successful document creation
        <span class="cov0" title="0">logging.Info("Document created", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "documentId": result,
                "fields":     len(sanitized),
        })
        
        // Run AfterCommit event
        if resultDoc, ok := result.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                go c.runAfterCommitEvent(ctx, resultDoc, "POST")
        }</span>
        
        <span class="cov0" title="0">return ctx.WriteJSON(result)</span>
}

func (c *Collection) handlePut(ctx *appcontext.Context) error <span class="cov0" title="0">{
        id := ctx.GetID()
        if id == "" </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "ID is required for PUT requests")
        }</span>
        
        // Run BeforeRequest event
        <span class="cov0" title="0">if err := c.runBeforeRequestEvent(ctx, "PUT"); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }
        
        // Check if this is a MongoDB command operation
        <span class="cov0" title="0">if c.isMongoCommand(ctx.Body) </span><span class="cov0" title="0">{
                return c.handleMongoCommand(ctx, id)
        }</span>
        
        // Get the existing document for the 'previous' object
        <span class="cov0" title="0">query := database.NewQueryBuilder().Where("id", "$eq", id)
        previous, err := c.store.FindOne(ctx.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        <span class="cov0" title="0">if previous == nil </span><span class="cov0" title="0">{
                return ctx.WriteError(404, "Document not found")
        }</span>
        
        // Check for $skipEvents parameter to bypass all events (before sanitization)
        <span class="cov0" title="0">skipEvents := false
        if val, exists := ctx.Body["$skipEvents"]; exists </span><span class="cov0" title="0">{
                if skip, ok := val.(bool); ok &amp;&amp; skip </span><span class="cov0" title="0">{
                        skipEvents = true
                }</span>
                // Remove $skipEvents from body so it doesn't interfere with validation/sanitization
                <span class="cov0" title="0">delete(ctx.Body, "$skipEvents")</span>
        }
        
        // Validate and sanitize body
        <span class="cov0" title="0">if err := c.validate(ctx.Body, false); err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(400, err.Error())
        }</span>
        
        <span class="cov0" title="0">sanitized := c.sanitize(ctx.Body)
        
        // Check if there are any fields to update after sanitization
        if len(sanitized) == 0 </span><span class="cov0" title="0">{
                // If skipEvents was specified but no actual fields to update, return the existing document
                if skipEvents </span><span class="cov0" title="0">{
                        return ctx.WriteJSON(previous)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(400, "No fields to update")</span>
        }
        
        // Merge with existing document
        <span class="cov0" title="0">merged := make(map[string]interface{})
        for k, v := range previous </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range sanitized </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>
        
        // Run Validate event (skip if $skipEvents is true)
        <span class="cov0" title="0">if !skipEvents </span><span class="cov0" title="0">{
                if err := c.runValidateEvent(ctx, merged); err != nil </span><span class="cov0" title="0">{
                        if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                                return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                        }</span>
                        <span class="cov0" title="0">if validationErr, ok := err.(*events.ValidationError); ok </span><span class="cov0" title="0">{
                                return ctx.WriteError(400, validationErr.Error())
                        }</span>
                        <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
                }
        }
        
        // Run Put event (skip if $skipEvents is true)
        <span class="cov0" title="0">if !skipEvents </span><span class="cov0" title="0">{
                if err := c.runPutEvent(ctx, merged); err != nil </span><span class="cov0" title="0">{
                        if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                                return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                        }</span>
                        <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
                }
        }
        
        // Set timestamps after events (cannot be overridden by events)
        <span class="cov0" title="0">c.setTimestamps(sanitized, false)
        
        // Update document - for SQLite we need to update individual fields, not set the entire data
        updateQuery := database.NewQueryBuilder().Where("id", "$eq", id)
        updateBuilder := database.NewUpdateBuilder()
        updateCount := 0
        for key, value := range sanitized </span><span class="cov0" title="0">{
                // Skip the id field - it should not be updated
                if key != "id" </span><span class="cov0" title="0">{
                        updateBuilder.Set(key, value)
                        updateCount++
                }</span>
        }
        
        // Check if we have any fields to update
        <span class="cov0" title="0">if updateCount == 0 </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "No valid fields to update")
        }</span>
        
        <span class="cov0" title="0">_, err = c.store.Update(ctx.Context(), updateQuery, updateBuilder)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        // Note: We don't check ModifiedCount() because it can be 0 if the document
        // already has the same values, which is a successful operation
        
        // Return updated document
        <span class="cov0" title="0">findQuery := database.NewQueryBuilder().Where("id", "$eq", id)
        doc, err := c.store.FindOne(ctx.Context(), findQuery)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        // Run AfterCommit event
        <span class="cov0" title="0">go c.runAfterCommitEvent(ctx, doc, "PUT")
        
        return ctx.WriteJSON(doc)</span>
}

func (c *Collection) handleDelete(ctx *appcontext.Context) error <span class="cov0" title="0">{
        id := ctx.GetID()
        if id == "" </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "ID is required for DELETE requests")
        }</span>
        
        // Run BeforeRequest event
        <span class="cov0" title="0">if err := c.runBeforeRequestEvent(ctx, "DELETE"); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }
        
        // Get the document to delete
        <span class="cov0" title="0">query := database.NewQueryBuilder().Where("id", "$eq", id)
        doc, err := c.store.FindOne(ctx.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        <span class="cov0" title="0">if doc == nil </span><span class="cov0" title="0">{
                return ctx.WriteError(404, "Document not found")
        }</span>
        
        // Run Delete event
        <span class="cov0" title="0">if err := c.runDeleteEvent(ctx, doc); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }
        
        // Delete the document
        <span class="cov0" title="0">deleteQuery := database.NewQueryBuilder().Where("id", "$eq", id)
        result, err := c.store.Remove(ctx.Context(), deleteQuery)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        <span class="cov0" title="0">if result.DeletedCount() == 0 </span><span class="cov0" title="0">{
                return ctx.WriteError(404, "Document not found")
        }</span>
        
        // Run AfterCommit event
        <span class="cov0" title="0">go c.runAfterCommitEvent(ctx, doc, "DELETE")
        
        return ctx.WriteJSON(map[string]interface{}{
                "deleted": result.DeletedCount(),
        })</span>
}

func (c *Collection) handleCount(ctx *appcontext.Context) error <span class="cov0" title="0">{
        if !ctx.IsRoot </span><span class="cov0" title="0">{
                return ctx.WriteError(403, "Must be root to count")
        }</span>
        
        <span class="cov0" title="0">sanitizedQuery := c.sanitizeQuery(ctx.Query)
        delete(sanitizedQuery, "id") // Remove id from query for count
        countQuery := c.mapToQueryBuilder(sanitizedQuery)
        
        count, err := c.store.Count(ctx.Context(), countQuery)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        <span class="cov0" title="0">return ctx.WriteJSON(map[string]interface{}{
                "count": count,
        })</span>
}

func (c *Collection) validate(data map[string]interface{}, isCreate bool) error <span class="cov0" title="0">{
        if c.config == nil || c.config.Properties == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">errors := make(map[string]string)
        
        for name, prop := range c.config.Properties </span><span class="cov0" title="0">{
                value, exists := data[name]
                
                if !exists || value == nil </span><span class="cov0" title="0">{
                        if prop.Required &amp;&amp; (isCreate || data[name] != nil) </span><span class="cov0" title="0">{
                                errors[name] = "is required"
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                
                <span class="cov0" title="0">if !c.validateType(value, prop.Type) </span><span class="cov0" title="0">{
                        errors[name] = fmt.Sprintf("must be a %s", prop.Type)
                }</span>
        }
        
        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                // Format errors as field: message pairs
                var errorStrings []string
                for field, message := range errors </span><span class="cov0" title="0">{
                        errorStrings = append(errorStrings, fmt.Sprintf("%s: %s", field, message))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("validation errors: %s", strings.Join(errorStrings, ", "))</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

func (c *Collection) validateType(value interface{}, expectedType string) bool <span class="cov0" title="0">{
        switch expectedType </span>{
        case "string":<span class="cov0" title="0">
                _, ok := value.(string)
                return ok</span>
        case "number":<span class="cov0" title="0">
                switch value.(type) </span>{
                case int, int32, int64, float32, float64:<span class="cov0" title="0">
                        return true</span>
                }
                <span class="cov0" title="0">return false</span>
        case "boolean":<span class="cov0" title="0">
                _, ok := value.(bool)
                return ok</span>
        case "date":<span class="cov0" title="0">
                switch value.(type) </span>{
                case time.Time, string:<span class="cov0" title="0">
                        return true</span>
                }
                <span class="cov0" title="0">return false</span>
        case "array":<span class="cov0" title="0">
                return reflect.TypeOf(value).Kind() == reflect.Slice</span>
        case "object":<span class="cov0" title="0">
                _, ok := value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        _, ok = value.(map[string]interface{})
                }</span>
                <span class="cov0" title="0">return ok</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (c *Collection) sanitize(data map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        if c.config == nil || c.config.Properties == nil </span><span class="cov0" title="0">{
                return data
        }</span>
        
        <span class="cov0" title="0">sanitized := make(map[string]interface{})
        
        for name, prop := range c.config.Properties </span><span class="cov0" title="0">{
                if value, exists := data[name]; exists </span><span class="cov0" title="0">{
                        sanitized[name] = c.coerceType(value, prop.Type)
                }</span>
        }
        
        <span class="cov0" title="0">return sanitized</span>
}

// Helper function to get map keys for logging
func getDataKeys(data map[string]interface{}) []string <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">keys := make([]string, 0, len(data))
        for k := range data </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

func (c *Collection) coerceType(value interface{}, targetType string) interface{} <span class="cov0" title="0">{
        switch targetType </span>{
        case "string":<span class="cov0" title="0">
                return fmt.Sprintf("%v", value)</span>
        case "number":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        if num, err := strconv.ParseFloat(str, 64); err == nil </span><span class="cov0" title="0">{
                                return num
                        }</span>
                }
                <span class="cov0" title="0">return value</span>
        case "boolean":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        return str == "true"
                }</span>
                <span class="cov0" title="0">return value</span>
        case "date":<span class="cov0" title="0">
                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                        if t, err := time.Parse(time.RFC3339, str); err == nil </span><span class="cov0" title="0">{
                                return t
                        }</span>
                }
                <span class="cov0" title="0">return value</span>
        default:<span class="cov0" title="0">
                return value</span>
        }
}

func (c *Collection) sanitizeQuery(query map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        if c.config == nil || c.config.Properties == nil </span><span class="cov0" title="0">{
                return query
        }</span>
        
        <span class="cov0" title="0">sanitized := make(map[string]interface{})
        
        for key, value := range query </span><span class="cov0" title="0">{
                // Allow MongoDB operators and id field
                if strings.HasPrefix(key, "$") || key == "id" </span><span class="cov0" title="0">{
                        sanitized[key] = value
                        continue</span>
                }
                
                // Only allow defined properties
                <span class="cov0" title="0">if prop, exists := c.config.Properties[key]; exists </span><span class="cov0" title="0">{
                        sanitized[key] = c.coerceType(value, prop.Type)
                }</span>
        }
        
        <span class="cov0" title="0">return sanitized</span>
}

func (c *Collection) extractQueryOptions(query map[string]interface{}) (database.QueryOptions, map[string]interface{}) <span class="cov0" title="0">{
        opts := database.QueryOptions{
                Sort:   make(map[string]int),
                Fields: make(map[string]int),
        }
        cleanQuery := make(map[string]interface{})
        
        for key, value := range query </span><span class="cov0" title="0">{
                switch key </span>{
                case "$sort", "$orderby":<span class="cov0" title="0">
                        // Handle different value types for sort specification
                        if sortMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for k, v := range sortMap </span><span class="cov0" title="0">{
                                        if sortDir, ok := v.(int); ok </span><span class="cov0" title="0">{
                                                opts.Sort[k] = sortDir
                                        }</span> else<span class="cov0" title="0"> if sortDir, ok := v.(float64); ok </span><span class="cov0" title="0">{
                                                opts.Sort[k] = int(sortDir)
                                        }</span>
                                }
                        }
                case "$limit":<span class="cov0" title="0">
                        if limit, ok := value.(int64); ok </span><span class="cov0" title="0">{
                                opts.Limit = &amp;limit
                        }</span> else<span class="cov0" title="0"> if limitFloat, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                limit := int64(limitFloat)
                                opts.Limit = &amp;limit
                        }</span> else<span class="cov0" title="0"> if limitStr, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if limit, err := strconv.ParseInt(limitStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        opts.Limit = &amp;limit
                                }</span>
                        }
                case "$skip":<span class="cov0" title="0">
                        if skip, ok := value.(int64); ok </span><span class="cov0" title="0">{
                                opts.Skip = &amp;skip
                        }</span> else<span class="cov0" title="0"> if skipFloat, ok := value.(float64); ok </span><span class="cov0" title="0">{
                                skip := int64(skipFloat)
                                opts.Skip = &amp;skip
                        }</span> else<span class="cov0" title="0"> if skipStr, ok := value.(string); ok </span><span class="cov0" title="0">{
                                if skip, err := strconv.ParseInt(skipStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                                        opts.Skip = &amp;skip
                                }</span>
                        }
                case "$fields":<span class="cov0" title="0">
                        // Handle field projection - support both object and string formats
                        if fieldsMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for k, v := range fieldsMap </span><span class="cov0" title="0">{
                                        if include, ok := v.(int); ok </span><span class="cov0" title="0">{
                                                opts.Fields[k] = include
                                        }</span> else<span class="cov0" title="0"> if include, ok := v.(float64); ok </span><span class="cov0" title="0">{
                                                opts.Fields[k] = int(include)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if fieldsStr, ok := value.(string); ok </span><span class="cov0" title="0">{
                                // Handle comma-separated field list like "title,content,id"
                                fields := strings.Split(fieldsStr, ",")
                                for _, field := range fields </span><span class="cov0" title="0">{
                                        field = strings.TrimSpace(field)
                                        if field != "" </span><span class="cov0" title="0">{
                                                opts.Fields[field] = 1
                                        }</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        cleanQuery[key] = value</span>
                }
        }
        
        // Apply default pagination if no limit was specified
        <span class="cov0" title="0">if opts.Limit == nil </span><span class="cov0" title="0">{
                defaultLimit := int64(50) // Default to 50 records per page
                opts.Limit = &amp;defaultLimit
        }</span>
        
        <span class="cov0" title="0">return opts, cleanQuery</span>
}

func (c *Collection) mapToQueryBuilder(query map[string]interface{}) database.QueryBuilder <span class="cov0" title="0">{
        builder := database.NewQueryBuilder()
        
        for field, value := range query </span><span class="cov0" title="0">{
                if strings.HasPrefix(field, "$") </span><span class="cov0" title="0">{
                        // Handle special MongoDB operators at root level
                        continue</span>
                }
                
                <span class="cov0" title="0">if valueMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Field has operators like {"age": {"$gt": 18}}
                        for op, opValue := range valueMap </span><span class="cov0" title="0">{
                                switch op </span>{
                                case "$in":<span class="cov0" title="0">
                                        if values, ok := opValue.([]interface{}); ok </span><span class="cov0" title="0">{
                                                builder.WhereIn(field, values)
                                        }</span>
                                case "$nin":<span class="cov0" title="0">
                                        if values, ok := opValue.([]interface{}); ok </span><span class="cov0" title="0">{
                                                builder.WhereNotIn(field, values)
                                        }</span>
                                default:<span class="cov0" title="0">
                                        builder.Where(field, op, opValue)</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Simple equality
                        builder.Where(field, "$eq", value)
                }</span>
        }
        
        <span class="cov0" title="0">return builder</span>
}

func (c *Collection) setDefaults(data map[string]interface{}) <span class="cov0" title="0">{
        if c.config == nil || c.config.Properties == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">for name, prop := range c.config.Properties </span><span class="cov0" title="0">{
                if _, exists := data[name]; !exists &amp;&amp; prop.Default != nil </span><span class="cov0" title="0">{
                        if prop.Default == "now" &amp;&amp; prop.Type == "date" </span><span class="cov0" title="0">{
                                data[name] = time.Now()
                        }</span> else<span class="cov0" title="0"> {
                                data[name] = prop.Default
                        }</span>
                }
        }
}

// setTimestamps sets createdAt and updatedAt fields, ensuring they cannot be overridden
func (c *Collection) setTimestamps(data map[string]interface{}, isCreate bool) <span class="cov0" title="0">{
        now := time.Now()
        
        if isCreate </span><span class="cov0" title="0">{
                // On creation, always set createdAt to now (cannot be overridden)
                data["createdAt"] = now
        }</span>
        
        // Always set updatedAt to now (cannot be overridden)
        <span class="cov0" title="0">data["updatedAt"] = now</span>
}

// Event runner methods
func (c *Collection) runBeforeRequestEvent(ctx *appcontext.Context, event string) error <span class="cov0" title="0">{
        data := map[string]interface{}{"event": event}
        return c.scriptManager.RunEvent(events.EventBeforeRequest, ctx, data)
}</span>

func (c *Collection) runValidateEvent(ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        logging.Debug("Running validate event", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "dataKeys":   getDataKeys(data),
                "dataValues": data,
                "hasData":    data != nil,
                "dataLen":    len(data),
        })
        
        err := c.scriptManager.RunEvent(events.EventValidate, ctx, data)
        
        if err != nil </span><span class="cov0" title="0">{
                logging.Debug("Validate event returned error", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "error":     err.Error(),
                        "errorType": fmt.Sprintf("%T", err),
                })
        }</span> else<span class="cov0" title="0"> {
                logging.Debug("Validate event completed successfully", fmt.Sprintf("collection:%s", c.name), nil)
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

func (c *Collection) runGetEvent(ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        logging.Info("üî• RUNNING GET EVENT", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                "documentId": data["id"],
                "email":      data["email"],
                "hasScript":  c.scriptManager != nil,
        })
        
        err := c.scriptManager.RunEvent(events.EventGet, ctx, data)
        
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("‚ùå GET EVENT FAILED", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "error": err.Error(),
                })
        }</span> else<span class="cov0" title="0"> {
                logging.Info("‚úÖ GET EVENT COMPLETED", fmt.Sprintf("collection:%s", c.name), map[string]interface{}{
                        "documentId":    data["id"],
                        "modifiedData": data,
                })
        }</span>
        
        <span class="cov0" title="0">return err</span>
}

func (c *Collection) runPostEvent(ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        return c.scriptManager.RunEvent(events.EventPost, ctx, data)
}</span>

func (c *Collection) runPutEvent(ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        return c.scriptManager.RunEvent(events.EventPut, ctx, data)
}</span>

func (c *Collection) runDeleteEvent(ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        return c.scriptManager.RunEvent(events.EventDelete, ctx, data)
}</span>

func (c *Collection) runAfterCommitEvent(ctx *appcontext.Context, data map[string]interface{}, event string) <span class="cov0" title="0">{
        // AfterCommit runs asynchronously and errors are ignored
        c.scriptManager.RunEvent(events.EventAfterCommit, ctx, data)
}</span>

// Hot-reload methods
func (c *Collection) LoadHotReloadScript(eventType events.EventType, source string) error <span class="cov0" title="0">{
        return c.scriptManager.LoadHotReloadScript(eventType, source)
}</span>

func (c *Collection) TestHotReloadScript(eventType events.EventType, ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        return c.scriptManager.RunEvent(eventType, ctx, data)
}</span>

func (c *Collection) TestScript(eventType events.EventType, ctx *appcontext.Context, data map[string]interface{}) error <span class="cov0" title="0">{
        return c.scriptManager.RunEvent(eventType, ctx, data)
}</span>

func (c *Collection) GetHotReloadInfo() map[string]interface{} <span class="cov0" title="0">{
        return c.scriptManager.GetHotReloadInfo()
}</span>

func (c *Collection) GetConfigPath() string <span class="cov0" title="0">{
        return c.configPath
}</span>

func (c *Collection) SetConfigPath(path string) <span class="cov0" title="0">{
        c.configPath = path
}</span>

func (c *Collection) GetScriptManager() *events.UniversalScriptManager <span class="cov0" title="0">{
        return c.scriptManager
}</span>

func (c *Collection) ReloadScripts() error <span class="cov0" title="0">{
        return c.scriptManager.LoadScripts(c.configPath)
}</span>

// isMongoCommand checks if the request body contains MongoDB operators
func (c *Collection) isMongoCommand(body map[string]interface{}) bool <span class="cov0" title="0">{
        for key := range body </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "$") &amp;&amp; key != "$skipEvents" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// handleMongoCommand processes MongoDB command operations
func (c *Collection) handleMongoCommand(ctx *appcontext.Context, id string) error <span class="cov0" title="0">{
        query := database.NewQueryBuilder().Where("id", "$eq", id)
        
        // Get the existing document for events
        previous, err := c.store.FindOne(ctx.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        <span class="cov0" title="0">if previous == nil </span><span class="cov0" title="0">{
                return ctx.WriteError(404, "Document not found")
        }</span>
        
        // Create a copy for the Put event (with anticipated changes)
        <span class="cov0" title="0">merged := make(map[string]interface{})
        for k, v := range previous </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>
        
        // Apply command operations for validation (simulate the changes)
        <span class="cov0" title="0">c.simulateMongoOperations(merged, ctx.Body)
        
        // Run Validate event with simulated changes
        if err := c.runValidateEvent(ctx, merged); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">if validationErr, ok := err.(*events.ValidationError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(400, validationErr.Error())
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }
        
        // Run Put event with simulated changes
        <span class="cov0" title="0">if err := c.runPutEvent(ctx, merged); err != nil </span><span class="cov0" title="0">{
                if scriptErr, ok := err.(*events.ScriptError); ok </span><span class="cov0" title="0">{
                        return ctx.WriteError(scriptErr.StatusCode, scriptErr.Message)
                }</span>
                <span class="cov0" title="0">return ctx.WriteError(500, err.Error())</span>
        }
        
        // Execute the actual MongoDB operation - convert body to UpdateBuilder
        <span class="cov0" title="0">updateBuilder := database.NewUpdateBuilder()
        for op, value := range ctx.Body </span><span class="cov0" title="0">{
                if valueMap, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for field, fieldValue := range valueMap </span><span class="cov0" title="0">{
                                switch op </span>{
                                case "$set":<span class="cov0" title="0">
                                        updateBuilder.Set(field, fieldValue)</span>
                                case "$inc":<span class="cov0" title="0">
                                        updateBuilder.Inc(field, fieldValue)</span>
                                case "$unset":<span class="cov0" title="0">
                                        updateBuilder.Unset(field)</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">result, err := c.store.Update(ctx.Context(), query, updateBuilder)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        <span class="cov0" title="0">if result.ModifiedCount() == 0 </span><span class="cov0" title="0">{
                return ctx.WriteError(404, "Document not found")
        }</span>
        
        // Return updated document
        <span class="cov0" title="0">query = database.NewQueryBuilder().Where("id", "$eq", id)
        doc, err := c.store.FindOne(ctx.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, err.Error())
        }</span>
        
        // Run AfterCommit event
        <span class="cov0" title="0">go c.runAfterCommitEvent(ctx, doc, "PUT")
        
        return ctx.WriteJSON(doc)</span>
}

// simulateMongoOperations applies MongoDB operations to a document for validation
func (c *Collection) simulateMongoOperations(doc map[string]interface{}, operations map[string]interface{}) <span class="cov0" title="0">{
        for op, value := range operations </span><span class="cov0" title="0">{
                switch op </span>{
                case "$inc":<span class="cov0" title="0">
                        if incOps, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for field, incValue := range incOps </span><span class="cov0" title="0">{
                                        if currentVal, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if currentNum, ok := currentVal.(float64); ok </span><span class="cov0" title="0">{
                                                        if incNum, ok := incValue.(float64); ok </span><span class="cov0" title="0">{
                                                                doc[field] = currentNum + incNum
                                                        }</span>
                                                }
                                        }
                                }
                        }
                case "$set":<span class="cov0" title="0">
                        if setOps, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for field, setValue := range setOps </span><span class="cov0" title="0">{
                                        doc[field] = setValue
                                }</span>
                        }
                case "$unset":<span class="cov0" title="0">
                        if unsetOps, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for field := range unsetOps </span><span class="cov0" title="0">{
                                        delete(doc, field)
                                }</span>
                        }
                case "$push":<span class="cov0" title="0">
                        if pushOps, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for field, pushValue := range pushOps </span><span class="cov0" title="0">{
                                        if currentVal, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if currentArray, ok := currentVal.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        doc[field] = append(currentArray, pushValue)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{pushValue}
                                        }</span>
                                }
                        }
                case "$pull":<span class="cov0" title="0">
                        if pullOps, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for field, pullValue := range pullOps </span><span class="cov0" title="0">{
                                        if currentVal, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if currentArray, ok := currentVal.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        newArray := make([]interface{}, 0)
                                                        for _, item := range currentArray </span><span class="cov0" title="0">{
                                                                if !c.valuesEqual(item, pullValue) </span><span class="cov0" title="0">{
                                                                        newArray = append(newArray, item)
                                                                }</span>
                                                        }
                                                        <span class="cov0" title="0">doc[field] = newArray</span>
                                                }
                                        }
                                }
                        }
                case "$addToSet":<span class="cov0" title="0">
                        if addOps, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for field, addValue := range addOps </span><span class="cov0" title="0">{
                                        if currentVal, exists := doc[field]; exists </span><span class="cov0" title="0">{
                                                if currentArray, ok := currentVal.([]interface{}); ok </span><span class="cov0" title="0">{
                                                        found := false
                                                        for _, item := range currentArray </span><span class="cov0" title="0">{
                                                                if c.valuesEqual(item, addValue) </span><span class="cov0" title="0">{
                                                                        found = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                                                doc[field] = append(currentArray, addValue)
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                doc[field] = []interface{}{addValue}
                                        }</span>
                                }
                        }
                }
        }
}

// valuesEqual compares two values for equality (simplified comparison)
func (c *Collection) valuesEqual(a, b interface{}) bool <span class="cov0" title="0">{
        return fmt.Sprintf("%v", a) == fmt.Sprintf("%v", b)
}</span>

// GetConfig returns the collection configuration
func (c *Collection) GetConfig() *CollectionConfig <span class="cov0" title="0">{
        return c.config
}</pre>
		
		<pre class="file" id="file28" style="display: none">package resources

import (
        "github.com/hjanuschka/go-deployd/internal/context"
)

// Resource represents a deployable resource that can handle HTTP requests
type Resource interface {
        GetName() string
        GetPath() string
        Handle(ctx *context.Context) error
}

// Property defines a field in a collection schema
type Property struct {
        Type     string      `json:"type"`
        Required bool        `json:"required,omitempty"`
        Default  interface{} `json:"default,omitempty"`
        Order    int         `json:"order,omitempty"`
        Unique   bool        `json:"unique,omitempty"`
        System   bool        `json:"system,omitempty"` // Indicates if this is a system-managed field
}

// BaseResource provides common functionality for all resources
type BaseResource struct {
        name string
        path string
}

func NewBaseResource(name string) *BaseResource <span class="cov0" title="0">{
        return &amp;BaseResource{
                name: name,
                path: "/" + name,
        }
}</span>

func (r *BaseResource) GetName() string <span class="cov0" title="0">{
        return r.name
}</span>

func (r *BaseResource) GetPath() string <span class="cov0" title="0">{
        return r.path
}</span>

func (r *BaseResource) Handle(ctx *context.Context) error <span class="cov0" title="0">{
        return ctx.WriteError(501, "Not implemented")
}</pre>
		
		<pre class="file" id="file29" style="display: none">package resources

import (
        "crypto/rand"
        "encoding/hex"
        "errors"
        "time"

        "github.com/hjanuschka/go-deployd/internal/config"
        "github.com/hjanuschka/go-deployd/internal/database"
        appcontext "github.com/hjanuschka/go-deployd/internal/context"
        emailpkg "github.com/hjanuschka/go-deployd/internal/email"
        "github.com/hjanuschka/go-deployd/internal/logging"
        "golang.org/x/crypto/bcrypt"
)

// UserCollection extends Collection with authentication capabilities
type UserCollection struct {
        *Collection
        securityConfig *config.SecurityConfig
        emailService   *emailpkg.EmailService
}

// UserSessionData represents the session data stored for authenticated users
type UserSessionData struct {
        UserID    string    `json:"userId"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Role      string    `json:"role"`
        LoginTime time.Time `json:"loginTime"`
        Token     string    `json:"token"`
}

// NewUserCollection creates a new user collection with authentication capabilities
func NewUserCollection(name string, collectionConfig *CollectionConfig, db database.DatabaseInterface) *UserCollection <span class="cov0" title="0">{
        collection := NewCollection(name, collectionConfig, db)
        
        // Load security configuration
        securityConfig, err := config.LoadSecurityConfig(config.GetConfigDir())
        if err != nil </span><span class="cov0" title="0">{
                // Use default config if loading fails
                securityConfig = config.DefaultSecurityConfig()
        }</span>
        
        // Create email service
        <span class="cov0" title="0">emailService := emailpkg.NewEmailService(&amp;securityConfig.Email)
        
        return &amp;UserCollection{
                Collection:     collection,
                securityConfig: securityConfig,
                emailService:   emailService,
        }</span>
}

// Handle extends the base collection handler with authentication endpoints
func (uc *UserCollection) Handle(ctx *appcontext.Context) error <span class="cov0" title="0">{
        logging.Info("üî• USER COLLECTION HANDLE", "user-collection", map[string]interface{}{
                "method": ctx.Method,
                "path":   ctx.Request.URL.Path,
                "id":     ctx.GetID(),
        })
        
        // Handle special authentication endpoints
        if ctx.Method == "POST" </span><span class="cov0" title="0">{
                switch ctx.GetID() </span>{
                case "login":<span class="cov0" title="0">
                        return uc.handleLogin(ctx)</span>
                case "logout":<span class="cov0" title="0">
                        return uc.handleLogout(ctx)</span>
                case "generate-token":<span class="cov0" title="0">
                        return uc.handleGenerateToken(ctx)</span>
                }
        }
        
        // Handle /me endpoint for current user
        <span class="cov0" title="0">if ctx.Method == "GET" &amp;&amp; ctx.GetID() == "me" </span><span class="cov0" title="0">{
                return uc.handleMe(ctx)
        }</span>
        
        // Handle user registration (POST to collection without ID)
        <span class="cov0" title="0">if ctx.Method == "POST" &amp;&amp; ctx.GetID() == "" </span><span class="cov0" title="0">{
                return uc.handleRegister(ctx)
        }</span>
        
        // For all other requests, delegate to base collection
        <span class="cov0" title="0">return uc.Collection.Handle(ctx)</span>
}

// handleLogin authenticates a user and creates a session
// DEPRECATED: This endpoint is deprecated. Use /auth/login with JWT tokens instead.
func (uc *UserCollection) handleLogin(ctx *appcontext.Context) error <span class="cov0" title="0">{
        ctx.Response.WriteHeader(410)
        return ctx.WriteJSON(map[string]interface{}{
                "error":   "Gone",
                "message": "This login endpoint is deprecated. Please use /auth/login with JWT authentication instead.",
                "redirect": "/auth/login",
        })
}</span>

// handleLogout clears the user session
// DEPRECATED: This endpoint is deprecated. JWT tokens expire automatically.
func (uc *UserCollection) handleLogout(ctx *appcontext.Context) error <span class="cov0" title="0">{
        ctx.Response.WriteHeader(410)
        return ctx.WriteJSON(map[string]interface{}{
                "error":   "Gone",
                "message": "This logout endpoint is deprecated. JWT tokens expire automatically. Simply delete the client-side token.",
                "info":    "JWT tokens are stateless and expire automatically based on server configuration.",
        })
}</span>

// handleMe returns the current user's information
// DEPRECATED: This endpoint is deprecated. Use /auth/me instead.
func (uc *UserCollection) handleMe(ctx *appcontext.Context) error <span class="cov0" title="0">{
        ctx.Response.WriteHeader(410)
        return ctx.WriteJSON(map[string]interface{}{
                "error":   "Gone", 
                "message": "This endpoint is deprecated. Please use /auth/me with JWT authentication instead.",
                "redirect": "/auth/me",
        })
}</span>

// handleRegister creates a new user account
func (uc *UserCollection) handleRegister(ctx *appcontext.Context) error <span class="cov0" title="0">{
        // Check if registration is allowed
        if !uc.securityConfig.AllowRegistration </span><span class="cov0" title="0">{
                return ctx.WriteError(403, "User registration is disabled. Please contact administrator.")
        }</span>
        
        // Get registration data from context body (already parsed)
        <span class="cov0" title="0">userData := ctx.Body
        if userData == nil || len(userData) == 0 </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "Request body is required")
        }</span>
        
        // Validate required fields
        <span class="cov0" title="0">password, ok := userData["password"].(string)
        if !ok || password == "" </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "Password is required")
        }</span>
        
        <span class="cov0" title="0">email, hasEmail := userData["email"].(string)
        username, hasUsername := userData["username"].(string)
        
        if !hasEmail &amp;&amp; !hasUsername </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "Username or email is required")
        }</span>
        
        // Email is required for verification
        <span class="cov0" title="0">if !hasEmail || email == "" </span><span class="cov0" title="0">{
                return ctx.WriteError(400, "Email is required for user registration")
        }</span>
        
        // Check if user already exists
        <span class="cov0" title="0">if hasEmail </span><span class="cov0" title="0">{
                query := database.NewQueryBuilder().Where("email", "$eq", email)
                existing, err := uc.store.FindOne(ctx.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(500, "Database error")
                }</span>
                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(409, "User with this email already exists")
                }</span>
        }
        
        <span class="cov0" title="0">if hasUsername </span><span class="cov0" title="0">{
                query := database.NewQueryBuilder().Where("username", "$eq", username)
                existing, err := uc.store.FindOne(ctx.Context(), query)
                if err != nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(500, "Database error")
                }</span>
                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(409, "User with this username already exists")
                }</span>
        }
        
        // Hash password
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), 12)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.WriteError(500, "Failed to hash password")
        }</span>
        
        <span class="cov0" title="0">userData["password"] = string(hashedPassword)
        
        // Set default role if not provided
        if _, hasRole := userData["role"]; !hasRole </span><span class="cov0" title="0">{
                userData["role"] = "user"
        }</span>
        
        // If email verification is required, set user as inactive and generate verification token
        <span class="cov0" title="0">if uc.securityConfig.RequireVerification &amp;&amp; uc.emailService.IsConfigured() </span><span class="cov0" title="0">{
                // Generate verification token
                verificationToken, err := emailpkg.GenerateVerificationToken()
                if err != nil </span><span class="cov0" title="0">{
                        return ctx.WriteError(500, "Failed to generate verification token")
                }</span>
                
                // Set verification fields
                <span class="cov0" title="0">userData["active"] = false
                userData["isVerified"] = false
                userData["verificationToken"] = verificationToken
                userData["verificationExpires"] = time.Now().Add(24 * time.Hour)
                
                // Delegate to base collection for validation and creation
                ctx.Body = userData
                if err := uc.Collection.handlePost(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Send verification email (do this after successful user creation)
                <span class="cov0" title="0">baseURL := "http://localhost:" + ctx.Request.Host // Get base URL from request
                if err := uc.emailService.SendVerificationEmail(email, username, verificationToken, baseURL); err != nil </span>{<span class="cov0" title="0">
                        // Log the error but don't fail the registration
                        // User can request resend later
                        // TODO: Add proper logging
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                // No email verification required, set user as active
                userData["active"] = true
                userData["isVerified"] = true
                
                // Delegate to base collection for validation and creation
                ctx.Body = userData
                return uc.Collection.handlePost(ctx)
        }</span>
}

// handleGenerateToken generates a static API token for a user
func (uc *UserCollection) handleGenerateToken(ctx *appcontext.Context) error <span class="cov0" title="0">{
        if !ctx.IsAuthenticated </span><span class="cov0" title="0">{
                return ctx.WriteError(401, "Not authenticated")
        }</span>
        
        // DEPRECATED: This endpoint is deprecated. Use JWT-based authentication instead.
        <span class="cov0" title="0">ctx.Response.WriteHeader(410)
        return ctx.WriteJSON(map[string]interface{}{
                "error":   "Gone",
                "message": "This endpoint is deprecated. Use JWT authentication for API access.",
                "info":    "JWT tokens provide secure, stateless authentication without requiring server-side token management.",
        })</span>
}

// generateToken generates a session token
func (uc *UserCollection) generateToken() string <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// generateStaticToken generates a longer-lived API token
func (uc *UserCollection) generateStaticToken() string <span class="cov0" title="0">{
        bytes := make([]byte, 48)
        rand.Read(bytes)
        return "tk_" + hex.EncodeToString(bytes)
}</span>

// getStringField safely gets a string field from a map
func getStringField(data map[string]interface{}, field string) string <span class="cov0" title="0">{
        if val, ok := data[field].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// AuthenticateToken validates a static API token and returns user data
func (uc *UserCollection) AuthenticateToken(token string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return nil, errors.New("token is required")
        }</span>
        
        <span class="cov0" title="0">query := database.NewQueryBuilder().Where("apiToken", "$eq", token)
        user, err := uc.store.FindOne(nil, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>
        
        <span class="cov0" title="0">return user, nil</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package router

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/hjanuschka/go-deployd/internal/auth"
        "github.com/hjanuschka/go-deployd/internal/config"
        "github.com/hjanuschka/go-deployd/internal/context"
        "github.com/hjanuschka/go-deployd/internal/database"
        "github.com/hjanuschka/go-deployd/internal/resources"
)

type Router struct {
        resources     []resources.Resource
        db            database.DatabaseInterface
        development   bool
        configPath    string
        jwtManager    *auth.JWTManager
}

func New(db database.DatabaseInterface, development bool, configPath string) *Router <span class="cov3" title="2">{
        // Load security config to set up JWT
        var jwtManager *auth.JWTManager
        securityConfig, err := config.LoadSecurityConfig(config.GetConfigDir())
        if err == nil </span><span class="cov3" title="2">{
                jwtDuration, err := time.ParseDuration(securityConfig.JWTExpiration)
                if err != nil </span><span class="cov0" title="0">{
                        jwtDuration = 24 * time.Hour
                }</span>
                <span class="cov3" title="2">jwtManager = auth.NewJWTManager(securityConfig.JWTSecret, jwtDuration)</span>
        }

        <span class="cov3" title="2">r := &amp;Router{
                db:          db,
                development: development,
                configPath:  configPath,
                jwtManager:  jwtManager,
        }
        
        r.loadResources()
        
        return r</span>
}

func (r *Router) loadResources() <span class="cov3" title="2">{
        if r.configPath == "" </span><span class="cov3" title="2">{
                r.configPath = "./resources"
        }</span>
        
        // Always create built-in users collection first
        <span class="cov3" title="2">r.createBuiltinUsersCollection()
        
        // Create default collection resources if config path exists
        if _, err := os.Stat(r.configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create a default "todos" collection for demo purposes
                todosCollection := resources.NewCollection("todos", &amp;resources.CollectionConfig{
                        Properties: map[string]resources.Property{
                                "title": {
                                        Type:     "string",
                                        Required: true,
                                },
                                "completed": {
                                        Type:    "boolean",
                                        Default: false,
                                },
                                "createdAt": {
                                        Type:    "date",
                                        Default: "now",
                                },
                        },
                }, r.db)
                
                r.resources = append(r.resources, todosCollection)
                return
        }</span>
        
        // Load resources from config directory
        <span class="cov3" title="2">err := filepath.Walk(r.configPath, func(path string, info os.FileInfo, err error) error </span><span class="cov7" title="8">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov7" title="8">if info.IsDir() &amp;&amp; path != r.configPath </span><span class="cov5" title="4">{
                        // This is a resource directory
                        resourceName := filepath.Base(path)
                        configFile := filepath.Join(path, "config.json")
                        
                        if _, err := os.Stat(configFile); err == nil </span><span class="cov3" title="2">{
                                // Load collection resource
                                collection, err := resources.LoadCollectionFromConfig(resourceName, path, r.db)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to load collection %s: %v", resourceName, err)
                                        return nil
                                }</span>
                                
                                <span class="cov3" title="2">r.resources = append(r.resources, collection)</span>
                        }
                }
                
                <span class="cov7" title="8">return nil</span>
        })
        
        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to load resources: %v", err)
        }</span>
        
        <span class="cov3" title="2">r.sortResources()</span>
}

func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        // Enable CORS
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if req.Method == "OPTIONS" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>
        
        // Check for authentication (JWT token or master key only)
        <span class="cov0" title="0">isAuthenticated := false
        isRoot := false
        userID := ""
        username := ""

        // 1. Check JWT token authentication
        authHeader := req.Header.Get("Authorization")
        if authHeader != "" &amp;&amp; strings.HasPrefix(authHeader, "Bearer ") &amp;&amp; r.jwtManager != nil </span><span class="cov0" title="0">{
                token := strings.TrimPrefix(authHeader, "Bearer ")
                if claims, err := r.jwtManager.ValidateToken(token); err == nil </span><span class="cov0" title="0">{
                        isAuthenticated = true
                        isRoot = claims.IsRoot
                        userID = claims.UserID
                        username = claims.Username
                }</span>
        }

        // 2. Check for master key authentication (fallback for admin operations)
        <span class="cov0" title="0">if !isAuthenticated </span><span class="cov0" title="0">{
                masterKey := req.Header.Get("X-Master-Key")
                if masterKey != "" </span><span class="cov0" title="0">{
                        // Load security config to validate master key
                        securityConfig, err := config.LoadSecurityConfig(config.GetConfigDir())
                        if err == nil &amp;&amp; securityConfig.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                                isAuthenticated = true
                                isRoot = true
                                userID = "root"
                                username = "root"
                        }</span>
                }
        }
        
        // Find matching resource
        <span class="cov0" title="0">resource := r.findMatchingResource(req.URL.Path)
        if resource == nil </span><span class="cov0" title="0">{
                http.Error(w, "Resource not found", http.StatusNotFound)
                return
        }</span>
        
        // Create context with authentication data
        <span class="cov0" title="0">authData := &amp;context.AuthData{
                UserID:       userID,
                Username:     username,
                IsRoot:       isRoot,
                IsAuthenticated: isAuthenticated,
        }
        ctx := context.New(req, w, resource, authData, r.development)
        
        // Handle the request
        if err := resource.Handle(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Resource handler error: %v", err)
                ctx.WriteError(500, err.Error())
        }</span>
}

func (r *Router) findMatchingResource(path string) resources.Resource <span class="cov0" title="0">{
        for _, resource := range r.resources </span><span class="cov0" title="0">{
                if r.pathMatches(path, resource.GetPath()) </span><span class="cov0" title="0">{
                        return resource
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *Router) pathMatches(requestPath, resourcePath string) bool <span class="cov0" title="0">{
        if resourcePath == "/" </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Remove trailing slash from resource path
        <span class="cov0" title="0">resourcePath = strings.TrimSuffix(resourcePath, "/")
        
        return strings.HasPrefix(requestPath, resourcePath)</span>
}

func (r *Router) GetResources() []resources.Resource <span class="cov0" title="0">{
        return r.resources
}</span>

func (r *Router) AddResource(resource resources.Resource) <span class="cov0" title="0">{
        r.resources = append(r.resources, resource)
        r.sortResources()
}</span>

func (r *Router) UpdateResource(name string, resource resources.Resource) <span class="cov0" title="0">{
        for i, res := range r.resources </span><span class="cov0" title="0">{
                if res.GetName() == name </span><span class="cov0" title="0">{
                        r.resources[i] = resource
                        break</span>
                }
        }
        <span class="cov0" title="0">r.sortResources()</span>
}

func (r *Router) RemoveResource(name string) <span class="cov0" title="0">{
        for i, res := range r.resources </span><span class="cov0" title="0">{
                if res.GetName() == name </span><span class="cov0" title="0">{
                        r.resources = append(r.resources[:i], r.resources[i+1:]...)
                        break</span>
                }
        }
}

func (r *Router) GetCollection(name string) *resources.Collection <span class="cov0" title="0">{
        for _, res := range r.resources </span><span class="cov0" title="0">{
                if res.GetName() == name </span><span class="cov0" title="0">{
                        if collection, ok := res.(*resources.Collection); ok </span><span class="cov0" title="0">{
                                return collection
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *Router) sortResources() <span class="cov3" title="2">{
        // Sort resources by path specificity (longer paths first)
        sort.Slice(r.resources, func(i, j int) bool </span><span class="cov3" title="2">{
                return len(strings.Split(r.resources[i].GetPath(), "/")) &gt; len(strings.Split(r.resources[j].GetPath(), "/"))
        }</span>)
}

// createBuiltinUsersCollection creates the built-in users collection with default fields
func (r *Router) createBuiltinUsersCollection() <span class="cov3" title="2">{
        // Define the current built-in schema for users collection
        currentBuiltinSchema := map[string]resources.Property{
                "username": {
                        Type:     "string",
                        Required: true,
                        Unique:   true,
                        System:   true, // Mark as system field
                },
                "email": {
                        Type:     "string", 
                        Required: true,
                        Unique:   true,
                        System:   true, // Mark as system field
                },
                "password": {
                        Type:     "string",
                        Required: true,
                        System:   true, // Mark as system field
                },
                "role": {
                        Type:    "string",
                        Default: "user",
                        System:  true, // Mark as system field
                },
                "active": {
                        Type:    "boolean",
                        Default: false, // Users start inactive until email verification
                        System:  true,  // Mark as system field
                },
                "isVerified": {
                        Type:    "boolean",
                        Default: false,
                        System:  true, // Mark as system field
                },
                "verificationToken": {
                        Type:   "string",
                        System: true, // Mark as system field
                },
                "verificationExpires": {
                        Type:   "date",
                        System: true, // Mark as system field
                },
                "createdAt": {
                        Type:    "date",
                        Default: "now",
                        System:  true, // Mark as system field
                },
                "updatedAt": {
                        Type:    "date", 
                        Default: "now",
                        System:  true, // Mark as system field
                },
        }
        
        // Check if users collection config already exists and migrate if needed
        usersConfigPath := filepath.Join(r.configPath, "users")
        configFile := filepath.Join(usersConfigPath, "config.json")
        
        var finalConfig *resources.CollectionConfig
        
        if _, err := os.Stat(configFile); err == nil </span><span class="cov3" title="2">{
                // Existing config found - perform migration
                log.Printf("üîÑ Found existing users collection, checking for schema migration...")
                finalConfig = r.migrateBuiltinCollection(configFile, currentBuiltinSchema)
        }</span> else<span class="cov0" title="0"> {
                // No existing config - create new one with built-in schema
                log.Printf("üì¶ Creating new built-in users collection...")
                finalConfig = &amp;resources.CollectionConfig{
                        Properties:                currentBuiltinSchema,
                        AllowAdditionalProperties: true,
                        IsBuiltin:                 true,
                }
                
                // Save the initial config file
                if err := r.saveCollectionConfig(usersConfigPath, finalConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to save users collection config: %v", err)
                }</span>
        }
        
        // Create UserCollection with the final config
        <span class="cov3" title="2">usersCollection := resources.NewUserCollection("users", finalConfig, r.db)
        
        // CRITICAL: Set the configPath and load event scripts for built-in users collection
        usersCollection.Collection.SetConfigPath(usersConfigPath)
        
        // Load event scripts if the users directory exists
        if _, err := os.Stat(usersConfigPath); err == nil </span><span class="cov3" title="2">{
                log.Printf("üî• LOADING EVENT SCRIPTS FOR BUILT-IN USERS COLLECTION...")
                if err := usersCollection.Collection.GetScriptManager().LoadScriptsWithConfig(usersConfigPath, finalConfig.EventConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ùå Failed to load event scripts for users collection: %v", err)
                }</span> else<span class="cov3" title="2"> {
                        log.Printf("‚úÖ Successfully loaded event scripts for built-in users collection")
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("‚ö†Ô∏è Users config directory not found: %s", usersConfigPath)
        }</span>
        
        <span class="cov3" title="2">r.resources = append(r.resources, usersCollection)</span>
}

// migrateBuiltinCollection handles schema migration for built-in collections
func (r *Router) migrateBuiltinCollection(configFile string, currentBuiltinSchema map[string]resources.Property) *resources.CollectionConfig <span class="cov3" title="2">{
        // Read existing config
        data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to read existing config, creating new one: %v", err)
                return &amp;resources.CollectionConfig{
                        Properties:                currentBuiltinSchema,
                        AllowAdditionalProperties: true,
                        IsBuiltin:                 true,
                }
        }</span>
        
        <span class="cov3" title="2">var existingConfig resources.CollectionConfig
        if err := json.Unmarshal(data, &amp;existingConfig); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to parse existing config, creating new one: %v", err)
                return &amp;resources.CollectionConfig{
                        Properties:                currentBuiltinSchema,
                        AllowAdditionalProperties: true,
                        IsBuiltin:                 true,
                }
        }</span>
        
        // Ensure properties map exists
        <span class="cov3" title="2">if existingConfig.Properties == nil </span><span class="cov0" title="0">{
                existingConfig.Properties = make(map[string]resources.Property)
        }</span>
        
        // Track if any changes were made
        <span class="cov3" title="2">migrationNeeded := false
        
        // Add or update built-in system properties
        for fieldName, builtinProperty := range currentBuiltinSchema </span><span class="cov10" title="20">{
                if existingProperty, exists := existingConfig.Properties[fieldName]; exists </span><span class="cov10" title="20">{
                        // Property exists - check if it needs updating
                        if !r.propertiesEqual(existingProperty, builtinProperty) </span><span class="cov0" title="0">{
                                log.Printf("  üìù Updating system field '%s' in users collection", fieldName)
                                existingConfig.Properties[fieldName] = builtinProperty
                                migrationNeeded = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Property doesn't exist - add it
                        log.Printf("  ‚ûï Adding new system field '%s' to users collection", fieldName)
                        existingConfig.Properties[fieldName] = builtinProperty
                        migrationNeeded = true
                }</span>
        }
        
        // Ensure collection is marked as built-in and allows additional properties
        <span class="cov3" title="2">if !existingConfig.IsBuiltin </span><span class="cov0" title="0">{
                log.Printf("  üèóÔ∏è Marking users collection as built-in")
                existingConfig.IsBuiltin = true
                migrationNeeded = true
        }</span>
        <span class="cov3" title="2">if !existingConfig.AllowAdditionalProperties </span><span class="cov0" title="0">{
                log.Printf("  üîß Enabling additional properties for users collection")
                existingConfig.AllowAdditionalProperties = true
                migrationNeeded = true
        }</span>
        
        // Save updated config if migration was needed
        <span class="cov3" title="2">if migrationNeeded </span><span class="cov0" title="0">{
                if err := r.saveCollectionConfig(filepath.Dir(configFile), &amp;existingConfig); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to save migrated config: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("‚úÖ Successfully migrated users collection schema")
                }</span>
        } else<span class="cov3" title="2"> {
                log.Printf("‚úÖ Users collection schema is up to date")
        }</span>
        
        <span class="cov3" title="2">return &amp;existingConfig</span>
}

// propertiesEqual compares two Property structs for equality
func (r *Router) propertiesEqual(a, b resources.Property) bool <span class="cov10" title="20">{
        return a.Type == b.Type &amp;&amp;
                a.Required == b.Required &amp;&amp;
                a.Unique == b.Unique &amp;&amp;
                a.System == b.System &amp;&amp;
                fmt.Sprintf("%v", a.Default) == fmt.Sprintf("%v", b.Default)
}</span>

// saveCollectionConfig saves a collection configuration to disk
func (r *Router) saveCollectionConfig(configDir string, config *resources.CollectionConfig) error <span class="cov0" title="0">{
        // Ensure directory exists
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>
        
        // Write config.json
        <span class="cov0" title="0">configFile := filepath.Join(configDir, "config.json")
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := os.WriteFile(configFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file31" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"
        "github.com/hjanuschka/go-deployd/internal/admin"
        "github.com/hjanuschka/go-deployd/internal/auth"
        appconfig "github.com/hjanuschka/go-deployd/internal/config"
        "github.com/hjanuschka/go-deployd/internal/database"
        "github.com/hjanuschka/go-deployd/internal/email"
        "github.com/hjanuschka/go-deployd/internal/events"
        "github.com/hjanuschka/go-deployd/internal/logging"
        "github.com/hjanuschka/go-deployd/internal/metrics"
        "github.com/hjanuschka/go-deployd/internal/resources"
        "github.com/hjanuschka/go-deployd/internal/router"
        "golang.org/x/crypto/bcrypt"
        "github.com/hjanuschka/go-deployd/internal/swagger"
        httpSwagger "github.com/swaggo/http-swagger/v2"
)

type Config struct {
        Port               int
        DatabaseType       string
        DatabaseHost       string
        DatabasePort       int
        DatabaseName       string
        DatabaseUsername   string
        DatabasePassword   string
        DatabaseSSL        bool
        ConfigPath         string
        Development        bool
}

type Server struct {
        config         *Config
        db             database.DatabaseInterface
        router         *router.Router
        adminHandler   *admin.AdminHandler
        upgrader       websocket.Upgrader
        httpMux        *mux.Router
        jwtManager     *auth.JWTManager
        securityConfig *appconfig.SecurityConfig
}

func New(config *Config) (*Server, error) <span class="cov10" title="5">{
        dbConfig := &amp;database.Config{
                Host:     config.DatabaseHost,
                Port:     config.DatabasePort,
                Name:     config.DatabaseName,
                Username: config.DatabaseUsername,
                Password: config.DatabasePassword,
                SSL:      config.DatabaseSSL,
        }

        // Determine database type
        var dbType database.DatabaseType
        switch config.DatabaseType </span>{
        case "mongodb":<span class="cov0" title="0">
                dbType = database.DatabaseTypeMongoDB</span>
        case "sqlite":<span class="cov10" title="5">
                dbType = database.DatabaseTypeSQLite</span>
        case "mysql":<span class="cov0" title="0">
                dbType = database.DatabaseTypeMySQL</span>
        case "postgres":<span class="cov0" title="0">
                dbType = database.DatabaseTypePostgres</span>
        default:<span class="cov0" title="0">
                dbType = database.DatabaseTypeMongoDB</span> // Default to MongoDB
        }

        <span class="cov10" title="5">db, err := database.NewDatabase(dbType, dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>


        // Initialize logging system
        <span class="cov10" title="5">if err := logging.InitializeLogger("./logs"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize logging: %w", err)
        }</span>

        // Load security configuration
        <span class="cov10" title="5">configDir := appconfig.GetConfigDir()
        securityConfig, err := appconfig.LoadSecurityConfig(configDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load security config: %w", err)
        }</span>

        // Parse JWT expiration duration
        <span class="cov10" title="5">jwtDuration, err := time.ParseDuration(securityConfig.JWTExpiration)
        if err != nil </span><span class="cov0" title="0">{
                jwtDuration = 24 * time.Hour // Default to 24 hours if parsing fails
                logging.Error("Failed to parse JWT expiration, using default 24h", "auth", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        // Create JWT manager
        <span class="cov10" title="5">jwtManager := auth.NewJWTManager(securityConfig.JWTSecret, jwtDuration)

        // Log server startup
        logging.Info("Starting go-deployd server", "server", map[string]interface{}{
                "port":         config.Port,
                "database":     config.DatabaseType,
                "development":  config.Development,
        })

        s := &amp;Server{
                config:         config,
                db:             db,
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true // TODO: Implement proper origin checking
                        }</span>,
                },
                httpMux:        mux.NewRouter(),
                jwtManager:     jwtManager,
                securityConfig: securityConfig,
        }

        <span class="cov10" title="5">s.router = router.New(s.db, config.Development, config.ConfigPath)

        // Create admin handler
        adminConfig := &amp;admin.Config{
                Port:           config.Port,
                DatabaseHost:   config.DatabaseHost,
                DatabasePort:   config.DatabasePort,
                DatabaseName:   config.DatabaseName,
                Development:    config.Development,
        }
        s.adminHandler = admin.NewAdminHandler(s.db, s.router, adminConfig)

        s.setupRoutes()

        // Start background jobs
        go s.startUserCleanupJob()

        return s, nil</span>
}

func (s *Server) setupRoutes() <span class="cov10" title="5">{
        // Apply metrics middleware to all routes
        s.httpMux.Use(metrics.HTTPMiddleware)

        // WebSocket endpoint for real-time features
        s.httpMux.HandleFunc("/socket.io/", s.handleWebSocket)

        // Admin API routes
        s.adminHandler.RegisterRoutes(s.httpMux)

        // Built-in API routes (like original Deployd)
        s.setupBuiltinRoutes()

        // Authentication routes
        s.setupAuthRoutes()

        // Metrics API routes
        s.setupMetricsRoutes()

        // API documentation routes
        s.setupSwaggerRoutes()

        // Serve dashboard static files with authentication
        dashboardPath := filepath.Join("web", "dashboard")
        s.httpMux.PathPrefix("/_dashboard/").HandlerFunc(s.serveDashboardWithAuth(dashboardPath))

        // Root route handling
        s.setupRootRoute()

        // API routes - delegate to our custom router (lowest priority)
        s.httpMux.PathPrefix("/").HandlerFunc(s.router.ServeHTTP)
}</span>

func (s *Server) setupBuiltinRoutes() <span class="cov10" title="5">{
        // Built-in collections list endpoint (like original Deployd)
        s.httpMux.HandleFunc("/collections", s.handleCollections).Methods("GET")
}</span>

func (s *Server) setupMetricsRoutes() <span class="cov10" title="5">{
        // Metrics API endpoints
        s.httpMux.HandleFunc("/_dashboard/api/metrics/detailed", s.handleDetailedMetrics).Methods("GET")
        s.httpMux.HandleFunc("/_dashboard/api/metrics/aggregated", s.handleAggregatedMetrics).Methods("GET")
        s.httpMux.HandleFunc("/_dashboard/api/metrics/system", s.handleSystemStats).Methods("GET")
        s.httpMux.HandleFunc("/_dashboard/api/metrics/collections", s.handleCollectionsList).Methods("GET")
        s.httpMux.HandleFunc("/_dashboard/api/metrics/events", s.handleEventMetrics).Methods("GET")
        s.httpMux.HandleFunc("/_dashboard/api/metrics/periods", s.handlePeriodsMetrics).Methods("GET")
}</span>

func (s *Server) handleCollections(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        // Get collections from router
        resources := s.router.GetResources()
        collections := make([]string, 0)
        
        for _, resource := range resources </span><span class="cov0" title="0">{
                // Only include actual collections, not internal resources
                name := resource.GetName()
                if name != "" &amp;&amp; !strings.HasPrefix(name, "_") </span><span class="cov0" title="0">{
                        collections = append(collections, name)
                }</span>
        }
        
        // Return collection names as a simple array (like original Deployd)
        <span class="cov0" title="0">if err := json.NewEncoder(w).Encode(collections); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to encode collections", http.StatusInternalServerError)
                return
        }</span>
}


func (s *Server) setupRootRoute() <span class="cov10" title="5">{
        s.httpMux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Only handle exact root path
                if r.URL.Path != "/" </span><span class="cov0" title="0">{
                        s.router.ServeHTTP(w, r)
                        return
                }</span>
                
                <span class="cov0" title="0">if s.config.Development </span><span class="cov0" title="0">{
                        // Redirect to dashboard in development
                        http.Redirect(w, r, "/_dashboard/", http.StatusTemporaryRedirect)
                }</span> else<span class="cov0" title="0"> {
                        // In production, try to serve index.html from public directory
                        indexPath := filepath.Join("./public", "index.html")
                        if _, err := os.Stat(indexPath); err == nil </span><span class="cov0" title="0">{
                                http.ServeFile(w, r, indexPath)
                        }</span> else<span class="cov0" title="0"> {
                                // No index.html, redirect to dashboard
                                http.Redirect(w, r, "/_dashboard/", http.StatusTemporaryRedirect)
                        }</span>
                }
        })
}

func (s *Server) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WebSocket upgrade failed: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Handle WebSocket connection
        // TODO: Implement full Socket.IO compatibility
        for </span><span class="cov0" title="0">{
                messageType, p, err := conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket read error: %v", err)
                        break</span>
                }

                <span class="cov0" title="0">log.Printf("WebSocket message received: %s", p)

                if err := conn.WriteMessage(messageType, p); err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket write error: %v", err)
                        break</span>
                }
        }
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.httpMux.ServeHTTP(w, r)
}</span>

func (s *Server) Close() error <span class="cov0" title="0">{
        // Shutdown V8 pool for JavaScript events
        if v8Pool := events.GetV8Pool(); v8Pool != nil </span><span class="cov0" title="0">{
                v8Pool.Shutdown()
                logging.Info("V8 pool shut down", "server", nil)
        }</span>
        
        <span class="cov0" title="0">if s.db != nil </span><span class="cov0" title="0">{
                return s.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Server) CreateStore(namespace string) database.StoreInterface <span class="cov0" title="0">{
        return s.db.CreateStore(namespace)
}</span>

// serveDashboardWithAuth returns a handler that serves dashboard files with master key authentication
func (s *Server) serveDashboardWithAuth(dashboardPath string) http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Extract path
                path := strings.TrimPrefix(r.URL.Path, "/_dashboard/")
                
                // Allow login page without authentication
                if path == "login" || path == "login/" || strings.HasPrefix(path, "assets/") </span><span class="cov0" title="0">{
                        s.serveDashboardFile(w, r, dashboardPath, path)
                        return
                }</span>
                
                // Check for master key authentication
                <span class="cov0" title="0">masterKey := r.Header.Get("X-Master-Key")
                if masterKey == "" </span><span class="cov0" title="0">{
                        // Also check cookie
                        if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                                masterKey = cookie.Value
                        }</span>
                }
                
                // Validate master key
                <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                        // Redirect to login page for dashboard requests
                        if path == "" || path == "/" || !strings.HasPrefix(path, "assets/") </span><span class="cov0" title="0">{
                                http.Redirect(w, r, "/_dashboard/login", http.StatusTemporaryRedirect)
                                return
                        }</span>
                        
                        // For API requests, return 401
                        <span class="cov0" title="0">if strings.HasPrefix(path, "api/") </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusUnauthorized)
                                w.Header().Set("Content-Type", "application/json")
                                json.NewEncoder(w).Encode(map[string]interface{}{
                                        "error": "Authentication required",
                                        "message": "Master key required for dashboard access",
                                })
                                return
                        }</span>
                        
                        // For other requests, serve login page
                        <span class="cov0" title="0">path = "login"</span>
                }
                
                <span class="cov0" title="0">s.serveDashboardFile(w, r, dashboardPath, path)</span>
        }
}

// serveDashboardFile serves a specific dashboard file
func (s *Server) serveDashboardFile(w http.ResponseWriter, r *http.Request, dashboardPath, path string) <span class="cov0" title="0">{
        if path == "" || path == "/" </span><span class="cov0" title="0">{
                // Serve index.html for dashboard root
                path = "index.html"
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(dashboardPath, path)
        
        // Check if file exists
        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // If file doesn't exist and it's not an asset, serve index.html (SPA routing)
                if !strings.HasPrefix(path, "assets/") </span><span class="cov0" title="0">{
                        fullPath = filepath.Join(dashboardPath, "index.html")
                }</span> else<span class="cov0" title="0"> {
                        http.NotFound(w, r)
                        return
                }</span>
        }
        
        <span class="cov0" title="0">http.ServeFile(w, r, fullPath)</span>
}

func (s *Server) handleDetailedMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check for master key authentication
        masterKey := r.Header.Get("X-Master-Key")
        if masterKey == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                        masterKey = cookie.Value
                }</span>
        }
        
        <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">collection := r.URL.Query().Get("collection")
        since := time.Now().Add(-24 * time.Hour) // Last 24 hours
        if sinceParam := r.URL.Query().Get("since"); sinceParam != "" </span><span class="cov0" title="0">{
                if parsedTime, err := time.Parse(time.RFC3339, sinceParam); err == nil </span><span class="cov0" title="0">{
                        since = parsedTime
                }</span>
        }

        <span class="cov0" title="0">collector := metrics.GetGlobalCollector()
        var metricsData []metrics.Metric
        if collection != "" &amp;&amp; collection != "all" </span><span class="cov0" title="0">{
                metricsData = collector.GetDetailedMetricsByCollection(collection, since)
        }</span> else<span class="cov0" title="0"> {
                metricsData = collector.GetDetailedMetrics(since)
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "metrics": metricsData,
                "since":   since,
                "count":   len(metricsData),
        })</span>
}

func (s *Server) handleAggregatedMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check for master key authentication
        masterKey := r.Header.Get("X-Master-Key")
        if masterKey == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                        masterKey = cookie.Value
                }</span>
        }
        
        <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">collection := r.URL.Query().Get("collection")
        since := time.Now().Add(-7 * 24 * time.Hour) // Last 7 days
        if sinceParam := r.URL.Query().Get("since"); sinceParam != "" </span><span class="cov0" title="0">{
                if parsedTime, err := time.Parse(time.RFC3339, sinceParam); err == nil </span><span class="cov0" title="0">{
                        since = parsedTime
                }</span>
        }

        <span class="cov0" title="0">collector := metrics.GetGlobalCollector()
        metricsData := collector.GetAggregatedMetrics("hourly", collection, since)

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "metrics": metricsData,
                "since":   since,
                "count":   len(metricsData),
        })</span>
}

func (s *Server) handleSystemStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check for master key authentication
        masterKey := r.Header.Get("X-Master-Key")
        if masterKey == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                        masterKey = cookie.Value
                }</span>
        }
        
        <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">collector := metrics.GetGlobalCollector()
        stats := collector.GetSystemStats()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(stats)</span>
}

func (s *Server) handleCollectionsList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check for master key authentication
        masterKey := r.Header.Get("X-Master-Key")
        if masterKey == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                        masterKey = cookie.Value
                }</span>
        }
        
        <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">collector := metrics.GetGlobalCollector()
        collections := collector.GetCollections()

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "collections": collections,
        })</span>
}

func (s *Server) handleEventMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check for master key authentication
        masterKey := r.Header.Get("X-Master-Key")
        if masterKey == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                        masterKey = cookie.Value
                }</span>
        }
        
        <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">collection := r.URL.Query().Get("collection")
        period := r.URL.Query().Get("period")
        if period == "" </span><span class="cov0" title="0">{
                period = "hourly"
        }</span>

        // Default to last 24 hours for detailed, 7 days for others
        <span class="cov0" title="0">var since time.Time
        switch period </span>{
        case "detailed":<span class="cov0" title="0">
                since = time.Now().Add(-24 * time.Hour)</span>
        case "hourly":<span class="cov0" title="0">
                since = time.Now().Add(-7 * 24 * time.Hour)</span>
        case "daily":<span class="cov0" title="0">
                since = time.Now().Add(-30 * 24 * time.Hour)</span>
        case "monthly":<span class="cov0" title="0">
                since = time.Now().Add(-365 * 24 * time.Hour)</span>
        }

        <span class="cov0" title="0">if sinceParam := r.URL.Query().Get("since"); sinceParam != "" </span><span class="cov0" title="0">{
                if parsedTime, err := time.Parse(time.RFC3339, sinceParam); err == nil </span><span class="cov0" title="0">{
                        since = parsedTime
                }</span>
        }

        <span class="cov0" title="0">collector := metrics.GetGlobalCollector()
        eventMetrics := collector.GetEventMetrics(collection)

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "events": eventMetrics,
                "since":  since,
                "period": period,
        })</span>
}

func (s *Server) handlePeriodsMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check for master key authentication
        masterKey := r.Header.Get("X-Master-Key")
        if masterKey == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("masterKey"); err == nil </span><span class="cov0" title="0">{
                        masterKey = cookie.Value
                }</span>
        }
        
        <span class="cov0" title="0">if !s.adminHandler.AuthHandler.Security.ValidateMasterKey(masterKey) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusUnauthorized)
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "error": "Authentication required",
                })
                return
        }</span>

        <span class="cov0" title="0">collection := r.URL.Query().Get("collection")
        period := r.URL.Query().Get("period")
        if period == "" </span><span class="cov0" title="0">{
                period = "daily"
        }</span>

        <span class="cov0" title="0">var since time.Time
        switch period </span>{
        case "daily":<span class="cov0" title="0">
                since = time.Now().Add(-6 * 30 * 24 * time.Hour)</span> // 6 months
        case "monthly":<span class="cov0" title="0">
                since = time.Now().Add(-12 * 30 * 24 * time.Hour)</span> // 12 months
        default:<span class="cov0" title="0">
                since = time.Now().Add(-30 * 24 * time.Hour)</span> // 30 days
        }

        <span class="cov0" title="0">if sinceParam := r.URL.Query().Get("since"); sinceParam != "" </span><span class="cov0" title="0">{
                if parsedTime, err := time.Parse(time.RFC3339, sinceParam); err == nil </span><span class="cov0" title="0">{
                        since = parsedTime
                }</span>
        }

        <span class="cov0" title="0">collector := metrics.GetGlobalCollector()
        metricsData := collector.GetAggregatedMetrics(period, collection, since)

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "metrics": metricsData,
                "since":   since,
                "period":  period,
                "count":   len(metricsData),
        })</span>
}

func (s *Server) setupAuthRoutes() <span class="cov10" title="5">{
        // Login endpoint
        s.httpMux.HandleFunc("/auth/login", s.handleLogin).Methods("POST", "OPTIONS")
        // Token validation endpoint
        s.httpMux.HandleFunc("/auth/validate", s.handleTokenValidation).Methods("GET", "OPTIONS")
        // User info endpoint
        s.httpMux.HandleFunc("/auth/me", s.handleMe).Methods("GET", "OPTIONS")
        // Email verification endpoint
        s.httpMux.HandleFunc("/auth/verify", s.handleEmailVerification).Methods("POST", "GET", "OPTIONS")
        // Resend verification email endpoint
        s.httpMux.HandleFunc("/auth/resend-verification", s.handleResendVerification).Methods("POST", "OPTIONS")
}</span>

// LoginRequest represents the login request payload
type LoginRequest struct {
        Username  string `json:"username,omitempty"`
        Password  string `json:"password,omitempty"`
        MasterKey string `json:"masterKey,omitempty"`
}

// LoginResponse represents the login response
type LoginResponse struct {
        Token     string                 `json:"token"`
        ExpiresAt int64                  `json:"expiresAt"`
        User      map[string]interface{} `json:"user,omitempty"`
        IsRoot    bool                   `json:"isRoot"`
}

func (s *Server) handleLogin(w http.ResponseWriter, r *http.Request) <span class="cov8" title="4">{
        // Enable CORS
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov8" title="4">var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Invalid request body"}`, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="4">var userID, username string
        var isRoot bool
        var userData map[string]interface{}

        // Check for master key authentication
        if req.MasterKey != "" </span><span class="cov8" title="4">{
                if s.securityConfig.ValidateMasterKey(req.MasterKey) </span><span class="cov7" title="3">{
                        userID = "root"
                        username = "root"
                        isRoot = true
                }</span> else<span class="cov1" title="1"> {
                        http.Error(w, `{"error": "Invalid master key"}`, http.StatusUnauthorized)
                        return
                }</span>
        } else<span class="cov0" title="0"> if req.Username != "" &amp;&amp; req.Password != "" </span><span class="cov0" title="0">{
                // Authenticate user with username/password
                user, err := s.authenticateUser(req.Username, req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, `{"error": "Invalid credentials"}`, http.StatusUnauthorized)
                        return
                }</span>
                
                <span class="cov0" title="0">userID = getStringFromMap(user, "id")
                username = getStringFromMap(user, "username")
                role := getStringFromMap(user, "role")
                isRoot = (role == "admin")
                
                // Remove password and other sensitive fields from user data
                userData = make(map[string]interface{})
                for k, v := range user </span><span class="cov0" title="0">{
                        if k != "password" &amp;&amp; k != "salt" </span><span class="cov0" title="0">{
                                userData[k] = v
                        }</span>
                }
                <span class="cov0" title="0">userData["role"] = role</span>
        } else<span class="cov0" title="0"> {
                http.Error(w, `{"error": "Username/password or masterKey required"}`, http.StatusBadRequest)
                return
        }</span>

        // Generate JWT token
        <span class="cov7" title="3">token, err := s.jwtManager.GenerateToken(userID, username, isRoot)
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Failed to generate JWT token", "auth", map[string]interface{}{
                        "error": err.Error(),
                })
                http.Error(w, `{"error": "Failed to generate token"}`, http.StatusInternalServerError)
                return
        }</span>

        // Calculate expiration time
        <span class="cov7" title="3">duration, _ := time.ParseDuration(s.securityConfig.JWTExpiration)
        expiresAt := time.Now().Add(duration).Unix()

        // Prepare response
        response := LoginResponse{
                Token:     token,
                ExpiresAt: expiresAt,
                IsRoot:    isRoot,
                User:      userData,
        }


        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

func (s *Server) handleTokenValidation(w http.ResponseWriter, r *http.Request) <span class="cov10" title="5">{
        // Enable CORS
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        // Extract token from Authorization header
        <span class="cov10" title="5">authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov1" title="1">{
                http.Error(w, `{"error": "Authorization header required"}`, http.StatusUnauthorized)
                return
        }</span>

        // Remove "Bearer " prefix
        <span class="cov8" title="4">token := strings.TrimPrefix(authHeader, "Bearer ")
        if token == authHeader </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Bearer token required"}`, http.StatusUnauthorized)
                return
        }</span>

        // Validate token
        <span class="cov8" title="4">claims, err := s.jwtManager.ValidateToken(token)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf(`{"error": "Invalid token: %s"}`, err.Error()), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov7" title="3">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "valid":    true,
                "userID":   claims.UserID,
                "username": claims.Username,
                "isRoot":   claims.IsRoot,
                "exp":      claims.ExpiresAt.Unix(),
        })</span>
}

func (s *Server) handleMe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Enable CORS
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                return
        }</span>

        // Extract token from Authorization header
        <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Authorization header required"}`, http.StatusUnauthorized)
                return
        }</span>

        // Remove "Bearer " prefix
        <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
        if token == authHeader </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Bearer token required"}`, http.StatusUnauthorized)
                return
        }</span>

        // Validate token
        <span class="cov0" title="0">claims, err := s.jwtManager.ValidateToken(token)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf(`{"error": "Invalid token: %s"}`, err.Error()), http.StatusUnauthorized)
                return
        }</span>

        // For root users, return basic info
        <span class="cov0" title="0">if claims.IsRoot </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "id":       claims.UserID,
                        "username": claims.Username,
                        "isRoot":   claims.IsRoot,
                })
                return
        }</span>

        // For regular users, fetch user data from users collection
        // Fetch user data by ID
        <span class="cov0" title="0">store := s.db.CreateStore("users")
        
        // Create query to find user by ID
        query := database.NewQueryBuilder()
        query.Where("id", "=", claims.UserID)
        
        userData, err := store.FindOne(r.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "User not found"}`, http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(userData)</span>
}

func (s *Server) handleEmailVerification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var token string
        
        if r.Method == "GET" </span><span class="cov0" title="0">{
                // GET request with token as query parameter (for email links)
                token = r.URL.Query().Get("token")
        }</span> else<span class="cov0" title="0"> if r.Method == "POST" </span><span class="cov0" title="0">{
                // POST request with token in JSON body
                var req struct {
                        Token string `json:"token"`
                }
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, `{"error": "Invalid JSON body"}`, http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">token = req.Token</span>
        }
        
        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Verification token required"}`, http.StatusBadRequest)
                return
        }</span>
        
        // Find user by verification token
        <span class="cov0" title="0">store := s.db.CreateStore("users")
        query := database.NewQueryBuilder()
        query.Where("verificationToken", "=", token)
        
        userData, err := store.FindOne(r.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Invalid or expired verification token"}`, http.StatusBadRequest)
                return
        }</span>
        
        // Check if token has expired
        <span class="cov0" title="0">if expiresStr, ok := userData["verificationExpires"].(string); ok </span><span class="cov0" title="0">{
                if expires, err := time.Parse(time.RFC3339, expiresStr); err == nil </span><span class="cov0" title="0">{
                        if time.Now().After(expires) </span><span class="cov0" title="0">{
                                http.Error(w, `{"error": "Verification token has expired"}`, http.StatusBadRequest)
                                return
                        }</span>
                }
        }
        
        // Update user to verified and active
        <span class="cov0" title="0">userID := userData["id"].(string)
        updateQuery := database.NewQueryBuilder()
        updateQuery.Where("id", "=", userID)
        
        updateBuilder := database.NewUpdateBuilder().
                Set("isVerified", true).
                Set("active", true).
                Unset("verificationToken").
                Unset("verificationExpires").
                Set("updatedAt", time.Now().Format(time.RFC3339))
        
        _, err = store.UpdateOne(r.Context(), updateQuery, updateBuilder)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Failed to verify user"}`, http.StatusInternalServerError)
                return
        }</span>
        
        // Return success response
        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Email verified successfully",
                "user": map[string]interface{}{
                        "id":       userData["id"],
                        "username": userData["username"],
                        "email":    userData["email"],
                        "verified": true,
                },
        })</span>
}

func (s *Server) handleResendVerification(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        
        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">var req struct {
                Email string `json:"email"`
        }
        
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Invalid JSON body"}`, http.StatusBadRequest)
                return
        }</span>
        
        <span class="cov0" title="0">if req.Email == "" </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Email address required"}`, http.StatusBadRequest)
                return
        }</span>
        
        // Find user by email
        <span class="cov0" title="0">store := s.db.CreateStore("users")
        query := database.NewQueryBuilder()
        query.Where("email", "=", req.Email)
        
        userData, err := store.FindOne(r.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                // Don't reveal if email exists for security
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": true,
                        "message": "If the email exists and is unverified, a verification email has been sent",
                })
                return
        }</span>
        
        // Check if already verified
        <span class="cov0" title="0">if verified, ok := userData["isVerified"].(bool); ok &amp;&amp; verified </span><span class="cov0" title="0">{
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "success": false,
                        "message": "Email is already verified",
                })
                return
        }</span>
        
        // Generate new verification token and update user
        <span class="cov0" title="0">verificationToken, err := email.GenerateVerificationToken()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Failed to generate verification token"}`, http.StatusInternalServerError)
                return
        }</span>
        
        // Update user with new verification token
        <span class="cov0" title="0">updateQuery := database.NewQueryBuilder().Where("email", "=", req.Email)
        updateBuilder := database.NewUpdateBuilder()
        updateBuilder.Set("verificationToken", verificationToken)
        updateBuilder.Set("verificationExpires", time.Now().Add(24 * time.Hour))
        
        _, err = store.Update(r.Context(), updateQuery, updateBuilder)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, `{"error": "Failed to update verification token"}`, http.StatusInternalServerError)
                return
        }</span>
        
        // Send verification email
        <span class="cov0" title="0">baseURL := fmt.Sprintf("http://%s", r.Host)
        emailService := email.NewEmailService(&amp;s.securityConfig.Email)
        
        username := getStringFromMap(userData, "username")
        if err := emailService.SendVerificationEmail(req.Email, username, verificationToken, baseURL); err != nil </span>{<span class="cov0" title="0">
                // Log the error but still return success to avoid revealing email existence
                // TODO: Add proper logging
        }</span>
        
        <span class="cov0" title="0">json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "If the email exists and is unverified, a verification email has been sent",
        })</span>
}

func (s *Server) setupSwaggerRoutes() <span class="cov10" title="5">{
        // Create swagger generator
        baseURL := fmt.Sprintf("http://localhost:%d", s.config.Port)
        generator := swagger.NewGenerator(baseURL, s.router.GetResources())

        // Overall API documentation
        s.httpMux.HandleFunc("/api/docs/openapi.json", s.handleOverallSwagger(generator)).Methods("GET")
        
        // Collection-specific API documentation
        s.httpMux.HandleFunc("/api/docs/{collection}/openapi.json", s.handleCollectionSwagger(generator)).Methods("GET")
        
        // Swagger UI for overall API
        s.httpMux.PathPrefix("/api/docs/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/api/docs/openapi.json"),
                httpSwagger.DeepLinking(true),
        ))

        // Collection-specific Swagger UI
        s.httpMux.HandleFunc("/api/docs/{collection}/", s.handleCollectionSwaggerUI()).Methods("GET")
}</span>

func (s *Server) handleOverallSwagger(generator *swagger.Generator) http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Enable CORS
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Content-Type", "application/json")

                spec, err := generator.GenerateSpec()
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf(`{"error": "Failed to generate API spec: %s"}`, err.Error()), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">json.NewEncoder(w).Encode(spec)</span>
        }
}

func (s *Server) handleCollectionSwagger(generator *swagger.Generator) http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                vars := mux.Vars(r)
                collectionName := vars["collection"]

                // Enable CORS
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Content-Type", "application/json")

                // Find the collection
                var targetCollection resources.Resource
                for _, collection := range s.router.GetResources() </span><span class="cov0" title="0">{
                        if collection.GetName() == collectionName </span><span class="cov0" title="0">{
                                targetCollection = collection
                                break</span>
                        }
                }

                <span class="cov0" title="0">if targetCollection == nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf(`{"error": "Collection '%s' not found"}`, collectionName), http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">spec, err := generator.GenerateCollectionSpec(targetCollection)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf(`{"error": "Failed to generate API spec: %s"}`, err.Error()), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">json.NewEncoder(w).Encode(spec)</span>
        }
}

func (s *Server) handleCollectionSwaggerUI() http.HandlerFunc <span class="cov10" title="5">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                vars := mux.Vars(r)
                collectionName := vars["collection"]

                // Redirect to Swagger UI with collection-specific spec
                swaggerURL := fmt.Sprintf("/api/docs/%s/openapi.json", collectionName)
                
                // Serve custom Swagger UI HTML
                html := fmt.Sprintf(`
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;%s API Documentation&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@3.52.5/swagger-ui.css" /&gt;
    &lt;style&gt;
        html {
            box-sizing: border-box;
            overflow: -moz-scrollbars-vertical;
            overflow-y: scroll;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }
        body {
            margin:0;
            background: #fafafa;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@3.52.5/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@3.52.5/swagger-ui-standalone-preset.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() {
            const ui = SwaggerUIBundle({
                url: '%s',
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout"
            });
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`, strings.Title(collectionName), swaggerURL)

                w.Header().Set("Content-Type", "text/html")
                w.Write([]byte(html))
        }</span>
}

// authenticateUser validates username/password and returns user data
func (s *Server) authenticateUser(username, password string) (map[string]interface{}, error) <span class="cov0" title="0">{
        store := s.db.CreateStore("users")
        
        // Find user by username or email
        var query database.QueryBuilder
        if strings.Contains(username, "@") </span><span class="cov0" title="0">{
                query = database.NewQueryBuilder().Where("email", "$eq", username)
        }</span> else<span class="cov0" title="0"> {
                query = database.NewQueryBuilder().Where("username", "$eq", username)
        }</span>
        
        <span class="cov0" title="0">user, err := store.FindOne(context.Background(), query)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>
        
        // Verify password
        <span class="cov0" title="0">hashedPassword, ok := user["password"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user data")
        }</span>
        
        // Verify password using bcrypt
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid password")
        }</span>
        
        <span class="cov0" title="0">return user, nil</span>
}

// getStringFromMap safely extracts a string value from a map
func getStringFromMap(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, exists := m[key]; exists </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}


// startUserCleanupJob runs a background job to remove unverified users after 24 hours
func (s *Server) startUserCleanupJob() <span class="cov10" title="5">{
        // Run cleanup every hour
        ticker := time.NewTicker(1 * time.Hour)
        defer ticker.Stop()
        
        // Also run immediately on startup
        s.cleanupUnverifiedUsers()
        
        for range ticker.C </span><span class="cov0" title="0">{
                s.cleanupUnverifiedUsers()
        }</span>
}

// cleanupUnverifiedUsers removes users who haven't verified their email within 24 hours
func (s *Server) cleanupUnverifiedUsers() <span class="cov10" title="5">{
        if !s.securityConfig.RequireVerification </span><span class="cov0" title="0">{
                // Email verification not required, no cleanup needed
                return
        }</span>
        
        <span class="cov10" title="5">store := s.db.CreateStore("users")
        
        // Find unverified users where verification token expired
        query := database.NewQueryBuilder()
        query.Where("isVerified", "=", false)
        query.Where("verificationExpires", "&lt;", time.Now())
        
        // Find expired unverified users
        users, err := store.Find(context.Background(), query, database.QueryOptions{})
        if err != nil </span><span class="cov4" title="2">{
                log.Printf("Error finding unverified users for cleanup: %v", err)
                return
        }</span>
        
        // Delete each expired unverified user
        <span class="cov7" title="3">deletedCount := 0
        for _, user := range users </span><span class="cov0" title="0">{
                if userID, ok := user["id"].(string); ok </span><span class="cov0" title="0">{
                        deleteQuery := database.NewQueryBuilder().Where("id", "=", userID)
                        result, err := store.Remove(context.Background(), deleteQuery)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error deleting unverified user %s: %v", userID, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">if result.DeletedCount() &gt; 0 </span><span class="cov0" title="0">{
                                deletedCount++
                        }</span>
                }
        }
        
        <span class="cov7" title="3">if deletedCount &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("üßπ Cleaned up %d unverified users", deletedCount)
        }</span>
}</pre>
		
		<pre class="file" id="file32" style="display: none">package sessions

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "net/http"
        "time"

        "github.com/hjanuschka/go-deployd/internal/database"
)

type SessionStore struct {
        store       database.StoreInterface
        development bool
}

type Session struct {
        ID          string                 `json:"id"`
        Data        map[string]interface{} `json:"data"`
        CreatedAt   time.Time              `json:"createdAt"`
        UpdatedAt   time.Time              `json:"updatedAt"`
        development bool
}

func New(db database.DatabaseInterface, development bool) *SessionStore <span class="cov0" title="0">{
        return &amp;SessionStore{
                store:       db.CreateStore("sessions"),
                development: development,
        }
}</span>

func (ss *SessionStore) CreateSession(sessionID string) (*Session, error) <span class="cov0" title="0">{
        ctx := context.Background()
        
        if sessionID != "" </span><span class="cov0" title="0">{
                // Try to find existing session
                query := database.NewQueryBuilder().Where("id", "$eq", sessionID)
                existing, err := ss.store.FindOne(ctx, query)
                if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                        session := &amp;Session{
                                ID:          sessionID,
                                Data:        make(map[string]interface{}),
                                development: ss.development,
                        }
                        
                        if data, exists := existing["data"]; exists </span><span class="cov0" title="0">{
                                if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        session.Data = dataMap
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback for any unconverted data types
                                        session.Data = make(map[string]interface{})
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if createdAt, exists := existing["createdAt"]; exists </span><span class="cov0" title="0">{
                                if t, ok := createdAt.(time.Time); ok </span><span class="cov0" title="0">{
                                        session.CreatedAt = t
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if updatedAt, exists := existing["updatedAt"]; exists </span><span class="cov0" title="0">{
                                if t, ok := updatedAt.(time.Time); ok </span><span class="cov0" title="0">{
                                        session.UpdatedAt = t
                                }</span>
                        }
                        
                        <span class="cov0" title="0">return session, nil</span>
                }
        }
        
        // Create new session
        <span class="cov0" title="0">newSessionID := ss.generateSessionID()
        now := time.Now()
        
        session := &amp;Session{
                ID:          newSessionID,
                Data:        make(map[string]interface{}),
                CreatedAt:   now,
                UpdatedAt:   now,
                development: ss.development,
        }
        
        // Save to database
        sessionDoc := map[string]interface{}{
                "id":        session.ID,
                "data":      session.Data,
                "createdAt": session.CreatedAt,
                "updatedAt": session.UpdatedAt,
        }
        
        _, err := ss.store.Insert(ctx, sessionDoc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>
        
        <span class="cov0" title="0">return session, nil</span>
}

func (ss *SessionStore) generateSessionID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

func (s *Session) GetID() string <span class="cov0" title="0">{
        return s.ID
}</span>

func (s *Session) IsRoot() bool <span class="cov0" title="0">{
        // Check explicit isRoot flag first (for system login, master key auth)
        if root, exists := s.Data["isRoot"]; exists </span><span class="cov0" title="0">{
                if rootBool, ok := root.(bool); ok </span><span class="cov0" title="0">{
                        return rootBool
                }</span>
        }
        
        // In development mode, only return true if no explicit isRoot flag is set
        // This allows proper authentication testing while maintaining dev convenience
        <span class="cov0" title="0">if s.development </span><span class="cov0" title="0">{
                return false // Changed: don't automatically grant root in dev mode
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (s *Session) Get(key string) interface{} <span class="cov0" title="0">{
        return s.Data[key]
}</span>

func (s *Session) Set(key string, value interface{}) <span class="cov0" title="0">{
        s.Data[key] = value
        s.UpdatedAt = time.Now()
}</span>

func (s *Session) Save(store *SessionStore) error <span class="cov0" title="0">{
        ctx := context.Background()
        
        query := database.NewQueryBuilder().Where("id", "$eq", s.ID)
        update := database.NewUpdateBuilder().
                Set("id", s.ID).
                Set("data", s.Data).
                Set("createdAt", s.CreatedAt).
                Set("updatedAt", s.UpdatedAt)
        
        _, err := store.store.Upsert(ctx, query, update)
        return err
}</span>

func (ss *SessionStore) GetSessionFromRequest(r *http.Request) (*Session, error) <span class="cov0" title="0">{
        // Try to get session ID from cookie
        cookie, err := r.Cookie("sid")
        if err == nil &amp;&amp; cookie.Value != "" </span><span class="cov0" title="0">{
                return ss.CreateSession(cookie.Value)
        }</span>
        
        // Try to get session ID from Authorization header
        <span class="cov0" title="0">auth := r.Header.Get("Authorization")
        if auth != "" &amp;&amp; len(auth) &gt; 7 &amp;&amp; auth[:7] == "Bearer " </span><span class="cov0" title="0">{
                token := auth[7:]
                return ss.CreateSession(token)
        }</span>
        
        // Create new session
        <span class="cov0" title="0">return ss.CreateSession("")</span>
}

func (ss *SessionStore) SetSessionCookie(w http.ResponseWriter, session *Session) <span class="cov0" title="0">{
        cookie := &amp;http.Cookie{
                Name:     "sid",
                Value:    session.ID,
                Path:     "/",
                HttpOnly: true,
                MaxAge:   86400 * 30, // 30 days
        }
        
        http.SetCookie(w, cookie)
}</span>

</pre>
		
		<pre class="file" id="file33" style="display: none">package swagger

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/hjanuschka/go-deployd/internal/resources"
)

// OpenAPISpec represents the OpenAPI 3.0 specification
type OpenAPISpec struct {
        OpenAPI string                 `json:"openapi"`
        Info    OpenAPIInfo            `json:"info"`
        Servers []OpenAPIServer        `json:"servers"`
        Paths   map[string]interface{} `json:"paths"`
        Components OpenAPIComponents   `json:"components"`
}

type OpenAPIInfo struct {
        Title       string `json:"title"`
        Description string `json:"description"`
        Version     string `json:"version"`
}

type OpenAPIServer struct {
        URL         string `json:"url"`
        Description string `json:"description"`
}

type OpenAPIComponents struct {
        Schemas         map[string]interface{} `json:"schemas"`
        SecuritySchemes map[string]interface{} `json:"securitySchemes"`
}

type OpenAPIPath struct {
        Summary     string                 `json:"summary,omitempty"`
        Description string                 `json:"description,omitempty"`
        OperationID string                 `json:"operationId,omitempty"`
        Tags        []string               `json:"tags,omitempty"`
        Parameters  []interface{}          `json:"parameters,omitempty"`
        RequestBody interface{}            `json:"requestBody,omitempty"`
        Responses   map[string]interface{} `json:"responses"`
        Security    []map[string][]string  `json:"security,omitempty"`
}

// Generator generates OpenAPI specifications for collections
type Generator struct {
        baseURL     string
        collections []resources.Resource
}

// NewGenerator creates a new OpenAPI generator
func NewGenerator(baseURL string, collections []resources.Resource) *Generator <span class="cov0" title="0">{
        return &amp;Generator{
                baseURL:     baseURL,
                collections: collections,
        }
}</span>

// GenerateSpec generates the complete OpenAPI specification
func (g *Generator) GenerateSpec() (*OpenAPISpec, error) <span class="cov0" title="0">{
        spec := &amp;OpenAPISpec{
                OpenAPI: "3.0.0",
                Info: OpenAPIInfo{
                        Title:       "go-deployd API",
                        Description: "RESTful API for go-deployd backend-as-a-service",
                        Version:     "1.0.0",
                },
                Servers: []OpenAPIServer{
                        {
                                URL:         g.baseURL,
                                Description: "go-deployd server",
                        },
                },
                Paths: make(map[string]interface{}),
                Components: OpenAPIComponents{
                        Schemas:         make(map[string]interface{}),
                        SecuritySchemes: g.generateSecuritySchemes(),
                },
        }

        // Add authentication endpoints
        g.addAuthPaths(spec)

        // Add collection endpoints
        for _, collection := range g.collections </span><span class="cov0" title="0">{
                g.addCollectionPaths(spec, collection)
        }</span>

        <span class="cov0" title="0">return spec, nil</span>
}

// GenerateCollectionSpec generates OpenAPI spec for a specific collection
func (g *Generator) GenerateCollectionSpec(collection resources.Resource) (*OpenAPISpec, error) <span class="cov0" title="0">{
        spec := &amp;OpenAPISpec{
                OpenAPI: "3.0.0",
                Info: OpenAPIInfo{
                        Title:       fmt.Sprintf("%s API", strings.Title(collection.GetName())),
                        Description: fmt.Sprintf("RESTful API for %s collection", collection.GetName()),
                        Version:     "1.0.0",
                },
                Servers: []OpenAPIServer{
                        {
                                URL:         g.baseURL,
                                Description: "go-deployd server",
                        },
                },
                Paths: make(map[string]interface{}),
                Components: OpenAPIComponents{
                        Schemas:         make(map[string]interface{}),
                        SecuritySchemes: g.generateSecuritySchemes(),
                },
        }

        g.addCollectionPaths(spec, collection)
        return spec, nil
}</span>

func (g *Generator) generateSecuritySchemes() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "BearerAuth": map[string]interface{}{
                        "type":         "http",
                        "scheme":       "bearer",
                        "bearerFormat": "JWT",
                        "description":  "JWT token obtained from /auth/login",
                },
                "MasterKey": map[string]interface{}{
                        "type":        "apiKey",
                        "in":          "header",
                        "name":        "X-Master-Key",
                        "description": "Master key for administrative access",
                },
        }
}</span>

func (g *Generator) addAuthPaths(spec *OpenAPISpec) <span class="cov0" title="0">{
        // Login endpoint
        spec.Paths["/auth/login"] = map[string]interface{}{
                "post": OpenAPIPath{
                        Summary:     "Authenticate user",
                        Description: "Login with username/password or master key to get JWT token",
                        OperationID: "login",
                        Tags:        []string{"Authentication"},
                        RequestBody: map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "type": "object",
                                                        "properties": map[string]interface{}{
                                                                "username": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Username for login",
                                                                },
                                                                "password": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Password for login",
                                                                },
                                                                "masterKey": map[string]interface{}{
                                                                        "type":        "string",
                                                                        "description": "Master key for administrative access",
                                                                },
                                                        },
                                                        "oneOf": []interface{}{
                                                                map[string]interface{}{
                                                                        "required": []string{"username", "password"},
                                                                },
                                                                map[string]interface{}{
                                                                        "required": []string{"masterKey"},
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Login successful",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/LoginResponse",
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{
                                        "description": "Authentication failed",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/Error",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        // Token validation endpoint
        spec.Paths["/auth/validate"] = map[string]interface{}{
                "get": OpenAPIPath{
                        Summary:     "Validate JWT token",
                        Description: "Validate the provided JWT token",
                        OperationID: "validateToken",
                        Tags:        []string{"Authentication"},
                        Security: []map[string][]string{
                                {"BearerAuth": {}},
                        },
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Token is valid",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/TokenValidation",
                                                        },
                                                },
                                        },
                                },
                                "401": map[string]interface{}{
                                        "description": "Token is invalid or expired",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": "#/components/schemas/Error",
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        // Add common schemas
        spec.Components.Schemas["LoginResponse"] = map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "token": map[string]interface{}{
                                "type":        "string",
                                "description": "JWT token",
                        },
                        "expiresAt": map[string]interface{}{
                                "type":        "integer",
                                "description": "Token expiration timestamp",
                        },
                        "isRoot": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether user has root privileges",
                        },
                        "user": map[string]interface{}{
                                "type":        "object",
                                "description": "User information",
                        },
                },
        }

        spec.Components.Schemas["TokenValidation"] = map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "valid": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether token is valid",
                        },
                        "userID": map[string]interface{}{
                                "type":        "string",
                                "description": "User ID from token",
                        },
                        "username": map[string]interface{}{
                                "type":        "string",
                                "description": "Username from token",
                        },
                        "isRoot": map[string]interface{}{
                                "type":        "boolean",
                                "description": "Whether user has root privileges",
                        },
                        "exp": map[string]interface{}{
                                "type":        "integer",
                                "description": "Token expiration timestamp",
                        },
                },
        }

        spec.Components.Schemas["Error"] = map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "error": map[string]interface{}{
                                "type":        "string",
                                "description": "Error message",
                        },
                },
        }
}</span>

func (g *Generator) addCollectionPaths(spec *OpenAPISpec, collection resources.Resource) <span class="cov0" title="0">{
        collectionName := collection.GetName()
        path := collection.GetPath()
        
        // Ensure path starts with /
        if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>

        // Remove trailing slash
        <span class="cov0" title="0">path = strings.TrimSuffix(path, "/")

        // Generate schema for the collection
        schema := g.generateCollectionSchema(collection)
        spec.Components.Schemas[strings.Title(collectionName)] = schema

        // Security for all operations
        security := []map[string][]string{
                {"BearerAuth": {}},
                {"MasterKey": {}},
        }

        // Collection operations (list and create)
        spec.Paths[path] = map[string]interface{}{
                "get": OpenAPIPath{
                        Summary:     fmt.Sprintf("List %s", collectionName),
                        Description: fmt.Sprintf("Get all documents from %s collection", collectionName),
                        OperationID: fmt.Sprintf("list%s", strings.Title(collectionName)),
                        Tags:        []string{strings.Title(collectionName)},
                        Parameters:  g.generateQueryParameters(),
                        Security:    security,
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "List of documents",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "type": "array",
                                                                "items": map[string]interface{}{
                                                                        "$ref": fmt.Sprintf("#/components/schemas/%s", strings.Title(collectionName)),
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "post": OpenAPIPath{
                        Summary:     fmt.Sprintf("Create %s", collectionName),
                        Description: fmt.Sprintf("Create a new document in %s collection", collectionName),
                        OperationID: fmt.Sprintf("create%s", strings.Title(collectionName)),
                        Tags:        []string{strings.Title(collectionName)},
                        RequestBody: map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": fmt.Sprintf("#/components/schemas/%s", strings.Title(collectionName)),
                                                },
                                        },
                                },
                        },
                        Security: security,
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Document created successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": fmt.Sprintf("#/components/schemas/%s", strings.Title(collectionName)),
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        // Document operations (get, update, delete)
        spec.Paths[path+"/{id}"] = map[string]interface{}{
                "get": OpenAPIPath{
                        Summary:     fmt.Sprintf("Get %s by ID", collectionName),
                        Description: fmt.Sprintf("Get a specific document from %s collection", collectionName),
                        OperationID: fmt.Sprintf("get%sByID", strings.Title(collectionName)),
                        Tags:        []string{strings.Title(collectionName)},
                        Parameters: []interface{}{
                                map[string]interface{}{
                                        "name":        "id",
                                        "in":          "path",
                                        "required":    true,
                                        "description": "Document ID",
                                        "schema": map[string]interface{}{
                                                "type": "string",
                                        },
                                },
                        },
                        Security: security,
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Document found",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": fmt.Sprintf("#/components/schemas/%s", strings.Title(collectionName)),
                                                        },
                                                },
                                        },
                                },
                                "404": map[string]interface{}{
                                        "description": "Document not found",
                                },
                        },
                },
                "put": OpenAPIPath{
                        Summary:     fmt.Sprintf("Update %s", collectionName),
                        Description: fmt.Sprintf("Update a document in %s collection", collectionName),
                        OperationID: fmt.Sprintf("update%s", strings.Title(collectionName)),
                        Tags:        []string{strings.Title(collectionName)},
                        Parameters: []interface{}{
                                map[string]interface{}{
                                        "name":        "id",
                                        "in":          "path",
                                        "required":    true,
                                        "description": "Document ID",
                                        "schema": map[string]interface{}{
                                                "type": "string",
                                        },
                                },
                        },
                        RequestBody: map[string]interface{}{
                                "required": true,
                                "content": map[string]interface{}{
                                        "application/json": map[string]interface{}{
                                                "schema": map[string]interface{}{
                                                        "$ref": fmt.Sprintf("#/components/schemas/%s", strings.Title(collectionName)),
                                                },
                                        },
                                },
                        },
                        Security: security,
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Document updated successfully",
                                        "content": map[string]interface{}{
                                                "application/json": map[string]interface{}{
                                                        "schema": map[string]interface{}{
                                                                "$ref": fmt.Sprintf("#/components/schemas/%s", strings.Title(collectionName)),
                                                        },
                                                },
                                        },
                                },
                        },
                },
                "delete": OpenAPIPath{
                        Summary:     fmt.Sprintf("Delete %s", collectionName),
                        Description: fmt.Sprintf("Delete a document from %s collection", collectionName),
                        OperationID: fmt.Sprintf("delete%s", strings.Title(collectionName)),
                        Tags:        []string{strings.Title(collectionName)},
                        Parameters: []interface{}{
                                map[string]interface{}{
                                        "name":        "id",
                                        "in":          "path",
                                        "required":    true,
                                        "description": "Document ID",
                                        "schema": map[string]interface{}{
                                                "type": "string",
                                        },
                                },
                        },
                        Security: security,
                        Responses: map[string]interface{}{
                                "200": map[string]interface{}{
                                        "description": "Document deleted successfully",
                                },
                                "404": map[string]interface{}{
                                        "description": "Document not found",
                                },
                        },
                },
        }</span>
}

func (g *Generator) generateCollectionSchema(collection resources.Resource) map[string]interface{} <span class="cov0" title="0">{
        // Try to get collection config if it's a Collection type
        if coll, ok := collection.(*resources.Collection); ok </span><span class="cov0" title="0">{
                config := coll.GetConfig()
                if config != nil &amp;&amp; config.Properties != nil </span><span class="cov0" title="0">{
                        return g.generateSchemaFromProperties(config.Properties)
                }</span>
        }

        // Default schema for collections without explicit configuration
        <span class="cov0" title="0">return map[string]interface{}{
                "type": "object",
                "properties": map[string]interface{}{
                        "id": map[string]interface{}{
                                "type":        "string",
                                "description": "Unique document identifier",
                                "readOnly":    true,
                        },
                        "createdAt": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Document creation timestamp",
                                "readOnly":    true,
                        },
                        "updatedAt": map[string]interface{}{
                                "type":        "string",
                                "format":      "date-time",
                                "description": "Document last update timestamp",
                                "readOnly":    true,
                        },
                },
                "additionalProperties": true,
        }</span>
}

func (g *Generator) generateSchemaFromProperties(properties map[string]resources.Property) map[string]interface{} <span class="cov0" title="0">{
        schema := map[string]interface{}{
                "type":       "object",
                "properties": make(map[string]interface{}),
        }

        // Add ID field
        schemaProps := schema["properties"].(map[string]interface{})
        schemaProps["id"] = map[string]interface{}{
                "type":        "string",
                "description": "Unique document identifier",
                "readOnly":    true,
        }

        required := []string{}

        for name, prop := range properties </span><span class="cov0" title="0">{
                propSchema := g.generatePropertySchema(prop)
                schemaProps[name] = propSchema

                if prop.Required </span><span class="cov0" title="0">{
                        required = append(required, name)
                }</span>
        }

        <span class="cov0" title="0">if len(required) &gt; 0 </span><span class="cov0" title="0">{
                schema["required"] = required
        }</span>

        <span class="cov0" title="0">return schema</span>
}

func (g *Generator) generatePropertySchema(prop resources.Property) map[string]interface{} <span class="cov0" title="0">{
        schema := map[string]interface{}{}

        switch prop.Type </span>{
        case "string":<span class="cov0" title="0">
                schema["type"] = "string"</span>
        case "number":<span class="cov0" title="0">
                schema["type"] = "number"</span>
        case "boolean":<span class="cov0" title="0">
                schema["type"] = "boolean"</span>
        case "date":<span class="cov0" title="0">
                schema["type"] = "string"
                schema["format"] = "date-time"</span>
        case "array":<span class="cov0" title="0">
                schema["type"] = "array"
                schema["items"] = map[string]interface{}{"type": "string"}</span>
        case "object":<span class="cov0" title="0">
                schema["type"] = "object"
                schema["additionalProperties"] = true</span>
        default:<span class="cov0" title="0">
                schema["type"] = "string"</span>
        }

        <span class="cov0" title="0">if prop.Default != nil </span><span class="cov0" title="0">{
                schema["default"] = prop.Default
        }</span>

        <span class="cov0" title="0">return schema</span>
}

func (g *Generator) generateQueryParameters() []interface{} <span class="cov0" title="0">{
        return []interface{}{
                map[string]interface{}{
                        "name":        "limit",
                        "in":          "query",
                        "description": "Maximum number of documents to return",
                        "schema": map[string]interface{}{
                                "type":    "integer",
                                "minimum": 1,
                                "maximum": 1000,
                                "default": 100,
                        },
                },
                map[string]interface{}{
                        "name":        "skip",
                        "in":          "query",
                        "description": "Number of documents to skip",
                        "schema": map[string]interface{}{
                                "type":    "integer",
                                "minimum": 0,
                                "default": 0,
                        },
                },
                map[string]interface{}{
                        "name":        "sort",
                        "in":          "query",
                        "description": "Sort field and direction (e.g., 'name' or '-createdAt')",
                        "schema": map[string]interface{}{
                                "type": "string",
                        },
                },
        }
}</span>

// ToJSON converts the OpenAPI spec to JSON
func (spec *OpenAPISpec) ToJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.MarshalIndent(spec, "", "  ")
}</pre>
		
		<pre class="file" id="file34" style="display: none">package testutil

import (
        "context"
        "fmt"
        "math/rand"
        "os"
        "path/filepath"
        "testing"
        "time"

        "github.com/google/uuid"
        "github.com/hjanuschka/go-deployd/internal/database"
)

func init() <span class="cov0" title="0">{
        rand.Seed(time.Now().UnixNano())
}</span>

func GenerateRandomName(prefix string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%s", prefix, uuid.New().String()[:8])
}</span>

func CreateTestDB(t *testing.T) database.DatabaseInterface <span class="cov0" title="0">{
        dbType := os.Getenv("TEST_DB")
        if dbType == "" </span><span class="cov0" title="0">{
                dbType = "sqlite"
        }</span>

        <span class="cov0" title="0">var config *database.Config
        var err error

        switch dbType </span>{
        case "sqlite":<span class="cov0" title="0">
                dbPath := filepath.Join(t.TempDir(), "test.db")
                config = &amp;database.Config{
                        Name: dbPath,
                }</span>
        case "mongodb":<span class="cov0" title="0">
                mongoURL := os.Getenv("TEST_MONGO_URL")
                if mongoURL == "" </span><span class="cov0" title="0">{
                        mongoURL = "mongodb://localhost:27017"
                }</span>
                <span class="cov0" title="0">config = &amp;database.Config{
                        Host: "localhost",
                        Port: 27017,
                        Name: "test_deployd_" + GenerateRandomName("db"),
                }</span>
        case "mysql":<span class="cov0" title="0">
                config = &amp;database.Config{
                        Host:     os.Getenv("TEST_MYSQL_HOST"),
                        Port:     3306,
                        Name:     "test_deployd_" + GenerateRandomName("db"),
                        Username: os.Getenv("TEST_MYSQL_USER"),
                        Password: os.Getenv("TEST_MYSQL_PASSWORD"),
                }
                if config.Host == "" </span><span class="cov0" title="0">{
                        config.Host = "localhost"
                }</span>
                <span class="cov0" title="0">if config.Username == "" </span><span class="cov0" title="0">{
                        config.Username = "root"
                }</span>
                <span class="cov0" title="0">if config.Password == "" </span><span class="cov0" title="0">{
                        config.Password = "password"
                }</span>
        default:<span class="cov0" title="0">
                t.Fatalf("unsupported database type: %s", dbType)</span>
        }

        <span class="cov0" title="0">db, err := database.NewDatabase(database.DatabaseType(dbType), config)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create test database: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

func CreateTestCollection(t *testing.T, db database.DatabaseInterface, collectionName string) database.StoreInterface <span class="cov0" title="0">{
        if collectionName == "" </span><span class="cov0" title="0">{
                collectionName = GenerateRandomName("test_collection")
        }</span>

        <span class="cov0" title="0">store := db.CreateStore(collectionName)
        if store == nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create store for collection %s", collectionName)
        }</span>

        <span class="cov0" title="0">return store</span>
}

func CleanupCollection(t *testing.T, db database.DatabaseInterface, collectionName string) <span class="cov0" title="0">{
        store := db.CreateStore(collectionName)
        if store != nil </span><span class="cov0" title="0">{
                ctx := context.Background()
                // Try to remove all documents from the collection
                emptyQuery := database.NewQueryBuilder()
                _, _ = store.Remove(ctx, emptyQuery)
        }</span>
}

type TestUser struct {
        ID       string
        Username string
        Email    string
        Token    string
}

func CreateTestUser(t *testing.T, db database.DatabaseInterface) *TestUser <span class="cov0" title="0">{
        userStore := db.CreateStore("users")
        if userStore == nil </span><span class="cov0" title="0">{
                t.Fatal("failed to create users store")
        }</span>

        <span class="cov0" title="0">username := GenerateRandomName("testuser")
        email := fmt.Sprintf("%s@test.com", username)
        
        ctx := context.Background()
        userData := map[string]interface{}{
                "username": username,
                "email":    email,
                "password": "hashedpassword123",
                "verified": true,
        }

        result, err := userStore.Insert(ctx, userData)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create test user: %v", err)
        }</span>

        <span class="cov0" title="0">userID := ""
        if id, ok := result.(string); ok </span><span class="cov0" title="0">{
                userID = id
        }</span> else<span class="cov0" title="0"> if insertResult, ok := result.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if id, exists := insertResult["InsertedID"]; exists </span><span class="cov0" title="0">{
                        userID = id.(string)
                }</span>
        } else<span class="cov0" title="0"> {
                userID = userStore.CreateUniqueIdentifier()
        }</span>

        <span class="cov0" title="0">return &amp;TestUser{
                ID:       userID,
                Username: username,
                Email:    email,
        }</span>
}

func CleanupTestData(t *testing.T, db database.DatabaseInterface, collections []string) <span class="cov0" title="0">{
        ctx := context.Background()
        for _, collName := range collections </span><span class="cov0" title="0">{
                store := db.CreateStore(collName)
                if store != nil </span><span class="cov0" title="0">{
                        emptyQuery := database.NewQueryBuilder()
                        _, _ = store.Remove(ctx, emptyQuery)
                }</span>
        }
}

type TestContext struct {
        UserID   string
        Username string
        IsAdmin  bool
        Extra    map[string]interface{}
}

func (tc *TestContext) Value(key interface{}) interface{} <span class="cov0" title="0">{
        switch key.(type) </span>{
        case string:<span class="cov0" title="0">
                switch key </span>{
                case "userID":<span class="cov0" title="0">
                        return tc.UserID</span>
                case "username":<span class="cov0" title="0">
                        return tc.Username</span>
                case "isAdmin":<span class="cov0" title="0">
                        return tc.IsAdmin</span>
                default:<span class="cov0" title="0">
                        if tc.Extra != nil </span><span class="cov0" title="0">{
                                return tc.Extra[key.(string)]
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func CreateTestContext(userID, username string, isAdmin bool) context.Context <span class="cov0" title="0">{
        tc := &amp;TestContext{
                UserID:   userID,
                Username: username,
                IsAdmin:  isAdmin,
                Extra:    make(map[string]interface{}),
        }
        return context.WithValue(context.Background(), "testContext", tc)
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
